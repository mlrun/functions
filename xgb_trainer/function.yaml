kind: job
metadata:
  name: xgb-trainer
  tag: latest
  hash: 475fd75c37af693b6a074f626cdf442c3b25675f
  project: ''
  labels:
    author: yjb
  categories:
  - models
  - classifier
spec:
  command: ''
  args: []
  image: mlrun/ml-models:0.4.6-py37
  env: []
  default_handler: train_model
  entry_points:
    gen_xgb_model:
      name: gen_xgb_model
      doc: 'generate an xgboost model


        Multiple model types that can be estimated using

        the XGBoost Scikit-Learn API'
      parameters:
      - name: model_type
        type: str
        doc: one of "classifier", "regressor", "ranker", "rf_classifier", or "rf_regressor"
      - name: xgb_params
        type: dict
        doc: parameters passed through the  function execution context
      outputs: []
      lineno: 6
    get_sample:
      name: get_sample
      doc: "generate data sample to be split (candidate for mlrun)\n \nReturns features\
        \ matrix and header (x), and labels (y)"
      parameters:
      - name: src
        type: str
        doc: full path and filename of data artifact
      - name: sample
        type: int
        doc: sample size from data source, use negative  integers to sample randomly,
          positive to sample consecutively from the first row
      - name: label
        type: str
        doc: label column title
      - name: reader
        doc: pandas type reader (read_csv, read_parquet, ...) returning a pandas dataframe,
          and with a `dropna` attribute
      outputs: []
      lineno: 44
    get_splits:
      name: get_splits
      doc: 'generate train and test sets (candidate for mlrun)


        cross validation:

        1. cut out a test set

        2a. use the training set in a cross validation scheme, or

        2b. make another split to generate a validation set


        2 parts (n_ways=2): train and test set only

        3 parts (n_ways=3): train, validation and test set

        4 parts (n_ways=4): n_ways=3 + a held-out probability calibration set'
      parameters:
      - name: raw
        doc: dataframe or numpy array of raw features
      - name: labels
        doc: dataframe or numpy array of raw labels
      - name: n_ways
        type: int
        doc: (3) split data into 2, 3, or 4 parts
        default: 3
      - name: test_size
        type: float
        doc: proportion of raw data to set asid as test data
        default: 0.15
      - name: valid_size
        type: float
        doc: proportion of remaining data to be set as validation
        default: 0.3
      - name: label_names
        type: list
        doc: label names
        default:
        - labels
      - name: random_state
        type: int
        doc: (1) random number seed
        default: 1
      outputs: []
      lineno: 77
    save_test_set:
      name: save_test_set
      doc: log a held out test set
      parameters:
      - name: context
        doc: the function execution context
      - name: xtest
        doc: test features, as np.ndarray output from `get_splits`
      - name: ytest
        doc: test labels, as np.ndarray output from `get_splits`
      - name: header
        type: list
        doc: ([])features header if required
      - name: label
        type: str
        doc: ("labels") name of label column
        default: labels
      - name: file_ext
        type: str
        doc: format of test set file
        default: parquet
      - name: index
        type: bool
        doc: preserve index column
      - name: debug
        type: bool
        doc: (False)
      outputs: []
      lineno: 135
    dump_xgb_model:
      name: dump_xgb_model
      doc: 'serialize/log model


        XGBoost model can be save in 3 different ways:

        1. pickle the internal _booster object, inside the model

        2. using model.save_model("fn.bin") using a legacy binary xgb format

        2. using model.save_model("fn.json") using a portable json format'
      parameters:
      - name: context
        doc: the function"s execution context
      - name: model
        doc: the fitted xgboost model
      - name: dump_type
        type: str
        doc: '"pickle" legacy", or "json", '
      - name: dest_folder
        type: str
        doc: 'path for serialized model '
      - name: dest_name
        type: str
        doc: name for serialized model file
      outputs: []
      lineno: 169
    plot_confusion_matrix:
      name: plot_confusion_matrix
      doc: prints and plots the confusion matrix.
      parameters:
      - name: labels
      - name: predictions
      - name: classes
      - name: normalize
        default: all
      - name: title
        default: Confusion matrix
      - name: cmap
      outputs: []
      lineno: 204
    plot_roc:
      name: plot_roc
      doc: "plot roc curves\n\nTODO:  add averaging method (as string) that was used\
        \ to create probs, \ndisplay in legend"
      parameters:
      - name: context
        doc: the function context
      - name: y_labels
        doc: 'ground truth labels, hot encoded for multiclass  '
      - name: y_probs
        doc: model prediction probabilities
      - name: fpr_label
        type: str
        doc: ("false positive rate") x-axis labels
        default: false positive rate
      - name: tpr_label
        type: str
        doc: ("true positive rate") y-axis labels
        default: true positive rate
      - name: title
        type: str
        doc: ("roc curve") title of plot
        default: roc curve
      - name: legend_loc
        type: str
        doc: ("best") location of plot legend
        default: best
      outputs: []
      lineno: 242
    gen_proba:
      name: gen_proba
      doc: generate predictions and validation stats
      parameters:
      - name: context
        doc: the function execution context
      - name: feats
        doc: 'validation features array '
      - name: labels
        doc: validation ground-truth labels
      - name: model
        doc: estimated model
      - name: score_method
      - name: plots_dest
        doc: destination folder for plot artifacts
      - name: ntree_limit
        doc: (None) limit no. trees used in prediction
      - name: validate_features
        doc: (True) ensure consistent feature names  between model and input data
        default: true
      - name: base_margin
        doc: (None) undefined
      outputs: []
      lineno: 296
    proba_calibration:
      name: proba_calibration
      doc: calibrate output probabilities
      parameters:
      - name: model
      - name: xcal
      - name: ycal
      outputs: []
      lineno: 348
    train_model:
      name: train_model
      doc: train an xgboost model.
      parameters:
      - name: context
        doc: the function context
      - name: model_type
        type: str
        doc: the model type to train, 'classifier', 'regressor'...
      - name: dataset
        doc: ("data") name of raw data file
      - name: label_column
        type: str
        doc: ground-truth (y) labels
        default: labels
      - name: sample
        type: int
        doc: Selects the first n rows, or select a sample starting from the first.
          If negative <-1, select a random sample
        default: <_ast.USub object at 0x7fc469966eb8>
      - name: test_size
        type: float
        doc: (0.05) test set size
        default: 0.05
      - name: valid_size
        type: float
        doc: (0.75) Once the test set has been removed the training set gets this
          proportion.
        default: 0.75
      - name: random_state
        type: int
        doc: (1) sklearn rng seed
        default: 1
      - name: model_filename
        type: str
        doc: model file filename, points to a directory
        default: xgb-model
      - name: models_dest
        type: str
        doc: models subfolder on artifact path
      - name: plots_dest
        type: str
        doc: plot subfolder on artifact path
      - name: score_method
        type: str
        doc: for multiclass classification
        default: micro
      - name: file_ext
        type: str
        doc: format for test_set_key hold out data
        default: parquet
      - name: model_pkg_file
        type: str
        doc: json model config file
      outputs: []
      lineno: 371
  description: train any classifier using scikit-learn's API
  build:
    functionSourceCode: IyBHZW5lcmF0ZWQgYnkgbnVjbGlvLmV4cG9ydC5OdWNsaW9FeHBvcnRlciBvbiAyMDIwLTA0LTI4IDIxOjIwCgppbXBvcnQgd2FybmluZ3MKd2FybmluZ3Muc2ltcGxlZmlsdGVyKGFjdGlvbj0iaWdub3JlIiwgY2F0ZWdvcnk9RnV0dXJlV2FybmluZykKCmRlZiBnZW5feGdiX21vZGVsKG1vZGVsX3R5cGU6IHN0ciwgeGdiX3BhcmFtczogZGljdCk6CiAgICAiIiJnZW5lcmF0ZSBhbiB4Z2Jvb3N0IG1vZGVsCiAgICAKICAgIE11bHRpcGxlIG1vZGVsIHR5cGVzIHRoYXQgY2FuIGJlIGVzdGltYXRlZCB1c2luZwogICAgdGhlIFhHQm9vc3QgU2Npa2l0LUxlYXJuIEFQSQogICAgCiAgICA6cGFyYW0gbW9kZWxfdHlwZTogb25lIG9mICJjbGFzc2lmaWVyIiwgInJlZ3Jlc3NvciIsCiAgICAgICAgICAgICAgICAgICAgICAgInJhbmtlciIsICJyZl9jbGFzc2lmaWVyIiwgb3IKICAgICAgICAgICAgICAgICAgICAgICJyZl9yZWdyZXNzb3IiCiAgICA6cGFyYW0geGdiX3BhcmFtczogcGFyYW1ldGVycyBwYXNzZWQgdGhyb3VnaCB0aGUgCiAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgICIiIgogICAgZnJvbSBqc29uIGltcG9ydCBsb2FkCiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdldF9jbGFzc19maXQsIGNyZWF0ZV9jbGFzcwoKICAgIG10eXBlcyA9IHsKICAgICAgICAiY2xhc3NpZmllciIgICA6ICJ4Z2Jvb3N0LlhHQkNsYXNzaWZpZXIiLAogICAgICAgICJyZWdyZXNzb3IiICAgIDogInhnYm9vc3QuWEdCUmVncmVzc29yIiwKICAgICAgICAicmFua2VyIiAgICAgICA6ICJ4Z2Jvb3N0LlhHQlJhbmtlciIsCiAgICAgICAgInJmX2NsYXNzaWZpZXIiOiAieGdib29zdC5YR0JSRkNsYXNzaWZpZXIiLAogICAgICAgICJyZl9yZWdyZXNzb3IiIDogInhnYm9vc3QuWEdCUkZSZWdyZXNzb3IiCiAgICB9CiAgICBpZiBtb2RlbF90eXBlIG5vdCBpbiBtdHlwZXMua2V5cygpOgogICAgICAgIHJhaXNlIEV4Y2VwdGlvbigidW5yZWNvZ25pemVkIG1vZGVsIHR5cGVzLCBzZWUgaGVscCBkb2N1bWVudGF0aW9uIikKICAgIAogICAgbW9kZWxfY29uZmlnID0gZ2V0X2NsYXNzX2ZpdChtdHlwZXNbbW9kZWxfdHlwZV0pCgogICAgZm9yIGssIHYgaW4geGdiX3BhcmFtczoKICAgICAgICBpZiBrLnN0YXJ0c3dpdGgoIkNMQVNTXyIpOgogICAgICAgICAgICBtb2RlbF9jb25maWdbIkNMQVNTIl1ba1s2Ol1dID0gdgogICAgICAgIGlmIGsuc3RhcnRzd2l0aCgiRklUXyIpOgogICAgICAgICAgICBtb2RlbF9jb25maWdbIkZJVCJdW2tbNDpdXSA9IHYKCiAgICBDbGFzc2lmaWVyQ2xhc3MgPSBjcmVhdGVfY2xhc3MobW9kZWxfY29uZmlnWyJNRVRBIl1bImNsYXNzIl0pCiAgICBtb2RlbCA9IENsYXNzaWZpZXJDbGFzcygqKm1vZGVsX2NvbmZpZ1siQ0xBU1MiXSkKCiAgICByZXR1cm4gbW9kZWwsIG1vZGVsX2NvbmZpZwoKZGVmIGdldF9zYW1wbGUoc3JjOnN0ciwgc2FtcGxlOiBpbnQsIGxhYmVsOiBzdHIsIHJlYWRlcj1Ob25lKToKICAgICIiImdlbmVyYXRlIGRhdGEgc2FtcGxlIHRvIGJlIHNwbGl0IChjYW5kaWRhdGUgZm9yIG1scnVuKQogICAgIAogICAgUmV0dXJucyBmZWF0dXJlcyBtYXRyaXggYW5kIGhlYWRlciAoeCksIGFuZCBsYWJlbHMgKHkpCiAgICA6cGFyYW0gc3JjOiAgICBmdWxsIHBhdGggYW5kIGZpbGVuYW1lIG9mIGRhdGEgYXJ0aWZhY3QKICAgIDpwYXJhbSBzYW1wbGU6IHNhbXBsZSBzaXplIGZyb20gZGF0YSBzb3VyY2UsIHVzZSBuZWdhdGl2ZSAKICAgICAgICAgICAgICAgICAgIGludGVnZXJzIHRvIHNhbXBsZSByYW5kb21seSwgcG9zaXRpdmUgdG8KICAgICAgICAgICAgICAgICAgIHNhbXBsZSBjb25zZWN1dGl2ZWx5IGZyb20gdGhlIGZpcnN0IHJvdwogICAgOnBhcmFtIGxhYmVsOiAgbGFiZWwgY29sdW1uIHRpdGxlCiAgICA6cGFyYW0gcmVhZGVyOiBwYW5kYXMgdHlwZSByZWFkZXIgKHJlYWRfY3N2LCByZWFkX3BhcnF1ZXQsIC4uLikgcmV0dXJuaW5nCiAgICAgICAgICAgICAgICAgICBhIHBhbmRhcyBkYXRhZnJhbWUsIGFuZCB3aXRoIGEgYGRyb3BuYWAgYXR0cmlidXRlCiAgICAiIiIKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIAogICAgaWYgbm90IHJlYWRlcjoKICAgICAgICBpZiBzcmMuZW5kc3dpdGgoImNzdiIpOgogICAgICAgICAgICByZWFkZXIgPSBwZC5yZWFkX2NzdgogICAgICAgIGVsaWYgc3JjLmVuZHN3aXRoKCJwYXJxdWV0Iikgb3Igc3JjLmVuZHN3aXRoKCJwcSIpOgogICAgICAgICAgICByZWFkZXIgPSBwZC5yZWFkX3BhcnF1ZXQKICAgICAgICBlbHNlOgogICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oZiJmaWxlIHR5cGUgdW5oYW5kbGVkIHtzcmN9IikKCiAgICBpZiAoc2FtcGxlID09IC0xKSBvciAoc2FtcGxlID49IDEpOgogICAgICAgIHJhdyA9IHJlYWRlcihzcmMpLmRyb3BuYSgpCiAgICAgICAgbGFiZWxzID0gcmF3LnBvcChsYWJlbCkKICAgICAgICByYXcgPSByYXcuaWxvY1s6c2FtcGxlLCA6XQogICAgICAgIGxhYmVscyA9IGxhYmVscy5pbG9jWzpzYW1wbGVdCiAgICBlbHNlOgogICAgICAgIHJhdyA9IHJlYWRlcihzcmMpLmRyb3BuYSgpLnNhbXBsZShzYW1wbGUgKiAtMSkKICAgICAgICBsYWJlbHMgPSByYXcucG9wKGxhYmVsKQoKICAgIHJldHVybiByYXcsIGxhYmVscywgcmF3LmNvbHVtbnMudmFsdWVzCgpkZWYgZ2V0X3NwbGl0cygKICAgIHJhdywgCiAgICBsYWJlbHMsIAogICAgbl93YXlzOiBpbnQgPSAzLAogICAgdGVzdF9zaXplOiBmbG9hdCA9IDAuMTUsCiAgICB2YWxpZF9zaXplOiBmbG9hdCA9IDAuMzAsCiAgICBsYWJlbF9uYW1lczogbGlzdCA9IFsibGFiZWxzIl0sCiAgICByYW5kb21fc3RhdGU6IGludCA9IDEKKToKICAgICIiImdlbmVyYXRlIHRyYWluIGFuZCB0ZXN0IHNldHMgKGNhbmRpZGF0ZSBmb3IgbWxydW4pCgogICAgY3Jvc3MgdmFsaWRhdGlvbjoKICAgIDEuIGN1dCBvdXQgYSB0ZXN0IHNldAogICAgMmEuIHVzZSB0aGUgdHJhaW5pbmcgc2V0IGluIGEgY3Jvc3MgdmFsaWRhdGlvbiBzY2hlbWUsIG9yCiAgICAyYi4gbWFrZSBhbm90aGVyIHNwbGl0IHRvIGdlbmVyYXRlIGEgdmFsaWRhdGlvbiBzZXQKICAgIAogICAgMiBwYXJ0cyAobl93YXlzPTIpOiB0cmFpbiBhbmQgdGVzdCBzZXQgb25seQogICAgMyBwYXJ0cyAobl93YXlzPTMpOiB0cmFpbiwgdmFsaWRhdGlvbiBhbmQgdGVzdCBzZXQKICAgIDQgcGFydHMgKG5fd2F5cz00KTogbl93YXlzPTMgKyBhIGhlbGQtb3V0IHByb2JhYmlsaXR5IGNhbGlicmF0aW9uIHNldAogICAgCiAgICA6cGFyYW0gcmF3OiAgICAgICAgICAgIGRhdGFmcmFtZSBvciBudW1weSBhcnJheSBvZiByYXcgZmVhdHVyZXMKICAgIDpwYXJhbSBsYWJlbHM6ICAgICAgICAgZGF0YWZyYW1lIG9yIG51bXB5IGFycmF5IG9mIHJhdyBsYWJlbHMKICAgIDpwYXJhbSBuX3dheXM6ICAgICAgICAgKDMpIHNwbGl0IGRhdGEgaW50byAyLCAzLCBvciA0IHBhcnRzCiAgICA6cGFyYW0gdGVzdF9zaXplOiAgICAgIHByb3BvcnRpb24gb2YgcmF3IGRhdGEgdG8gc2V0IGFzaWQgYXMgdGVzdCBkYXRhCiAgICA6cGFyYW0gdmFsaWRfc2l6ZTogICAgIHByb3BvcnRpb24gb2YgcmVtYWluaW5nIGRhdGEgdG8gYmUgc2V0IGFzIHZhbGlkYXRpb24KICAgIDpwYXJhbSBsYWJlbF9uYW1lczogICAgICAgICBsYWJlbCBuYW1lcwogICAgOnBhcmFtIHJhbmRvbV9zdGF0ZTogICAoMSkgcmFuZG9tIG51bWJlciBzZWVkCiAgICAiIiIKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIGltcG9ydCBudW1weSBhcyBucAogICAgZnJvbSBza2xlYXJuLm1vZGVsX3NlbGVjdGlvbiBpbXBvcnQgdHJhaW5fdGVzdF9zcGxpdAogICAgCiAgICBpZiBpc2luc3RhbmNlKHJhdywgbnAubmRhcnJheSk6CiAgICAgICAgaWYgbGFiZWxzLm5kaW09PTE6CiAgICAgICAgICAgIGxhYmVscz1sYWJlbHMucmVzaGFwZSgtMSwxKQogICAgICAgIHh5ID0gbnAuY29uY2F0ZW5hdGUoW3JhdywgbGFiZWxzXSwgYXhpcz0xKQogICAgZWxzZToKICAgICAgICBpZiBpc2luc3RhbmNlKGxhYmVscywgcGQuU2VyaWVzKToKICAgICAgICAgICAgbGFiZWxzID0gcGQuRGF0YUZyYW1lKGRhdGE9bGFiZWxzLCBjb2x1bW5zPWxhYmVsX25hbWVzKQogICAgICAgIHh5ID0gcGQuY29uY2F0KFtyYXcsIGxhYmVsc10sIGF4aXM9MSkKICAgICAgICAKICAgIHgsIHh0ZSwgeSwgeXRlID0gdHJhaW5fdGVzdF9zcGxpdCh4eSwgbGFiZWxzLCB0ZXN0X3NpemU9dGVzdF9zaXplLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICBpZiBuX3dheXM9PTI6CiAgICAgICAgcmV0dXJuICh4LCB5KSwgKHh0ZSwgeXRlKSwgTm9uZSwgTm9uZQogICAgZWxpZiBuX3dheXM9PTM6CiAgICAgICAgeHRyLCB4dmEsIHl0ciwgeXZhID0gdHJhaW5fdGVzdF9zcGxpdCh4LCB5LHRyYWluX3NpemU9dmFsaWRfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICAgICAgcmV0dXJuICh4dHIsIHl0ciksICh4dmEsIHl2YSksICh4dGUsIHl0ZSksIE5vbmUKICAgIGVsaWYgbl93YXlzPT00OgogICAgICAgIHh0LCB4dmEsIHl0LCB5dmEgPSB0cmFpbl90ZXN0X3NwbGl0KHgsIHksdHJhaW5fc2l6ZT12YWxpZF9zaXplLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZG9tX3N0YXRlPXJhbmRvbV9zdGF0ZSkKICAgICAgICB4dHIsIHhjYWwsIHl0ciwgeWNhbCA9IHRyYWluX3Rlc3Rfc3BsaXQoeHQsIHl0LCB0cmFpbl9zaXplPTAuOCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICAgICAgcmV0dXJuICh4dHIsIHl0ciksICh4dmEsIHl2YSksICh4dGUsIHl0ZSksICh4Y2FsLCB5Y2FsKQogICAgZWxzZToKICAgICAgICByYWlzZSBFeGNlcHRpb24oIm5fd2F5cyBtdXN0IGJlIGluIHRoZSByYW5nZSBbMiw0XSIpCgpkZWYgc2F2ZV90ZXN0X3NldCgKICAgIGNvbnRleHQsIAogICAgeHRlc3QsIAogICAgeXRlc3QsIAogICAgaGVhZGVyOiBsaXN0LCAKICAgIGxhYmVsOiBzdHIgPSAibGFiZWxzIiwgCiAgICBmaWxlX2V4dDogc3RyID0gInBhcnF1ZXQiLCAKICAgIGluZGV4OiBib29sID0gRmFsc2UsCiAgICBkZWJ1ZzogYm9vbCA9IEZhbHNlCik6CiAgICAiIiJsb2cgYSBoZWxkIG91dCB0ZXN0IHNldAoKICAgIDpwYXJhbSBjb250ZXh0OiAgICB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgIDpwYXJhbSB4dGVzdDogICAgICB0ZXN0IGZlYXR1cmVzLCBhcyBucC5uZGFycmF5IG91dHB1dCBmcm9tIGBnZXRfc3BsaXRzYAogICAgOnBhcmFtIHl0ZXN0OiAgICAgIHRlc3QgbGFiZWxzLCBhcyBucC5uZGFycmF5IG91dHB1dCBmcm9tIGBnZXRfc3BsaXRzYAogICAgOnBhcmFtIGhlYWRlcjogICAgIChbXSlmZWF0dXJlcyBoZWFkZXIgaWYgcmVxdWlyZWQKICAgIDpwYXJhbSBsYWJlbDogICAgICAoImxhYmVscyIpIG5hbWUgb2YgbGFiZWwgY29sdW1uCiAgICA6cGFyYW0gZmlsZV9leHQ6ICAgZm9ybWF0IG9mIHRlc3Qgc2V0IGZpbGUKICAgIDpwYXJhbSBpbmRleDogICAgICBwcmVzZXJ2ZSBpbmRleCBjb2x1bW4KICAgIDpwYXJhbSBkZWJ1ZzogICAgICAoRmFsc2UpCiAgICAiIiIKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIGZyb20gbWxydW4gaW1wb3J0IG1sY29uZgogICAgCiAgICB0ZXN0X3NldCA9IHBkLmNvbmNhdCgKICAgICAgICBbcGQuRGF0YUZyYW1lKGRhdGE9eHRlc3QsIGNvbHVtbnM9aGVhZGVyKSwKICAgICAgICAgcGQuRGF0YUZyYW1lKGRhdGE9eXRlc3QudmFsdWVzLCBjb2x1bW5zPVtsYWJlbF0pXSwKICAgICAgICBheGlzPTEsKQogICAgCiAgICBpZiBkZWJ1ZzoKICAgICAgICB0ZXN0X3NldC50b19wYXJxdWV0KG1sY29uZi5hcnRpZmFjdF9wYXRoKycvdGVzdF9zZXQtZGV2LnBhcnF1ZXQnKQogICAgICAgIAogICAgY29udGV4dC5sb2dfZGF0YXNldCgidGVzdF9zZXQiLCBkZj10ZXN0X3NldCwgZm9ybWF0PWZpbGVfZXh0LCBpbmRleD1pbmRleCkKCmRlZiBkdW1wX3hnYl9tb2RlbCgKICAgIGNvbnRleHQsIAogICAgbW9kZWwsCiAgICBkdW1wX3R5cGU6IHN0ciwKICAgIGRlc3RfZm9sZGVyOiBzdHIsCiAgICBkZXN0X25hbWU6IHN0cgopOgogICAgIiIic2VyaWFsaXplL2xvZyBtb2RlbAogICAgCiAgICBYR0Jvb3N0IG1vZGVsIGNhbiBiZSBzYXZlIGluIDMgZGlmZmVyZW50IHdheXM6CiAgICAxLiBwaWNrbGUgdGhlIGludGVybmFsIF9ib29zdGVyIG9iamVjdCwgaW5zaWRlIHRoZSBtb2RlbAogICAgMi4gdXNpbmcgbW9kZWwuc2F2ZV9tb2RlbCgiZm4uYmluIikgdXNpbmcgYSBsZWdhY3kgYmluYXJ5IHhnYiBmb3JtYXQKICAgIDIuIHVzaW5nIG1vZGVsLnNhdmVfbW9kZWwoImZuLmpzb24iKSB1c2luZyBhIHBvcnRhYmxlIGpzb24gZm9ybWF0CiAgICAKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgdGhlIGZ1bmN0aW9uInMgZXhlY3V0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBtb2RlbDogICAgICAgdGhlIGZpdHRlZCB4Z2Jvb3N0IG1vZGVsCiAgICA6cGFyYW0gZHVtcF90eXBlOiAgICJwaWNrbGUiIGxlZ2FjeSIsIG9yICJqc29uIiwgCiAgICA6cGFyYW0gZGVzdF9mb2xkZXI6IHBhdGggZm9yIHNlcmlhbGl6ZWQgbW9kZWwgCiAgICA6cGFyYW0gZGVzdF9uYW1lOiAgIG5hbWUgZm9yIHNlcmlhbGl6ZWQgbW9kZWwgZmlsZQogICAgIiIiCiAgICBmcm9tIGNsb3VkcGlja2xlIGltcG9ydCBkdW1wcywgZHVtcAogICAgdHJ5OgogICAgICAgIG1vZGVsLnNhdmVfbW9kZWwoZiJ7ZGVzdF9mb2xkZXJ9L3tkZXN0X25hbWV9LXNhdmVfbW9kZWwucGtsIikKICAgICAgICAKICAgICAgICBtb2RlbC5zYXZlX21vZGVsKGYie2Rlc3RfZm9sZGVyfS97ZGVzdF9uYW1lfS1zYXZlX21vZGVsLmpzb24iKQogICAgICAgIAogICAgICAgIF9ib29zdGVyID0gbW9kZWwuZ2V0X2Jvb3N0ZXIoKQogICAgICAgIGR1bXAoX2Jvb3N0ZXIsIG9wZW4oZiJ7ZGVzdF9mb2xkZXJ9L3tkZXN0X25hbWV9LWR1bXAucGtsIiwgIndiIikpCiAgICAgICAgZHVtcChtb2RlbCwgb3BlbihmIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0tZHVtcC1tb2RlbC5wa2wiLCAid2IiKSkKICAgICAgICAKICAgICAgICBkYXRhID0gZHVtcHMoX2Jvb3N0ZXIpCiAgICAgICAgY29udGV4dC5sb2dfYXJ0aWZhY3QoInhnYi1tb2RlbC1tbHJ1bi5wa2wiLCBib2R5PWRhdGEsIGFydGlmYWN0X3BhdGg9ZiJ7ZGVzdF9mb2xkZXJ9IikKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBwcmludCgieGdib29zdCBtb2RlbCBzZXJpYWxpemF0aW9uIGVycm9yIiwgc3RyKGUpKQoKZGVmIHBsb3RfY29uZnVzaW9uX21hdHJpeCgKICAgIGxhYmVscywKICAgIHByZWRpY3Rpb25zLAogICAgY2xhc3NlcywKICAgIG5vcm1hbGl6ZT0iYWxsIiwKICAgIHRpdGxlPSdDb25mdXNpb24gbWF0cml4JywKICAgIGNtYXA9Tm9uZQopOgogICAgIiIicHJpbnRzIGFuZCBwbG90cyB0aGUgY29uZnVzaW9uIG1hdHJpeC4KICAgIAogICAgIiIiCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIGltcG9ydCBudW1weSBhcyBucAogICAgaW1wb3J0IGl0ZXJ0b29scwogICAgCiAgICBpZiBub3QgY21hcDoKICAgICAgICBjbWFwID0gcGx0LmNtLkJsdWVzCgogICAgY20gPSBtZXRyaWNzLmNvbmZ1c2lvbl9tYXRyaXgobGFiZWxzLCBwcmVkaWN0aW9ucywgbm9ybWFsaXplPW5vcm1hbGl6ZSkKICAgIAogICAgcGx0Lmltc2hvdyhjbSwgaW50ZXJwb2xhdGlvbj0nbmVhcmVzdCcsIGNtYXA9Y21hcCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5jb2xvcmJhcigpCiAgICB0aWNrX21hcmtzID0gbnAuYXJhbmdlKGxlbihjbGFzc2VzKSkKICAgIHBsdC54dGlja3ModGlja19tYXJrcywgY2xhc3Nlcywgcm90YXRpb249NDUpCiAgICBwbHQueXRpY2tzKHRpY2tfbWFya3MsIGNsYXNzZXMpCgogICAgdGhyZXNoID0gY20ubWF4KCkgLyAyLgogICAgZm9yIGksIGogaW4gaXRlcnRvb2xzLnByb2R1Y3QocmFuZ2UoY20uc2hhcGVbMF0pLCByYW5nZShjbS5zaGFwZVsxXSkpOgogICAgICAgIHBsdC50ZXh0KGosIGksIHJvdW5kKGNtW2ksIGpdLCAyKSwKICAgICAgICAgICAgICAgICBob3Jpem9udGFsYWxpZ25tZW50PSJjZW50ZXIiLAogICAgICAgICAgICAgICAgIGNvbG9yPSJ3aGl0ZSIgaWYgY21baSwgal0gPiB0aHJlc2ggZWxzZSAiYmxhY2siKQoKICAgIHBsdC55bGFiZWwoJ1RydWUgbGFiZWwnKQogICAgcGx0LnhsYWJlbCgnUHJlZGljdGVkIGxhYmVsJykKICAgIHJldHVybiBwbHQuZ2NmKCkKCmRlZiBwbG90X3JvYygKICAgIGNvbnRleHQsCiAgICB5X2xhYmVscywKICAgIHlfcHJvYnMsCiAgICBmcHJfbGFiZWw6IHN0ciA9ICJmYWxzZSBwb3NpdGl2ZSByYXRlIiwKICAgIHRwcl9sYWJlbDogc3RyID0gInRydWUgcG9zaXRpdmUgcmF0ZSIsCiAgICB0aXRsZTogc3RyID0gInJvYyBjdXJ2ZSIsCiAgICBsZWdlbmRfbG9jOiBzdHIgPSAiYmVzdCIsCik6CiAgICAiIiJwbG90IHJvYyBjdXJ2ZXMKCiAgICBUT0RPOiAgYWRkIGF2ZXJhZ2luZyBtZXRob2QgKGFzIHN0cmluZykgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgcHJvYnMsIAogICAgZGlzcGxheSBpbiBsZWdlbmQKCiAgICA6cGFyYW0gY29udGV4dDogICAgICB0aGUgZnVuY3Rpb24gY29udGV4dAogICAgOnBhcmFtIHlfbGFiZWxzOiAgICAgZ3JvdW5kIHRydXRoIGxhYmVscywgaG90IGVuY29kZWQgZm9yIG11bHRpY2xhc3MgIAogICAgOnBhcmFtIHlfcHJvYnM6ICAgICAgbW9kZWwgcHJlZGljdGlvbiBwcm9iYWJpbGl0aWVzCiAgICA6cGFyYW0ga2V5OiAgICAgICAgICAoInJvYyIpIGtleSBvZiBwbG90IGluIGFydGlmYWN0IHN0b3JlCiAgICA6cGFyYW0gcGxvdHNfZGlyOiAgICAoInBsb3RzIikgZGVzdGluYXRpb24gZm9sZGVyIHJlbGF0aXZlIHBhdGggdG8gYXJ0aWZhY3QgcGF0aAogICAgOnBhcmFtIGZtdDogICAgICAgICAgKCJwbmciKSBwbG90IGZvcm1hdAogICAgOnBhcmFtIGZwcl9sYWJlbDogICAgKCJmYWxzZSBwb3NpdGl2ZSByYXRlIikgeC1heGlzIGxhYmVscwogICAgOnBhcmFtIHRwcl9sYWJlbDogICAgKCJ0cnVlIHBvc2l0aXZlIHJhdGUiKSB5LWF4aXMgbGFiZWxzCiAgICA6cGFyYW0gdGl0bGU6ICAgICAgICAoInJvYyBjdXJ2ZSIpIHRpdGxlIG9mIHBsb3QKICAgIDpwYXJhbSBsZWdlbmRfbG9jOiAgICgiYmVzdCIpIGxvY2F0aW9uIG9mIHBsb3QgbGVnZW5kCiAgICAiIiIKICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgZnJvbSBtbHJ1bi5tbHV0aWxzIGltcG9ydCBnY2ZfY2xlYXIKICAgIAogICAgZ2NmX2NsZWFyKHBsdCkKCiAgICBwbHQucGxvdChbMCwgMV0sIFswLCAxXSwgImstLSIpCgogICAgcGx0LnhsYWJlbChmcHJfbGFiZWwpCiAgICBwbHQueWxhYmVsKHRwcl9sYWJlbCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5sZWdlbmQobG9jPWxlZ2VuZF9sb2MpCgogICAgaWYgeV9sYWJlbHMubmRpbSA+IDI6CiAgICAgICAgZnByID0gZGljdCgpCiAgICAgICAgdHByID0gZGljdCgpCiAgICAgICAgcm9jX2F1YyA9IGRpY3QoKQogICAgICAgIGZvciBpIGluIHJhbmdlKHlfbGFiZWxzWzosIDotMV0uc2hhcGVbMV0pOgogICAgICAgICAgICBmcHJbaV0sIHRwcltpXSwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKAogICAgICAgICAgICAgICAgeV9sYWJlbHNbOiwgaV0sIHlfcHJvYnNbOiwgaV0sIHBvc19sYWJlbD0xCiAgICAgICAgICAgICkKICAgICAgICAgICAgcm9jX2F1Y1tpXSA9IG1ldHJpY3MuYXVjKGZwcltpXSwgdHByW2ldKQogICAgICAgICAgICBwbHQucGxvdChmcHJbaV0sIHRwcltpXSwgbGFiZWw9ZiJjbGFzcyB7aX0iKQogICAgZWxzZToKICAgICAgICBmcHIsIHRwciwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKHlfbGFiZWxzLCB5X3Byb2JzWzosLTFdKQogICAgICAgIHBsdC5wbG90KGZwciwgdHByLCBsYWJlbD1mInBvc2l0aXZlIGNsYXNzIikKCiAgICByZXR1cm4gcGx0LmdjZigpCgpkZWYgZ2VuX3Byb2JhKAogICAgY29udGV4dCwKICAgIGZlYXRzLAogICAgbGFiZWxzLAogICAgbW9kZWwsCiAgICBzY29yZV9tZXRob2QsCiAgICBwbG90c19kZXN0LAogICAgbnRyZWVfbGltaXQ9Tm9uZSwKICAgIHZhbGlkYXRlX2ZlYXR1cmVzPVRydWUsCiAgICBiYXNlX21hcmdpbj1Ob25lCik6CiAgICAiIiIgZ2VuZXJhdGUgcHJlZGljdGlvbnMgYW5kIHZhbGlkYXRpb24gc3RhdHMKICAgIAogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBmZWF0czogICAgICAgICAgICAgdmFsaWRhdGlvbiBmZWF0dXJlcyBhcnJheSAKICAgIDpwYXJhbSBsYWJlbHM6ICAgICAgICAgICAgdmFsaWRhdGlvbiBncm91bmQtdHJ1dGggbGFiZWxzCiAgICA6cGFyYW0gbW9kZWw6ICAgICAgICAgICAgIGVzdGltYXRlZCBtb2RlbAogICAgOnBhcmFtIHNjcm9yZV9tZXRob2Q6ICAgICAoImF2ZXJhZ2UiKSBtdWx0aWNsYXNzIHNjb3JpbmcKICAgIDpwYXJhbSBwbG90c19kZXN0OiAgICAgICAgZGVzdGluYXRpb24gZm9sZGVyIGZvciBwbG90IGFydGlmYWN0cwogICAgOnBhcmFtIG50cmVlX2xpbWl0OiAgICAgICAoTm9uZSkgbGltaXQgbm8uIHRyZWVzIHVzZWQgaW4gcHJlZGljdGlvbgogICAgOnBhcmFtIHZhbGlkYXRlX2ZlYXR1cmVzOiAoVHJ1ZSkgZW5zdXJlIGNvbnNpc3RlbnQgZmVhdHVyZSBuYW1lcyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV0d2VlbiBtb2RlbCBhbmQgaW5wdXQgZGF0YQogICAgOnBhcmFtIGJhc2VfbWFyZ2luOiAgICAgICAoTm9uZSkgdW5kZWZpbmVkCiAgICAiIiIKICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgZnJvbSBtbHJ1bi5hcnRpZmFjdHMgaW1wb3J0IFBsb3RBcnRpZmFjdAogICAgZnJvbSBtbHJ1bi5tbHV0aWxzIGltcG9ydCBnY2ZfY2xlYXIKICAgIGZyb20geGdib29zdCBpbXBvcnQgWEdCQ2xhc3NpZmllcgogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgCiAgICB5cHJlZCA9IG1vZGVsLnByZWRpY3QoZmVhdHMsIEZhbHNlLCBudHJlZV9saW1pdCwgdmFsaWRhdGVfZmVhdHVyZXMsIGJhc2VfbWFyZ2luKQogICAgCiAgICB5X3Byb2JhID0gW10KICAgIGlmIGhhc2F0dHIobW9kZWwsICJwcmVkaWN0X3Byb2JhIik6CiAgICAgICAgeV9wcm9iYSA9IG1vZGVsLnByZWRpY3RfcHJvYmEoZmVhdHMsIG50cmVlX2xpbWl0LCB2YWxpZGF0ZV9mZWF0dXJlcywgYmFzZV9tYXJnaW4pCiAgICB5cHJlZF9iaW5hcnkgPSBbcm91bmQodmFsdWUpIGZvciB2YWx1ZSBpbiB5X3Byb2JhWzosLTFdXQogICAgCiAgICBhdmVyYWdlX3ByZWNpc2lvbiA9IG1ldHJpY3MuYXZlcmFnZV9wcmVjaXNpb25fc2NvcmUobGFiZWxzLCB5X3Byb2JhWzosLTFdLCBhdmVyYWdlPXNjb3JlX21ldGhvZCkKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmImF2Z19wcmVjaXNpb24iLCBhdmVyYWdlX3ByZWNpc2lvbikKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmInJvY2F1YyIsIG1ldHJpY3Mucm9jX2F1Y19zY29yZShsYWJlbHMsIHlfcHJvYmFbOiwtMV0pKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYiYWNjdXJhY3lfc2NvcmUiLCBmbG9hdChtZXRyaWNzLmFjY3VyYWN5X3Njb3JlKGxhYmVscywgeXByZWRfYmluYXJ5KSkpCiAgICBjb250ZXh0LmxvZ19yZXN1bHQoZiJmMV9zY29yZSIsIG1ldHJpY3MuZjFfc2NvcmUobGFiZWxzLCB5cHJlZF9iaW5hcnksIGF2ZXJhZ2U9c2NvcmVfbWV0aG9kKSkKICAgIAogICAgY29udGV4dC5sb2dfYXJ0aWZhY3QoCiAgICAgICAgUGxvdEFydGlmYWN0KCJyb2MiLCBib2R5PXBsb3Rfcm9jKGNvbnRleHQsIGxhYmVscywgeV9wcm9iYSkpLCBhcnRpZmFjdF9wYXRoPWYie3Bsb3RzX2Rlc3R9IikKICAgIGdjZl9jbGVhcihwbHQpCgogICAgYm9keSA9IHBsb3RfY29uZnVzaW9uX21hdHJpeChsYWJlbHMsIHlwcmVkX2JpbmFyeSwgY2xhc3Nlcz1sYWJlbHMubGFiZWxzLnVuaXF1ZSgpKSAKICAgIGNvbnRleHQubG9nX2FydGlmYWN0KFBsb3RBcnRpZmFjdCgiY29uZnVzaW9uIiwgYm9keT1ib2R5KSwgYXJ0aWZhY3RfcGF0aD1mIntwbG90c19kZXN0fSIpCiAgICAKICAgIHJldHVybiB5X3Byb2JhCgpkZWYgcHJvYmFfY2FsaWJyYXRpb24obW9kZWwsIHhjYWwsIHljYWwpOgogICAgIiIiY2FsaWJyYXRlIG91dHB1dCBwcm9iYWJpbGl0aWVzCiAgICAKICAgICIiIgogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgZnJvbSBza2xlYXJuLmNhbGlicmF0aW9uIGltcG9ydCAoQ2FsaWJyYXRlZENsYXNzaWZpZXJDViwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGlicmF0aW9uX2N1cnZlKQogICAgZnJvbSBza2xlYXJuLmxpbmVhcl9tb2RlbCBpbXBvcnQgTG9naXN0aWNSZWdyZXNzaW9uCiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIAogICAgcHJpbnQodHlwZSh4Y2FsKSwgdHlwZSh5Y2FsKSkKCgoKCiAgICAgICAgCgoKCgoKCgpkZWYgdHJhaW5fbW9kZWwoCiAgICBjb250ZXh0LAogICAgbW9kZWxfdHlwZTogc3RyLAogICAgZGF0YXNldCwKICAgIGxhYmVsX2NvbHVtbjogc3RyID0gImxhYmVscyIsCiAgICBzYW1wbGU6IGludCA9IC0xLAogICAgdGVzdF9zaXplOiBmbG9hdCA9IDAuMDUsCiAgICB2YWxpZF9zaXplOiBmbG9hdCA9IDAuNzUsCiAgICByYW5kb21fc3RhdGU6IGludCA9IDEsCiAgICBtb2RlbF9maWxlbmFtZTogc3RyID0gInhnYi1tb2RlbCIsCiAgICBtb2RlbHNfZGVzdDogc3RyID0gIiIsCiAgICBwbG90c19kZXN0OiBzdHIgPSAiIiwKICAgIHNjb3JlX21ldGhvZDogc3RyID0gIm1pY3JvIiwKICAgIGZpbGVfZXh0OiBzdHIgPSAicGFycXVldCIsCiAgICBtb2RlbF9wa2dfZmlsZTogc3RyID0gIiIsICAgIAopIC0+IE5vbmU6CiAgICAiIiJ0cmFpbiBhbiB4Z2Jvb3N0IG1vZGVsLgoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgdGhlIGZ1bmN0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBtb2RlbF90eXBlOiAgICAgICAgdGhlIG1vZGVsIHR5cGUgdG8gdHJhaW4sICdjbGFzc2lmaWVyJywgJ3JlZ3Jlc3NvcicuLi4KICAgIDpwYXJhbSBkYXRhc2V0OiAgICAgICAgICAgKCJkYXRhIikgbmFtZSBvZiByYXcgZGF0YSBmaWxlCiAgICA6cGFyYW0gbGFiZWxfY29sdW1uOiAgICAgIGdyb3VuZC10cnV0aCAoeSkgbGFiZWxzCiAgICA6cGFyYW0gc2FtcGxlOiAgICAgICAgICAgIFNlbGVjdHMgdGhlIGZpcnN0IG4gcm93cywgb3Igc2VsZWN0IGEgc2FtcGxlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0LiBJZiBuZWdhdGl2ZSA8LTEsIHNlbGVjdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHJhbmRvbSBzYW1wbGUKICAgIDpwYXJhbSBtb2RlbF9maWxlbmFtZTogICAgbW9kZWwgZmlsZSBmaWxlbmFtZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzIHRvIGEgZGlyZWN0b3J5CiAgICA6cGFyYW0gdGVzdF9zaXplOiAgICAgICAgICgwLjA1KSB0ZXN0IHNldCBzaXplCiAgICA6cGFyYW0gdmFsaWRfc2l6ZTogICAgICAgICAgKDAuNzUpIE9uY2UgdGhlIHRlc3Qgc2V0IGhhcyBiZWVuIHJlbW92ZWQgdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWluaW5nIHNldCBnZXRzIHRoaXMgcHJvcG9ydGlvbi4KICAgIDpwYXJhbSByYW5kb21fc3RhdGU6ICAgICAgKDEpIHNrbGVhcm4gcm5nIHNlZWQKICAgIDpwYXJhbSBtb2RlbHNfZGVzdDogICAgICAgbW9kZWxzIHN1YmZvbGRlciBvbiBhcnRpZmFjdCBwYXRoCiAgICA6cGFyYW0gcGxvdHNfZGVzdDogICAgICAgIHBsb3Qgc3ViZm9sZGVyIG9uIGFydGlmYWN0IHBhdGgKICAgIDpwYXJhbSBzY29yZV9tZXRob2Q6ICAgICAgZm9yIG11bHRpY2xhc3MgY2xhc3NpZmljYXRpb24KICAgIAogICAgOnBhcmFtIGZpbGVfZXh0OiAgICAgICAgICBmb3JtYXQgZm9yIHRlc3Rfc2V0X2tleSBob2xkIG91dCBkYXRhCiAgICA6cGFyYW0gbW9kZWxfcGtnX2ZpbGU6ICAgIGpzb24gbW9kZWwgY29uZmlnIGZpbGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAiIiIKICAgIG1vZGVsc19kZXN0ID0gbW9kZWxzX2Rlc3Qgb3IgIm1vZGVscyIKICAgIHBsb3RzX2Rlc3QgPSBwbG90c19kZXN0IG9yIGYicGxvdHMve2NvbnRleHQubmFtZX0iCiAgICAKICAgIHJhdywgbGFiZWxzLCBoZWFkZXIgPSBnZXRfc2FtcGxlKHN0cihkYXRhc2V0KSwgc2FtcGxlLCBsYWJlbF9jb2x1bW4pCiAgICAKICAgICh4dHIseXRyKSwgKHh2YSx5dmEpLCAoeHRlLHl0ZSksICh4Y2FsLCB5Y2FsKSA9IGdldF9zcGxpdHMocmF3LCBsYWJlbHMsIDQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Rfc2l6ZSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkX3NpemUsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbImxhYmVscyJdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGUpCiAgICAgICAgCiAgICBtb2RlbCwgbW9kZWxfY29uZmlnID0gZ2VuX3hnYl9tb2RlbChtb2RlbF90eXBlLCBjb250ZXh0LnBhcmFtZXRlcnMuaXRlbXMoKSkKICAgIAogICAgbW9kZWxfY29uZmlnWyJGSVQiXS51cGRhdGUoeyJYIjogeHRyLCJ5IjogeXRyLnZhbHVlc30pCiAgICAKICAgIG1vZGVsLmZpdCgqKm1vZGVsX2NvbmZpZ1siRklUIl0pCiAgICAKICAgIGR1bXBfeGdiX21vZGVsKGNvbnRleHQsIG1vZGVsLCAianNvbiIsIG1vZGVsc19kZXN0LCBtb2RlbF9maWxlbmFtZSkKCiAgICB5X3Byb2JhID0gZ2VuX3Byb2JhKGNvbnRleHQsIHh2YSwgeXZhLCBtb2RlbCwgc2NvcmVfbWV0aG9kLCBwbG90c19kZXN0KQogICAgCiAgICB5X3Byb2JhX2NhbCA9IHByb2JhX2NhbGlicmF0aW9uKG1vZGVsLCB4Y2FsLCB5Y2FsKQoK
    commands: []
    code_origin: https://github.com/yjb-ds/functions.git#2decd6b1782d68d3a0e01ae6243b6beb811730fd:xgb_trainer.ipynb
