metadata:
  tag: ''
  name: arc-to-parquet
  categories:
  - utils
verbose: false
kind: job
spec:
  image: mlrun/mlrun
  disable_auto_mount: false
  build:
    origin_filename: ''
    functionSourceCode: IyBDb3B5cmlnaHQgMjAxOSBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiMKIyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKIyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KIyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiMgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiMKaW1wb3J0IG9zCgppbXBvcnQgbnVtcHkgYXMgbnAKaW1wb3J0IHBhbmRhcyBhcyBwZAppbXBvcnQgcHlhcnJvdyBhcyBwYQppbXBvcnQgcHlhcnJvdy5wYXJxdWV0IGFzIHBxCmZyb20gbWxydW4uZGF0YXN0b3JlIGltcG9ydCBEYXRhSXRlbQpmcm9tIG1scnVuLmV4ZWN1dGlvbiBpbXBvcnQgTUxDbGllbnRDdHgKCgpkZWYgX2NodW5rX3JlYWR3cml0ZSgKICAgIGFyY2hpdmVfdXJsLCBkZXN0X3BhdGgsIGNodW5rc2l6ZSwgaGVhZGVyLCBlbmNvZGluZywgZHR5cGUsIGRhdGFzZXQKKToKICAgICIiInN0cmVhbSByZWFkIGFuZCB3cml0ZSBhcmNoaXZlcwoKICAgIHBhbmRhcyByZWFkcyBhbmQgcGFycXVldCB3cml0ZXMKCiAgICBub3RlcwogICAgLS0tLS0KICAgICogZGVzdF9wYXRoIGNhbiBiZSBlaXRoZXIgYSBmaWxlLnBhcnF1ZXQsIG9yIGluIGh0ZSBjYXNlIG9mIHBhcnRpdGlvbmVkIHBhcnF1ZXQKICAgICAgaXQgd2lsbCBiZSBvbmx5IHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgb2YgdGhlIHBhcnF1ZXQgcGFydGl0aW9uIGZpbGVzCiAgICAiIiIKICAgIHBxd3JpdGVyID0gTm9uZQogICAgaGVhZGVyID0gW10KICAgIGZvciBpLCBkZiBpbiBlbnVtZXJhdGUoCiAgICAgICAgcGQucmVhZF9jc3YoCiAgICAgICAgICAgIGFyY2hpdmVfdXJsLAogICAgICAgICAgICBjaHVua3NpemU9Y2h1bmtzaXplLAogICAgICAgICAgICBuYW1lcz1oZWFkZXIsCiAgICAgICAgICAgIGVuY29kaW5nPWVuY29kaW5nLAogICAgICAgICAgICBkdHlwZT1kdHlwZSwKICAgICAgICApCiAgICApOgogICAgICAgIHRhYmxlID0gcGEuVGFibGUuZnJvbV9wYW5kYXMoZGYpCiAgICAgICAgaWYgaSA9PSAwOgogICAgICAgICAgICBpZiBkYXRhc2V0OgogICAgICAgICAgICAgICAgaGVhZGVyID0gbnAuY29weSh0YWJsZS5zY2hlbWEpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBwcXdyaXRlciA9IHBxLlBhcnF1ZXRXcml0ZXIoZGVzdF9wYXRoLCB0YWJsZS5zY2hlbWEpCiAgICAgICAgaWYgZGF0YXNldDoKICAgICAgICAgICAgcHEud3JpdGVfdG9fZGF0YXNldCgKICAgICAgICAgICAgICAgIHRhYmxlLCByb290X3BhdGg9ZGVzdF9wYXRoLCBwYXJ0aXRpb25fY29scz1wYXJ0aXRpb25fY29scwogICAgICAgICAgICApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHF3cml0ZXIud3JpdGVfdGFibGUodGFibGUpCiAgICBpZiBwcXdyaXRlcjoKICAgICAgICBwcXdyaXRlci5jbG9zZSgpCgogICAgcmV0dXJuIGhlYWRlcgoKCmRlZiBhcmNfdG9fcGFycXVldCgKICAgIGNvbnRleHQ6IE1MQ2xpZW50Q3R4LAogICAgYXJjaGl2ZV91cmw6IERhdGFJdGVtLAogICAgaGVhZGVyOiBsaXN0W3N0cl0gPSBbTm9uZV0sCiAgICBjaHVua3NpemU6IGludCA9IDAsCiAgICBkdHlwZT1Ob25lLAogICAgZW5jb2Rpbmc6IHN0ciA9ICJsYXRpbi0xIiwKICAgIGtleTogc3RyID0gImRhdGEiLAogICAgZGF0YXNldDogc3RyID0gIk5vbmUiLAogICAgcGFydF9jb2xzPVtdLAogICAgZmlsZV9leHQ6IHN0ciA9ICJwYXJxdWV0IiwKICAgIGluZGV4OiBib29sID0gRmFsc2UsCiAgICByZWZyZXNoX2RhdGE6IGJvb2wgPSBGYWxzZSwKICAgIHN0YXRzOiBib29sID0gRmFsc2UsCikgLT4gTm9uZToKICAgICIiIk9wZW4gYSBmaWxlL29iamVjdCBhcmNoaXZlIGFuZCBzYXZlIGFzIGEgcGFycXVldCBmaWxlIG9yIGRhdGFzZXQKCiAgICBOb3RlcwogICAgLS0tLS0KICAgICogdGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgZm9yIGxhcmdlIGZpbGVzLCBwbGVhc2UgYmUgc3VyZSB0byBjaGVjayBhbGwgc2V0dGluZ3MKICAgICogcGFydGl0aW9uaW5nIHJlcXVpcmVzIHByZWNpc2Ugc3BlY2lmaWNhdGlvbiBvZiBjb2x1bW4gdHlwZXMuCiAgICAqIHRoZSBhcmNoaXZlX3VybCBjYW4gYmUgYW55IGZpbGUgcmVhZGFibGUgYnkgcGFuZGFzIHJlYWRfY3N2LCB3aGljaCBpbmNsdWRlcyB0YXIgZmlsZXMKICAgICogaWYgdGhlIGBkYXRhc2V0YCBwYXJhbWV0ZXIgaXMgbm90IGVtcHR5LCB0aGVuIGEgcGFydGl0aW9uZWQgZGF0YXNldCB3aWxsIGJlIGNyZWF0ZWQKICAgIGluc3RlYWQgb2YgYSBzaW5nbGUgZmlsZSBpbiB0aGUgZm9sZGVyIGBkYXRhc2V0YAogICAgKiBpZiBhIGtleSBleGlzdHMgYWxyZWFkeSB0aGVuIGl0IHdpbGwgbm90IGJlIHJlLWFjcXVpcmVkIHVubGVzcyB0aGUgYHJlZnJlc2hfZGF0YWAgcGFyYW0KICAgIGlzIHNldCB0byBgVHJ1ZWAuICBUaGlzIGlzIGluIGNhc2UgdGhlIG9yaWdpbmFsIGZpbGUgaXMgY29ycnVwdCwgb3IgYSByZWZyZXNoIGlzCiAgICByZXF1aXJlZC4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgIHRoZSBmdW5jdGlvbiBjb250ZXh0CiAgICA6cGFyYW0gYXJjaGl2ZV91cmw6ICAgIE1MUnVuIGRhdGEgaW5wdXQgKERhdGFJdGVtIG9iamVjdCkKICAgIDpwYXJhbSBjaHVua3NpemU6ICAgICAgKDApIHdoZW4gPiAwLCByb3cgc2l6ZSAoY2h1bmspIHRvIHJldHJpZXZlCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlciBpdGVyYXRpb24KICAgIDpwYXJhbSBkdHlwZSAgICAgICAgICAgZGVzdGluYXRpb24gZGF0YSB0eXBlIG9mIHNwZWNpZmllZCBjb2x1bW5zCiAgICA6cGFyYW0gZW5jb2RpbmcgICAgICAgICgibGF0aW4tOCIpIGZpbGUgZW5jb2RpbmcKICAgIDpwYXJhbSBrZXk6ICAgICAgICAgICAga2V5IGluIGFydGlmYWN0IHN0b3JlICh3aGVuIGxvZ19kYXRhPVRydWUpCiAgICA6cGFyYW0gZGF0YXNldDogICAgICAgIChOb25lKSBpZiBub3QgTm9uZSB0aGVuICJ0YXJnZXRfcGF0aC9kYXRhc2V0IgogICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBmb2xkZXIgZm9yIHBhcnRpdGlvbmVkIGZpbGVzCiAgICA6cGFyYW0gcGFydF9jb2xzOiAgICAgIChbXSkgbGlzdCBvZiBwYXJ0aXRpb25pbmcgY29sdW1ucwogICAgOnBhcmFtIGZpbGVfZXh0OiAgICAgICAocGFycXVldCkgY3N2L3BhcnF1ZXQgZmlsZSBleHRlbnNpb24KICAgIDpwYXJhbSBpbmRleDogICAgICAgICAgKEZhbHNlKSBwYW5kYXMgc2F2ZSBpbmRleCBvcHRpb24KICAgIDpwYXJhbSByZWZyZXNoX2RhdGE6ICAgKEZhbHNlKSBvdmVyd3JpdGUgZXhpc3RpbmcgZGF0YSBhdCB0aGF0IGxvY2F0aW9uCiAgICA6cGFyYW0gc3RhdHM6ICAgICAgICAgIChOb25lKSBjYWxjdWxhdGUgdGFibGUgc3RhdHMgd2hlbiBsb2dnaW5nIGFydGlmYWN0CiAgICAiIiIKICAgIGJhc2VfcGF0aCA9IGNvbnRleHQuYXJ0aWZhY3RfcGF0aAogICAgb3MubWFrZWRpcnMoYmFzZV9wYXRoLCBleGlzdF9vaz1UcnVlKQoKICAgIGFyY2hpdmVfdXJsID0gYXJjaGl2ZV91cmwubG9jYWwoKQoKICAgIGlmIGRhdGFzZXQgaXMgbm90IE5vbmU6CiAgICAgICAgZGVzdF9wYXRoID0gb3MucGF0aC5qb2luKGJhc2VfcGF0aCwgZGF0YXNldCkKICAgICAgICBleGlzdHMgPSBvcy5wYXRoLmlzZGlyKGRlc3RfcGF0aCkKICAgIGVsc2U6CiAgICAgICAgZGVzdF9wYXRoID0gb3MucGF0aC5qb2luKGJhc2VfcGF0aCwga2V5ICsgZiIue2ZpbGVfZXh0fSIpCiAgICAgICAgZXhpc3RzID0gb3MucGF0aC5pc2ZpbGUoZGVzdF9wYXRoKQoKICAgIGlmIG5vdCBleGlzdHM6CiAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbygiZGVzdGluYXRpb24gZmlsZSBkb2VzIG5vdCBleGlzdCwgZG93bmxvYWRpbmciKQogICAgICAgIGlmIGNodW5rc2l6ZSA+IDA6CiAgICAgICAgICAgIGhlYWRlciA9IF9jaHVua19yZWFkd3JpdGUoCiAgICAgICAgICAgICAgICBhcmNoaXZlX3VybCwgZGVzdF9wYXRoLCBjaHVua3NpemUsIGVuY29kaW5nLCBkdHlwZSwgZGF0YXNldAogICAgICAgICAgICApCiAgICAgICAgICAgIGNvbnRleHQubG9nX2RhdGFzZXQoCiAgICAgICAgICAgICAgICBrZXk9a2V5LCBzdGF0cz1zdGF0cywgZm9ybWF0PSJwYXJxdWV0IiwgdGFyZ2V0X3BhdGg9ZGVzdF9wYXRoCiAgICAgICAgICAgICkKICAgICAgICBlbHNlOgogICAgICAgICAgICBkZiA9IHBkLnJlYWRfY3N2KGFyY2hpdmVfdXJsKQogICAgICAgICAgICBjb250ZXh0LmxvZ19kYXRhc2V0KGtleSwgZGY9ZGYsIGZvcm1hdD1maWxlX2V4dCwgaW5kZXg9aW5kZXgpCiAgICBlbHNlOgogICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8oImRlc3RpbmF0aW9uIGZpbGUgYWxyZWFkeSBleGlzdHMsIG5vdGhpbmcgZG9uZSIpCg==
    code_origin: ''
  filename: arc_to_parquet.py
  entry_points:
    arc_to_parquet:
      outputs:
      - type: None
      parameters:
      - name: context
        type: MLClientCtx
        doc: the function context
      - name: archive_url
        type: DataItem
        doc: MLRun data input (DataItem object)
      - name: header
        type: list[str]
        default:
        - null
      - name: chunksize
        type: int
        doc: (0) when > 0, row size (chunk) to retrieve per iteration
        default: 0
      - name: dtype
        default: null
      - name: encoding
        type: str
        default: latin-1
      - name: key
        type: str
        doc: key in artifact store (when log_data=True)
        default: data
      - name: dataset
        type: str
        doc: (None) if not None then "target_path/dataset" is folder for partitioned
          files
        default: None
      - name: part_cols
        doc: ([]) list of partitioning columns
        default: []
      - name: file_ext
        type: str
        doc: (parquet) csv/parquet file extension
        default: parquet
      - name: index
        type: bool
        doc: (False) pandas save index option
        default: false
      - name: refresh_data
        type: bool
        doc: (False) overwrite existing data at that location
        default: false
      - name: stats
        type: bool
        doc: (None) calculate table stats when logging artifact
        default: false
      name: arc_to_parquet
      doc: 'Open a file/object archive and save as a parquet file or dataset


        Notes

        -----

        * this function is typically for large files, please be sure to check all
        settings

        * partitioning requires precise specification of column types.

        * the archive_url can be any file readable by pandas read_csv, which includes
        tar files

        * if the `dataset` parameter is not empty, then a partitioned dataset will
        be created

        instead of a single file in the folder `dataset`

        * if a key exists already then it will not be re-acquired unless the `refresh_data`
        param

        is set to `True`.  This is in case the original file is corrupt, or a refresh
        is

        required.'
      has_kwargs: false
      has_varargs: false
      lineno: 66
  command: ''
  description: retrieve remote archive, open and save as parquet
  default_handler: arc_to_parquet
