kind: job
metadata:
  name: hugging-face-classifier-trainer
  tag: ''
  hash: f9d8aa4a2c66e24fa418bb163829adc3e2ada06c
  project: ''
  labels:
    author: davids
  categories:
  - deep-learning
  - huggingface
  - machine-learning
  - model-training
spec:
  command: ''
  args: []
  image: ''
  build:
    functionSourceCode: aW1wb3J0IG9zCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRlbXBmaWxlCmltcG9ydCB6aXBmaWxlCmZyb20gYWJjIGltcG9ydCBBQkMKZnJvbSB0eXBpbmcgaW1wb3J0IEFueSwgQ2FsbGFibGUsIERpY3QsIExpc3QsIE9wdGlvbmFsLCBUdXBsZSwgVW5pb24KCmltcG9ydCBtbHJ1bgppbXBvcnQgbWxydW4uZGF0YXN0b3JlCmltcG9ydCBtbHJ1bi51dGlscwppbXBvcnQgbnVtcHkgYXMgbnAKaW1wb3J0IHBhbmRhcyBhcyBwZAppbXBvcnQgdHJhbnNmb3JtZXJzCmZyb20gZGF0YXNldHMgaW1wb3J0IERhdGFzZXQsIGxvYWRfZGF0YXNldCwgbG9hZF9tZXRyaWMKZnJvbSBtbHJ1biBpbXBvcnQgTUxDbGllbnRDdHgKZnJvbSBtbHJ1biBpbXBvcnQgZmVhdHVyZV9zdG9yZSBhcyBmcwpmcm9tIG1scnVuLmFydGlmYWN0cyBpbXBvcnQgQXJ0aWZhY3QsIFBsb3RseUFydGlmYWN0CmZyb20gbWxydW4uZGF0YXN0b3JlIGltcG9ydCBEYXRhSXRlbQpmcm9tIG1scnVuLmZyYW1ld29ya3MuX2NvbW1vbiBpbXBvcnQgQ29tbW9uVHlwZXMsIE1MUnVuSW50ZXJmYWNlCmZyb20gbWxydW4udXRpbHMgaW1wb3J0IGNyZWF0ZV9jbGFzcwpmcm9tIHBsb3RseSBpbXBvcnQgZ3JhcGhfb2JqZWN0cyBhcyBnbwpmcm9tIHNrbGVhcm4ubW9kZWxfc2VsZWN0aW9uIGltcG9ydCB0cmFpbl90ZXN0X3NwbGl0CmZyb20gdHJhbnNmb3JtZXJzIGltcG9ydCAoCiAgICBBdXRvVG9rZW5pemVyLAogICAgRGF0YUNvbGxhdG9yV2l0aFBhZGRpbmcsCiAgICBFdmFsUHJlZGljdGlvbiwKICAgIFByZVRyYWluZWRNb2RlbCwKICAgIFByZVRyYWluZWRUb2tlbml6ZXIsCiAgICBUcmFpbmVyLAogICAgVHJhaW5lckNhbGxiYWNrLAogICAgVHJhaW5lckNvbnRyb2wsCiAgICBUcmFpbmVyU3RhdGUsCiAgICBUcmFpbmluZ0FyZ3VtZW50cywKKQoKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWZyb20gTUxSVU4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpjbGFzcyBIRk9SVE9wdGltaXplck1MUnVuSW50ZXJmYWNlKE1MUnVuSW50ZXJmYWNlLCBBQkMpOgogICAgIiIiCiAgICBJbnRlcmZhY2UgZm9yIGFkZGluZyBNTFJ1biBmZWF0dXJlcyBmb3IgdGVuc29yZmxvdyBrZXJhcyBBUEkuCiAgICAiIiIKCiAgICAjIE1MUnVuJ3MgY29udGV4dCBkZWZhdWx0IG5hbWU6CiAgICBERUZBVUxUX0NPTlRFWFRfTkFNRSA9ICJtbHJ1bi1odWdnaW5nZmFjZSIKCiAgICAjIEF0dHJpYnV0ZXMgdG8gYmUgaW5zZXJ0ZWQgc28gdGhlIE1MUnVuIGludGVyZmFjZSB3aWxsIGJlIGZ1bGx5IGVuYWJsZWQuCiAgICBfUFJPUEVSVElFUyA9IHsKICAgICAgICAiX2F1dG9fbG9nIjogRmFsc2UsCiAgICAgICAgIl9jb250ZXh0IjogTm9uZSwKICAgICAgICAiX21vZGVsX25hbWUiOiAibW9kZWwiLAogICAgICAgICJfdGFnIjogIiIsCiAgICAgICAgIl9sYWJlbHMiOiBOb25lLAogICAgICAgICJfZXh0cmFfZGF0YSI6IE5vbmUsCiAgICB9CiAgICBfTUVUSE9EUyA9IFsiZW5hYmxlX2F1dG9fbG9nZ2luZyJdCiAgICAjIEF0dHJpYnV0ZXMgdG8gcmVwbGFjZSBzbyB0aGUgTUxSdW4gaW50ZXJmYWNlIHdpbGwgYmUgZnVsbHkgZW5hYmxlZC4KICAgIF9SRVBMQUNFRF9NRVRIT0RTID0gWwogICAgICAgICJvcHRpbWl6ZSIsCiAgICBdCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgYWRkX2ludGVyZmFjZSgKICAgICAgICBjbHMsCiAgICAgICAgb2JqLAogICAgICAgIHJlc3RvcmF0aW9uOiBDb21tb25UeXBlcy5NTFJ1bkludGVyZmFjZVJlc3RvcmF0aW9uVHlwZSA9IE5vbmUsCiAgICApOgogICAgICAgICIiIgogICAgICAgIEVucmljaCB0aGUgb2JqZWN0IHdpdGggdGhpcyBpbnRlcmZhY2UgcHJvcGVydGllcywgbWV0aG9kcyBhbmQgZnVuY3Rpb25zLCBzbyBpdCB3aWxsIGhhdmUgdGhpcyBUZW5zb3JGbG93LktlcmFzCiAgICAgICAgTUxSdW4ncyBmZWF0dXJlcy4KICAgICAgICA6cGFyYW0gb2JqOiAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgdG8gZW5yaWNoIGhpcyBpbnRlcmZhY2UuCiAgICAgICAgOnBhcmFtIHJlc3RvcmF0aW9uOiBSZXN0b3JhdGlvbiBpbmZvcm1hdGlvbiB0dXBsZSBhcyByZXR1cm5lZCBmcm9tICdyZW1vdmVfaW50ZXJmYWNlJyBpbiBvcmRlciB0bwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkIHRoZSBpbnRlcmZhY2UgaW4gYSBjZXJ0YWluIHN0YXRlLgogICAgICAgICIiIgogICAgICAgIHN1cGVyKEhGT1JUT3B0aW1pemVyTUxSdW5JbnRlcmZhY2UsIGNscykuYWRkX2ludGVyZmFjZSgKICAgICAgICAgICAgb2JqPW9iaiwgcmVzdG9yYXRpb249cmVzdG9yYXRpb24KICAgICAgICApCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgbWxydW5fb3B0aW1pemUoY2xzKToKICAgICAgICAiIiIKICAgICAgICBNTFJ1bidzIHRmLmtlcmFzLk1vZGVsLmZpdCB3cmFwcGVyLiBJdCB3aWxsIHNldHVwIHRoZSBvcHRpbWl6ZXIgd2hlbiB1c2luZyBob3Jvdm9kLiBUaGUgb3B0aW1pemVyIG11c3QgYmUKICAgICAgICBwYXNzZWQgaW4gYSBrZXl3b3JkIGFyZ3VtZW50IGFuZCB3aGVuIHVzaW5nIGhvcm92b2QsIGl0IG11c3QgYmUgcGFzc2VkIGFzIGFuIE9wdGltaXplciBpbnN0YW5jZSwgbm90IGEgc3RyaW5nLgoKICAgICAgICByYWlzZSBNTFJ1bkludmFsaWRBcmd1bWVudEVycm9yOiBJbiBjYXNlIHRoZSBvcHRpbWl6ZXIgcHJvdmlkZWQgZGlkIG5vdCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhYm92ZS4KICAgICAgICAiIiIKCiAgICAgICAgZGVmIHdyYXBwZXIoc2VsZiwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgc2F2ZV9kaXIgPSBjbHMuX2dldF9mdW5jdGlvbl9hcmd1bWVudCgKICAgICAgICAgICAgICAgIHNlbGYub3B0aW1pemUsCiAgICAgICAgICAgICAgICBhcmd1bWVudF9uYW1lPSJzYXZlX2RpciIsCiAgICAgICAgICAgICAgICBwYXNzZWRfYXJncz1hcmdzLAogICAgICAgICAgICAgICAgcGFzc2VkX2t3YXJncz1rd2FyZ3MsCiAgICAgICAgICAgIClbMF0KCiAgICAgICAgICAgICMgQ2FsbCB0aGUgb3JpZ2luYWwgb3B0aW1pemUgbWV0aG9kOgogICAgICAgICAgICByZXN1bHQgPSBzZWxmLm9yaWdpbmFsX29wdGltaXplKCphcmdzLCAqKmt3YXJncykKCiAgICAgICAgICAgIGlmIHNlbGYuX2F1dG9fbG9nOgogICAgICAgICAgICAgICAgIyBMb2cgdGhlIG9ubnggbW9kZWw6CiAgICAgICAgICAgICAgICBzZWxmLl9jb250ZXh0LmxvZ19tb2RlbCgKICAgICAgICAgICAgICAgICAgICBrZXk9Im1vZGVsIiwKICAgICAgICAgICAgICAgICAgICBkYl9rZXk9c2VsZi5fbW9kZWxfbmFtZSwKICAgICAgICAgICAgICAgICAgICBtb2RlbF9maWxlPWYie3NhdmVfZGlyfS9tb2RlbF9vcHRpbWl6ZWQub25ueCIsCiAgICAgICAgICAgICAgICAgICAgdGFnPXNlbGYuX3RhZywKICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcms9Ik9OTlgiLAogICAgICAgICAgICAgICAgICAgIGxhYmVscz1zZWxmLl9sYWJlbHMsCiAgICAgICAgICAgICAgICAgICAgZXh0cmFfZGF0YT1zZWxmLl9leHRyYV9kYXRhLAogICAgICAgICAgICAgICAgKQoKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIGRlZiBlbmFibGVfYXV0b19sb2dnaW5nKAogICAgICAgIHNlbGYsCiAgICAgICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHgsCiAgICAgICAgbW9kZWxfbmFtZTogc3RyID0gIm1vZGVsIiwKICAgICAgICB0YWc6IHN0ciA9ICIiLAogICAgICAgIGxhYmVsczogRGljdFtzdHIsIHN0cl0gPSBOb25lLAogICAgICAgIGV4dHJhX2RhdGE6IGRpY3QgPSBOb25lLAogICAgKToKICAgICAgICBzZWxmLl9hdXRvX2xvZyA9IFRydWUKCiAgICAgICAgc2VsZi5fY29udGV4dCA9IGNvbnRleHQKICAgICAgICBzZWxmLl9tb2RlbF9uYW1lID0gbW9kZWxfbmFtZQogICAgICAgIHNlbGYuX3RhZyA9IHRhZwogICAgICAgIHNlbGYuX2xhYmVscyA9IGxhYmVscwogICAgICAgIHNlbGYuX2V4dHJhX2RhdGEgPSBleHRyYV9kYXRhCgoKY2xhc3MgSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UoTUxSdW5JbnRlcmZhY2UsIEFCQyk6CiAgICAiIiIKICAgIEludGVyZmFjZSBmb3IgYWRkaW5nIE1MUnVuIGZlYXR1cmVzIGZvciB0ZW5zb3JmbG93IGtlcmFzIEFQSS4KICAgICIiIgoKICAgICMgTUxSdW5zIGNvbnRleHQgZGVmYXVsdCBuYW1lOgogICAgREVGQVVMVF9DT05URVhUX05BTUUgPSAibWxydW4taHVnZ2luZ2ZhY2UiCgogICAgIyBBdHRyaWJ1dGVzIHRvIHJlcGxhY2Ugc28gdGhlIE1MUnVuIGludGVyZmFjZSB3aWxsIGJlIGZ1bGx5IGVuYWJsZWQuCiAgICBfUkVQTEFDRURfTUVUSE9EUyA9IFsKICAgICAgICAidHJhaW4iLAogICAgICAgICMgImV2YWx1YXRlIgogICAgXQoKICAgIEBjbGFzc21ldGhvZAogICAgZGVmIGFkZF9pbnRlcmZhY2UoCiAgICAgICAgY2xzLAogICAgICAgIG9iajogVHJhaW5lciwKICAgICAgICByZXN0b3JhdGlvbjogQ29tbW9uVHlwZXMuTUxSdW5JbnRlcmZhY2VSZXN0b3JhdGlvblR5cGUgPSBOb25lLAogICAgKToKICAgICAgICAiIiIKICAgICAgICBFbnJpY2ggdGhlIG9iamVjdCB3aXRoIHRoaXMgaW50ZXJmYWNlIHByb3BlcnRpZXMsIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucywgc28gaXQgd2lsbCBoYXZlIHRoaXMgVGVuc29yRmxvdy5LZXJhcwogICAgICAgIE1MUnVucyBmZWF0dXJlcy4KICAgICAgICA6cGFyYW0gb2JqOiAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgdG8gZW5yaWNoIGhpcyBpbnRlcmZhY2UuCiAgICAgICAgOnBhcmFtIHJlc3RvcmF0aW9uOiBSZXN0b3JhdGlvbiBpbmZvcm1hdGlvbiB0dXBsZSBhcyByZXR1cm5lZCBmcm9tICdyZW1vdmVfaW50ZXJmYWNlJyBpbiBvcmRlciB0bwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkIHRoZSBpbnRlcmZhY2UgaW4gYSBjZXJ0YWluIHN0YXRlLgogICAgICAgICIiIgoKICAgICAgICBzdXBlcihIRlRyYWluZXJNTFJ1bkludGVyZmFjZSwgY2xzKS5hZGRfaW50ZXJmYWNlKAogICAgICAgICAgICBvYmo9b2JqLCByZXN0b3JhdGlvbj1yZXN0b3JhdGlvbgogICAgICAgICkKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBtbHJ1bl90cmFpbihjbHMpOgoKICAgICAgICAiIiIKICAgICAgICBNTFJ1bnMgdGYua2VyYXMuTW9kZWwuZml0IHdyYXBwZXIuIEl0IHdpbGwgc2V0dXAgdGhlIG9wdGltaXplciB3aGVuIHVzaW5nIGhvcm92b2QuIFRoZSBvcHRpbWl6ZXIgbXVzdCBiZQogICAgICAgIHBhc3NlZCBpbiBhIGtleXdvcmQgYXJndW1lbnQgYW5kIHdoZW4gdXNpbmcgaG9yb3ZvZCwgaXQgbXVzdCBiZSBwYXNzZWQgYXMgYW4gT3B0aW1pemVyIGluc3RhbmNlLCBub3QgYSBzdHJpbmcuCgogICAgICAgIHJhaXNlIE1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3I6IEluIGNhc2UgdGhlIG9wdGltaXplciBwcm92aWRlZCBkaWQgbm90IGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGFib3ZlLgogICAgICAgICIiIgoKICAgICAgICBkZWYgd3JhcHBlcihzZWxmOiBUcmFpbmVyLCAqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICAjIFJlc3RvcmUgdGhlIGV2YWx1YXRpb24gbWV0aG9kIGFzIGB0cmFpbmAgd2lsbCB1c2UgaXQ6CiAgICAgICAgICAgICMgY2xzLl9yZXN0b3JlX2F0dHJpYnV0ZShvYmo9c2VsZiwgYXR0cmlidXRlX25hbWU9ImV2YWx1YXRlIikKCiAgICAgICAgICAgICMgQ2FsbCB0aGUgb3JpZ2luYWwgZml0IG1ldGhvZDoKICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5vcmlnaW5hbF90cmFpbigqYXJncywgKiprd2FyZ3MpCgogICAgICAgICAgICAjIFJlcGxhY2UgdGhlIGV2YWx1YXRpb24gbWV0aG9kIGFnYWluOgogICAgICAgICAgICAjIGNscy5fcmVwbGFjZV9mdW5jdGlvbihvYmo9c2VsZiwgZnVuY3Rpb25fbmFtZT0iZXZhbHVhdGUiKQoKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKCmNsYXNzIE1MUnVuQ2FsbGJhY2soVHJhaW5lckNhbGxiYWNrKToKICAgICIiIgogICAgQ2FsbGJhY2sgZm9yIGNvbGxlY3RpbmcgbG9ncyBkdXJpbmcgdHJhaW5pbmcgLyBldmFsdWF0aW9uIG9mIHRoZSBgVHJhaW5lcmAgQVBJLgogICAgIiIiCgogICAgZGVmIF9faW5pdF9fKAogICAgICAgIHNlbGYsCiAgICAgICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHggPSBOb25lLAogICAgICAgIG1vZGVsX25hbWU6IHN0ciA9ICJtb2RlbCIsCiAgICAgICAgdGFnOiBzdHIgPSAiIiwKICAgICAgICBsYWJlbHM6IERpY3Rbc3RyLCBzdHJdID0gTm9uZSwKICAgICAgICBleHRyYV9kYXRhOiBkaWN0ID0gTm9uZSwKICAgICk6CiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpCgogICAgICAgICMgU3RvcmUgdGhlIGNvbmZpZ3VyYXRpb25zOgogICAgICAgIHNlbGYuX2NvbnRleHQgPSAoCiAgICAgICAgICAgIGNvbnRleHQKICAgICAgICAgICAgaWYgY29udGV4dCBpcyBub3QgTm9uZQogICAgICAgICAgICBlbHNlIG1scnVuLmdldF9vcl9jcmVhdGVfY3R4KCIuL21scnVuLWh1Z2dpbmdmYWNlIikKICAgICAgICApCiAgICAgICAgc2VsZi5fbW9kZWxfbmFtZSA9IG1vZGVsX25hbWUKICAgICAgICBzZWxmLl90YWcgPSB0YWcKICAgICAgICBzZWxmLl9sYWJlbHMgPSBsYWJlbHMKICAgICAgICBzZWxmLl9leHRyYV9kYXRhID0gZXh0cmFfZGF0YSBpZiBleHRyYV9kYXRhIGlzIG5vdCBOb25lIGVsc2Uge30KCiAgICAgICAgIyBTZXQgdXAgdGhlIGxvZ2dpbmcgbW9kZToKICAgICAgICBzZWxmLl9pc190cmFpbmluZyA9IEZhbHNlCiAgICAgICAgc2VsZi5fc3RlcHM6IExpc3RbTGlzdFtpbnRdXSA9IFtdCiAgICAgICAgc2VsZi5fbWV0cmljX3Njb3JlczogRGljdFtzdHIsIExpc3RbZmxvYXRdXSA9IHt9CiAgICAgICAgc2VsZi5fYXJ0aWZhY3RzOiBEaWN0W3N0ciwgQXJ0aWZhY3RdID0ge30KCiAgICBkZWYgb25fZXBvY2hfYmVnaW4oCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9zdGVwcy5hcHBlbmQoW10pCgogICAgZGVmIG9uX2Vwb2NoX2VuZCgKICAgICAgICBzZWxmLAogICAgICAgIGFyZ3M6IFRyYWluaW5nQXJndW1lbnRzLAogICAgICAgIHN0YXRlOiBUcmFpbmVyU3RhdGUsCiAgICAgICAgY29udHJvbDogVHJhaW5lckNvbnRyb2wsCiAgICAgICAgKiprd2FyZ3MsCiAgICApOgogICAgICAgIHNlbGYuX2xvZ19tZXRyaWNzKCkKCiAgICBkZWYgb25fbG9nKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICBsb2dzOiBEaWN0W3N0ciwgZmxvYXRdID0gTm9uZSwKICAgICAgICAqKmt3YXJncywKICAgICk6CiAgICAgICAgcmVjZW50X2xvZ3MgPSBzdGF0ZS5sb2dfaGlzdG9yeVstMV0uY29weSgpCgogICAgICAgIHJlY2VudF9sb2dzLnBvcCgiZXBvY2giKQogICAgICAgIGN1cnJlbnRfc3RlcCA9IGludChyZWNlbnRfbG9ncy5wb3AoInN0ZXAiKSkKICAgICAgICBpZiBjdXJyZW50X3N0ZXAgbm90IGluIHNlbGYuX3N0ZXBzWy0xXToKICAgICAgICAgICAgc2VsZi5fc3RlcHNbLTFdLmFwcGVuZChjdXJyZW50X3N0ZXApCgogICAgICAgIGZvciBtZXRyaWNfbmFtZSwgbWV0cmljX3Njb3JlIGluIHJlY2VudF9sb2dzLml0ZW1zKCk6CiAgICAgICAgICAgIGlmIG1ldHJpY19uYW1lLnN0YXJ0c3dpdGgoInRyYWluXyIpOgogICAgICAgICAgICAgICAgaWYgbWV0cmljX25hbWUuc3BsaXQoInRyYWluXyIpWzFdIG5vdCBpbiBzZWxmLl9tZXRyaWNfc2NvcmVzOgogICAgICAgICAgICAgICAgICAgIHNlbGYuX21ldHJpY19zY29yZXNbbWV0cmljX25hbWVdID0gW21ldHJpY19zY29yZV0KICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGlmIG1ldHJpY19uYW1lIG5vdCBpbiBzZWxmLl9tZXRyaWNfc2NvcmVzOgogICAgICAgICAgICAgICAgc2VsZi5fbWV0cmljX3Njb3Jlc1ttZXRyaWNfbmFtZV0gPSBbXQogICAgICAgICAgICBzZWxmLl9tZXRyaWNfc2NvcmVzW21ldHJpY19uYW1lXS5hcHBlbmQobWV0cmljX3Njb3JlKQoKICAgIGRlZiBvbl90cmFpbl9iZWdpbigKICAgICAgICBzZWxmLAogICAgICAgIGFyZ3M6IFRyYWluaW5nQXJndW1lbnRzLAogICAgICAgIHN0YXRlOiBUcmFpbmVyU3RhdGUsCiAgICAgICAgY29udHJvbDogVHJhaW5lckNvbnRyb2wsCiAgICAgICAgKiprd2FyZ3MsCiAgICApOgogICAgICAgIHNlbGYuX2lzX3RyYWluaW5nID0gVHJ1ZQoKICAgIGRlZiBvbl90cmFpbl9lbmQoCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgIG1vZGVsOiBQcmVUcmFpbmVkTW9kZWwgPSBOb25lLAogICAgICAgIHRva2VuaXplcjogUHJlVHJhaW5lZFRva2VuaXplciA9IE5vbmUsCiAgICAgICAgKiprd2FyZ3MsCiAgICApOgogICAgICAgIHNlbGYuX2xvZ19tZXRyaWNzKCkKCiAgICAgICAgdGVtcF9kaXJlY3RvcnkgPSB0ZW1wZmlsZS5nZXR0ZW1wZGlyKCkKCiAgICAgICAgIyBTYXZlIGFuZCBsb2cgdGhlIHRva2VuaXplcjoKICAgICAgICBpZiB0b2tlbml6ZXIgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICMgU2F2ZSB0b2tlbml6ZXI6CiAgICAgICAgICAgIHRva2VuaXplcl9kaXIgPSBvcy5wYXRoLmpvaW4odGVtcF9kaXJlY3RvcnksICJ0b2tlbml6ZXIiKQogICAgICAgICAgICB0b2tlbml6ZXIuc2F2ZV9wcmV0cmFpbmVkKHNhdmVfZGlyZWN0b3J5PXRva2VuaXplcl9kaXIpCiAgICAgICAgICAgICMgWmlwIHRoZSB0b2tlbml6ZXIgZGlyZWN0b3J5OgogICAgICAgICAgICB0b2tlbml6ZXJfemlwID0gc2h1dGlsLm1ha2VfYXJjaGl2ZSgKICAgICAgICAgICAgICAgIGJhc2VfbmFtZT0idG9rZW5pemVyIiwKICAgICAgICAgICAgICAgIGZvcm1hdD0iemlwIiwKICAgICAgICAgICAgICAgIHJvb3RfZGlyPXRva2VuaXplcl9kaXIsCiAgICAgICAgICAgICkKICAgICAgICAgICAgIyBMb2cgdGhlIHppcCBmaWxlOgogICAgICAgICAgICBzZWxmLl9hcnRpZmFjdHNbInRva2VuaXplciJdID0gc2VsZi5fY29udGV4dC5sb2dfYXJ0aWZhY3QoCiAgICAgICAgICAgICAgICBpdGVtPSJ0b2tlbml6ZXIiLCBsb2NhbF9wYXRoPXRva2VuaXplcl96aXAKICAgICAgICAgICAgKQoKICAgICAgICAjIFNhdmUgdGhlIG1vZGVsOgogICAgICAgIG1vZGVsX2RpciA9IG9zLnBhdGguam9pbih0ZW1wX2RpcmVjdG9yeSwgIm1vZGVsIikKICAgICAgICBtb2RlbC5zYXZlX3ByZXRyYWluZWQoc2F2ZV9kaXJlY3Rvcnk9bW9kZWxfZGlyKQoKICAgICAgICAjIFppcCB0aGUgbW9kZWwgZGlyZWN0b3J5OgogICAgICAgIHNodXRpbC5tYWtlX2FyY2hpdmUoCiAgICAgICAgICAgIGJhc2VfbmFtZT0ibW9kZWwiLAogICAgICAgICAgICBmb3JtYXQ9InppcCIsCiAgICAgICAgICAgIHJvb3RfZGlyPW1vZGVsX2RpciwKICAgICAgICApCgogICAgICAgICMgTG9nIHRoZSBtb2RlbDoKICAgICAgICBzZWxmLl9jb250ZXh0LmxvZ19tb2RlbCgKICAgICAgICAgICAga2V5PSJtb2RlbCIsCiAgICAgICAgICAgIGRiX2tleT1zZWxmLl9tb2RlbF9uYW1lLAogICAgICAgICAgICBtb2RlbF9maWxlPSJtb2RlbC56aXAiLAogICAgICAgICAgICB0YWc9c2VsZi5fdGFnLAogICAgICAgICAgICBmcmFtZXdvcms9Ikh1Z2dpbmcgRmFjZSIsCiAgICAgICAgICAgIGxhYmVscz1zZWxmLl9sYWJlbHMsCiAgICAgICAgICAgIGV4dHJhX2RhdGE9eyoqc2VsZi5fYXJ0aWZhY3RzLCAqKnNlbGYuX2V4dHJhX2RhdGF9LAogICAgICAgICkKCiAgICBkZWYgb25fZXZhbHVhdGUoCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9sb2dfbWV0cmljcygpCgogICAgICAgIGlmIHNlbGYuX2lzX3RyYWluaW5nOgogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgIyBUT0RPOiBVcGRhdGUgdGhlIG1vZGVsIG9iamVjdAoKICAgIGRlZiBfbG9nX21ldHJpY3Moc2VsZik6CiAgICAgICAgZm9yIG1ldHJpY19uYW1lLCBtZXRyaWNfc2NvcmVzIGluIHNlbGYuX21ldHJpY19zY29yZXMuaXRlbXMoKToKICAgICAgICAgICAgc2VsZi5fY29udGV4dC5sb2dfcmVzdWx0KGtleT1tZXRyaWNfbmFtZSwgdmFsdWU9bWV0cmljX3Njb3Jlc1stMV0pCiAgICAgICAgICAgIGlmIGxlbihtZXRyaWNfc2NvcmVzKSA+IDE6CiAgICAgICAgICAgICAgICBzZWxmLl9sb2dfbWV0cmljX3Bsb3QobmFtZT1tZXRyaWNfbmFtZSwgc2NvcmVzPW1ldHJpY19zY29yZXMpCiAgICAgICAgc2VsZi5fY29udGV4dC5jb21taXQoY29tcGxldGVkPUZhbHNlKQoKICAgIGRlZiBfbG9nX21ldHJpY19wbG90KHNlbGYsIG5hbWU6IHN0ciwgc2NvcmVzOiBMaXN0W2Zsb2F0XSk6CiAgICAgICAgIyBJbml0aWFsaXplIGEgcGxvdGx5IGZpZ3VyZToKICAgICAgICBtZXRyaWNfZmlndXJlID0gZ28uRmlndXJlKCkKCiAgICAgICAgIyBBZGQgdGl0bGVzOgogICAgICAgIG1ldHJpY19maWd1cmUudXBkYXRlX2xheW91dCgKICAgICAgICAgICAgdGl0bGU9bmFtZS5jYXBpdGFsaXplKCkucmVwbGFjZSgiXyIsICIgIiksCiAgICAgICAgICAgIHhheGlzX3RpdGxlPSJTYW1wbGVzIiwKICAgICAgICAgICAgeWF4aXNfdGl0bGU9IlNjb3JlcyIsCiAgICAgICAgKQoKICAgICAgICAjIERyYXc6CiAgICAgICAgbWV0cmljX2ZpZ3VyZS5hZGRfdHJhY2UoCiAgICAgICAgICAgIGdvLlNjYXR0ZXIoeD1ucC5hcmFuZ2UobGVuKHNjb3JlcykpLCB5PXNjb3JlcywgbW9kZT0ibGluZXMiKQogICAgICAgICkKCiAgICAgICAgIyBDcmVhdGUgdGhlIHBsb3RseSBhcnRpZmFjdDoKICAgICAgICBhcnRpZmFjdF9uYW1lID0gZiJ7bmFtZX1fcGxvdCIKICAgICAgICBhcnRpZmFjdCA9IFBsb3RseUFydGlmYWN0KGtleT1hcnRpZmFjdF9uYW1lLCBmaWd1cmU9bWV0cmljX2ZpZ3VyZSkKICAgICAgICBzZWxmLl9hcnRpZmFjdHNbYXJ0aWZhY3RfbmFtZV0gPSBzZWxmLl9jb250ZXh0LmxvZ19hcnRpZmFjdChhcnRpZmFjdCkKCgpkZWYgX2FwcGx5X21scnVuX29uX3RyYWluZXIoCiAgICB0cmFpbmVyOiB0cmFuc2Zvcm1lcnMuVHJhaW5lciwKICAgIG1vZGVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICB0YWc6IHN0ciA9ICIiLAogICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHggPSBOb25lLAogICAgYXV0b19sb2c6IGJvb2wgPSBUcnVlLAogICAgbGFiZWxzOiBEaWN0W3N0ciwgc3RyXSA9IE5vbmUsCiAgICBleHRyYV9kYXRhOiBkaWN0ID0gTm9uZSwKICAgICoqa3dhcmdzLAopOgogICAgIyBHZXQgcGFyYW1ldGVycyBkZWZhdWx0czoKICAgIGlmIGNvbnRleHQgaXMgTm9uZToKICAgICAgICBjb250ZXh0ID0gbWxydW4uZ2V0X29yX2NyZWF0ZV9jdHgoSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UuREVGQVVMVF9DT05URVhUX05BTUUpCgogICAgSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UuYWRkX2ludGVyZmFjZShvYmo9dHJhaW5lcikKCiAgICBpZiBhdXRvX2xvZzoKICAgICAgICB0cmFpbmVyLmFkZF9jYWxsYmFjaygKICAgICAgICAgICAgTUxSdW5DYWxsYmFjaygKICAgICAgICAgICAgICAgIGNvbnRleHQ9Y29udGV4dCwKICAgICAgICAgICAgICAgIG1vZGVsX25hbWU9bW9kZWxfbmFtZSwKICAgICAgICAgICAgICAgIHRhZz10YWcsCiAgICAgICAgICAgICAgICBsYWJlbHM9bGFiZWxzLAogICAgICAgICAgICAgICAgZXh0cmFfZGF0YT1leHRyYV9kYXRhLAogICAgICAgICAgICApCiAgICAgICAgKQoKCmRlZiBfYXBwbHlfbWxydW5fb25fb3B0aW1pemVyKAogICAgb3B0aW1pemVyLAogICAgbW9kZWxfbmFtZTogc3RyID0gTm9uZSwKICAgIHRhZzogc3RyID0gIiIsCiAgICBjb250ZXh0OiBtbHJ1bi5NTENsaWVudEN0eCA9IE5vbmUsCiAgICBhdXRvX2xvZzogYm9vbCA9IFRydWUsCiAgICBsYWJlbHM6IERpY3Rbc3RyLCBzdHJdID0gTm9uZSwKICAgIGV4dHJhX2RhdGE6IGRpY3QgPSBOb25lLAogICAgKiprd2FyZ3MsCik6CiAgICAjIEdldCBwYXJhbWV0ZXJzIGRlZmF1bHRzOgogICAgaWYgY29udGV4dCBpcyBOb25lOgogICAgICAgIGNvbnRleHQgPSBtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eCgKICAgICAgICAgICAgSEZPUlRPcHRpbWl6ZXJNTFJ1bkludGVyZmFjZS5ERUZBVUxUX0NPTlRFWFRfTkFNRQogICAgICAgICkKCiAgICBIRk9SVE9wdGltaXplck1MUnVuSW50ZXJmYWNlLmFkZF9pbnRlcmZhY2Uob2JqPW9wdGltaXplcikKCiAgICBpZiBhdXRvX2xvZzoKICAgICAgICBvcHRpbWl6ZXIuZW5hYmxlX2F1dG9fbG9nZ2luZygKICAgICAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgICAgICBtb2RlbF9uYW1lPW1vZGVsX25hbWUsCiAgICAgICAgICAgIHRhZz10YWcsCiAgICAgICAgICAgIGxhYmVscz1sYWJlbHMsCiAgICAgICAgICAgIGV4dHJhX2RhdGE9ZXh0cmFfZGF0YSwKICAgICAgICApCgoKZGVmIGFwcGx5X21scnVuKAogICAgaHVnZ2luZ2ZhY2Vfb2JqZWN0LAogICAgbW9kZWxfbmFtZTogc3RyID0gTm9uZSwKICAgIHRhZzogc3RyID0gIiIsCiAgICBjb250ZXh0OiBtbHJ1bi5NTENsaWVudEN0eCA9IE5vbmUsCiAgICBhdXRvX2xvZzogYm9vbCA9IFRydWUsCiAgICBsYWJlbHM6IERpY3Rbc3RyLCBzdHJdID0gTm9uZSwKICAgIGV4dHJhX2RhdGE6IGRpY3QgPSBOb25lLAogICAgKiprd2FyZ3MsCik6CiAgICAiIiIKICAgIFdyYXAgdGhlIGdpdmVuIG1vZGVsIHdpdGggTUxSdW4ncyBpbnRlcmZhY2UgcHJvdmlkaW5nIGl0IHdpdGggbWxydW4ncyBhZGRpdGlvbmFsIGZlYXR1cmVzLgogICAgOnBhcmFtIGh1Z2dpbmdmYWNlX29iamVjdDogVGhlIG1vZGVsIHRvIHdyYXAuIENhbiBiZSBsb2FkZWQgZnJvbSB0aGUgbW9kZWwgcGF0aCBnaXZlbiBhcyB3ZWxsLgogICAgOnBhcmFtIG1vZGVsX25hbWU6ICAgICAgICAgVGhlIG1vZGVsIG5hbWUgdG8gdXNlIGZvciBzdG9yaW5nIHRoZSBtb2RlbCBhcnRpZmFjdC4gRGVmYXVsdDogIm1vZGVsIi4KICAgIDpwYXJhbSB0YWc6ICAgICAgICAgICAgICAgIFRoZSBtb2RlbCdzIHRhZyB0byBsb2cgd2l0aC4KICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgIE1MUnVuIGNvbnRleHQgdG8gd29yayB3aXRoLiBJZiBubyBjb250ZXh0IGlzIGdpdmVuIGl0IHdpbGwgYmUgcmV0cmlldmVkIHZpYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21scnVuLmdldF9vcl9jcmVhdGVfY3R4KE5vbmUpJwogICAgOnBhcmFtIGF1dG9fbG9nOiAgICAgICAgICAgV2hldGhlciB0byBlbmFibGUgTUxSdW4ncyBhdXRvIGxvZ2dpbmcuIERlZmF1bHQ6IFRydWUuCiAgICAiIiIKCiAgICBpZiBpc2luc3RhbmNlKGh1Z2dpbmdmYWNlX29iamVjdCwgdHJhbnNmb3JtZXJzLlRyYWluZXIpOgogICAgICAgIHJldHVybiBfYXBwbHlfbWxydW5fb25fdHJhaW5lcigKICAgICAgICAgICAgdHJhaW5lcj1odWdnaW5nZmFjZV9vYmplY3QsCiAgICAgICAgICAgIG1vZGVsX25hbWU9bW9kZWxfbmFtZSwKICAgICAgICAgICAgdGFnPXRhZywKICAgICAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgICAgICBhdXRvX2xvZz1hdXRvX2xvZywKICAgICAgICAgICAgbGFiZWxzPWxhYmVscywKICAgICAgICAgICAgZXh0cmFfZGF0YT1leHRyYV9kYXRhLAogICAgICAgICkKICAgIGltcG9ydCBvcHRpbXVtLm9ubnhydW50aW1lIGFzIG9wdGltdW1fb3J0CgogICAgaWYgaXNpbnN0YW5jZShodWdnaW5nZmFjZV9vYmplY3QsIG9wdGltdW1fb3J0Lk9SVE9wdGltaXplcik6CiAgICAgICAgcmV0dXJuIF9hcHBseV9tbHJ1bl9vbl9vcHRpbWl6ZXIoCiAgICAgICAgICAgIG9wdGltaXplcj1odWdnaW5nZmFjZV9vYmplY3QsCiAgICAgICAgICAgIG1vZGVsX25hbWU9bW9kZWxfbmFtZSwKICAgICAgICAgICAgdGFnPXRhZywKICAgICAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgICAgICBhdXRvX2xvZz1hdXRvX2xvZywKICAgICAgICAgICAgbGFiZWxzPWxhYmVscywKICAgICAgICAgICAgZXh0cmFfZGF0YT1leHRyYV9kYXRhLAogICAgICAgICkKICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1bkludmFsaWRBcmd1bWVudEVycm9yCgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGZyb20gYXV0b190cmFpbmVyLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgS1dBcmdzUHJlZml4ZXM6CiAgICBNT0RFTF9DTEFTUyA9ICJDTEFTU18iCiAgICBGSVQgPSAiRklUXyIKICAgIFRSQUlOID0gIlRSQUlOXyIKICAgIFBSRURJQ1QgPSAiUFJFRElDVF8iCgoKZGVmIF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KHNyYzogRGljdCwgcHJlZml4X2tleTogc3RyKSAtPiBEaWN0W3N0ciwgQW55XToKICAgICIiIgogICAgQ29sbGVjdCBhbGwgdGhlIGtleXMgZnJvbSB0aGUgZ2l2ZW4gZGljdCB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwcmVmaXggYW5kIGNyZWF0ZXMgYSBuZXcgZGljdGlvbmFyeSB3aXRoIHRoZXNlCiAgICBrZXlzLgoKICAgIDpwYXJhbSBzcmM6ICAgICAgICAgVGhlIHNvdXJjZSBkaWN0IHRvIGV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tLgogICAgOnBhcmFtIHByZWZpeF9rZXk6ICBPbmx5IGtleXMgd2l0aCB0aGlzIHByZWZpeCB3aWxsIGJlIHJldHVybmVkLiBUaGUga2V5cyBpbiB0aGUgcmVzdWx0IGRpY3Qgd2lsbCBiZSB3aXRob3V0IHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4LgogICAgIiIiCiAgICByZXR1cm4gewogICAgICAgIGtleS5yZXBsYWNlKHByZWZpeF9rZXksICIiKTogdmFsCiAgICAgICAgZm9yIGtleSwgdmFsIGluIHNyYy5pdGVtcygpCiAgICAgICAgaWYga2V5LnN0YXJ0c3dpdGgocHJlZml4X2tleSkKICAgIH0KCgpkZWYgX2dldF9kYXRhZnJhbWUoCiAgICBjb250ZXh0OiBNTENsaWVudEN0eCwKICAgIGRhdGFzZXQ6IERhdGFJdGVtLAogICAgbGFiZWxfY29sdW1uczogT3B0aW9uYWxbVW5pb25bc3RyLCBMaXN0W3N0cl1dXSA9IE5vbmUsCiAgICBkcm9wX2NvbHVtbnM6IFVuaW9uW3N0ciwgTGlzdFtzdHJdLCBpbnQsIExpc3RbaW50XV0gPSBOb25lLAopIC0+IFR1cGxlW3BkLkRhdGFGcmFtZSwgT3B0aW9uYWxbVW5pb25bc3RyLCBMaXN0W3N0cl1dXV06CiAgICAiIiIKICAgIEdldHRpbmcgdGhlIERhdGFGcmFtZSBvZiB0aGUgZGF0YXNldCBhbmQgZHJvcCB0aGUgY29sdW1ucyBhY2NvcmRpbmdseS4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICBNTFJ1biBjb250ZXh0LgogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgVGhlIGRhdGFzZXQgdG8gdHJhaW4gdGhlIG1vZGVsIG9uLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIGVpdGhlciBhIGxpc3Qgb2YgbGlzdHMsIGRpY3QsIFVSSSBvciBhIEZlYXR1cmVWZWN0b3IuCiAgICA6cGFyYW0gbGFiZWxfY29sdW1uczogICBUaGUgdGFyZ2V0IGxhYmVsKHMpIG9mIHRoZSBjb2x1bW4ocykgaW4gdGhlIGRhdGFzZXQuIGZvciBSZWdyZXNzaW9uIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzc2lmaWNhdGlvbiB0YXNrcy4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgIHN0ci9pbnQgb3IgYSBsaXN0IG9mIHN0cmluZ3MvaW50cyB0aGF0IHJlcHJlc2VudCB0aGUgY29sdW1uIG5hbWVzL2luZGljZXMgdG8gZHJvcC4KICAgICIiIgogICAgaWYgaXNpbnN0YW5jZShkYXRhc2V0LCAobGlzdCwgZGljdCkpOgogICAgICAgIGRhdGFzZXQgPSBwZC5EYXRhRnJhbWUoZGF0YXNldCkKICAgICAgICAjIENoZWNraW5nIGlmIGRyb3BfY29sdW1ucyBwcm92aWRlZCBieSBpbnRlZ2VyIHR5cGU6CiAgICAgICAgaWYgZHJvcF9jb2x1bW5zOgogICAgICAgICAgICBpZiBpc2luc3RhbmNlKGRyb3BfY29sdW1ucywgc3RyKSBvciAoCiAgICAgICAgICAgICAgICBpc2luc3RhbmNlKGRyb3BfY29sdW1ucywgbGlzdCkKICAgICAgICAgICAgICAgIGFuZCBhbnkoaXNpbnN0YW5jZShjb2wsIHN0cikgZm9yIGNvbCBpbiBkcm9wX2NvbHVtbnMpCiAgICAgICAgICAgICk6CiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5lcnJvcigKICAgICAgICAgICAgICAgICAgICAiZHJvcF9jb2x1bW5zIG11c3QgYmUgYW4gaW50ZWdlci9saXN0IG9mIGludGVnZXJzIGlmIG5vdCBwcm92aWRlZCB3aXRoIGEgVVJJL0ZlYXR1cmVWZWN0b3IgZGF0YXNldCIKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IKICAgICAgICAgICAgZGF0YXNldC5kcm9wKGRyb3BfY29sdW1ucywgYXhpcz0xLCBpbnBsYWNlPVRydWUpCgogICAgICAgIHJldHVybiBkYXRhc2V0LCBsYWJlbF9jb2x1bW5zCgogICAgc3RvcmVfdXJpX3ByZWZpeCwgXyA9IG1scnVuLmRhdGFzdG9yZS5wYXJzZV9zdG9yZV91cmkoZGF0YXNldC5hcnRpZmFjdF91cmwpCiAgICBpZiBtbHJ1bi51dGlscy5TdG9yZVByZWZpeC5GZWF0dXJlVmVjdG9yID09IHN0b3JlX3VyaV9wcmVmaXg6CiAgICAgICAgIyBmZWF0dXJlLXZlY3RvciBjYXNlOgogICAgICAgIGxhYmVsX2NvbHVtbnMgPSBsYWJlbF9jb2x1bW5zIG9yIGRhdGFzZXQubWV0YS5zdGF0dXMubGFiZWxfY29sdW1uCiAgICAgICAgZGF0YXNldCA9IGZzLmdldF9vZmZsaW5lX2ZlYXR1cmVzKAogICAgICAgICAgICBkYXRhc2V0Lm1ldGEudXJpLCBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zCiAgICAgICAgKS50b19kYXRhZnJhbWUoKQoKICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKGYibGFiZWwgY29sdW1uczoge2xhYmVsX2NvbHVtbnN9IikKICAgIGVsc2U6CiAgICAgICAgIyBzaW1wbGUgVVJMIGNhc2U6CiAgICAgICAgZGF0YXNldCA9IGRhdGFzZXQuYXNfZGYoKQogICAgICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICAgICAgaWYgYWxsKGNvbCBpbiBkYXRhc2V0IGZvciBjb2wgaW4gZHJvcF9jb2x1bW5zKToKICAgICAgICAgICAgICAgIGRhdGFzZXQgPSBkYXRhc2V0LmRyb3AoZHJvcF9jb2x1bW5zLCBheGlzPTEpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKAogICAgICAgICAgICAgICAgICAgICJub3QgYWxsIG9mIHRoZSBjb2x1bW5zIHRvIGRyb3AgaW4gdGhlIGRhdGFzZXQsIGRyb3AgY29sdW1ucyBwcm9jZXNzIHNraXBwZWQiCiAgICAgICAgICAgICAgICApCiAgICByZXR1cm4gZGF0YXNldCwgbGFiZWxfY29sdW1ucwoKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBIdWdnaW5nIEZhY2UgVHJhaW5lciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCmRlZiBfY3JlYXRlX2NvbXB1dGVfbWV0cmljcyhtZXRyaWNzOiBMaXN0W3N0cl0pIC0+IENhbGxhYmxlW1tFdmFsUHJlZGljdGlvbl0sIERpY3RdOgogICAgIiIiCiAgICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZSBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgbWV0cmljcyBhdCBldmFsdWF0aW9uLgogICAgOnBhcmFtIG1ldHJpY3M6IExpc3Qgb2YgZGlmZmVyZW50IG1ldHJpY3MgZm9yIGV2YWx1YXRlIHRoZSBtb2RlbCBzdWNoIGFzIGYxLCBhY2N1cmFjeSBldGMuCgogICAgOnJldHVybnM6IEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgbWV0cmljcyBhdCBldmFsdWF0aW9uLgogICAgICAgICAgICAgTXVzdCB0YWtlIGEgW2BFdmFsUHJlZGljdGlvbmBdIGFuZCByZXR1cm4gYSBkaWN0aW9uYXJ5IHN0cmluZyB0byBtZXRyaWMgdmFsdWVzLgogICAgIiIiCgogICAgZGVmIF9jb21wdXRlX21ldHJpY3MoZXZhbF9wcmVkKToKICAgICAgICBsb2dpdHMsIGxhYmVscyA9IGV2YWxfcHJlZAogICAgICAgIHByZWRpY3Rpb25zID0gbnAuYXJnbWF4KGxvZ2l0cywgYXhpcz0tMSkKICAgICAgICBtZXRyaWNfZGljdF9yZXN1bHRzID0ge30KICAgICAgICBmb3IgbWV0cmljIGluIG1ldHJpY3M6CiAgICAgICAgICAgIGxvYWRfbWV0ID0gbG9hZF9tZXRyaWMobWV0cmljKQogICAgICAgICAgICBtZXRyaWNfcmVzID0gbG9hZF9tZXQuY29tcHV0ZShwcmVkaWN0aW9ucz1wcmVkaWN0aW9ucywgcmVmZXJlbmNlcz1sYWJlbHMpWwogICAgICAgICAgICAgICAgbWV0cmljCiAgICAgICAgICAgIF0KICAgICAgICAgICAgbWV0cmljX2RpY3RfcmVzdWx0c1ttZXRyaWNdID0gbWV0cmljX3JlcwoKICAgICAgICByZXR1cm4gbWV0cmljX2RpY3RfcmVzdWx0cwoKICAgIHJldHVybiBfY29tcHV0ZV9tZXRyaWNzCgoKZGVmIF9lZGl0X2NvbHVtbnMoCiAgICBkYXRhc2V0OiBEYXRhc2V0LAogICAgZHJvcF9jb2x1bW5zOiBMaXN0W3N0cl0gPSBOb25lLAogICAgcmVuYW1lX2NvbHVtbnM6IFtzdHIsIHN0cl0gPSBOb25lLAopIC0+IERhdGFzZXQ6CiAgICAiIiIKICAgIERyb3AgYW5kIHJlbmFtZXMgdGhhdCBjb2x1bW5zIG9mIHRoZSBnaXZlbiBkYXRhc2V0CiAgICA6cGFyYW0gZGF0YXNldDogICAgICAgICBEYXRhc2V0IHRvIHByb2Nlc3MKICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgIFRoZSBjb2x1bW5zIHRvIGRyb3AgZnJvbSB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSByZW5hbWVfY29sdW1uczogIERpY3Qgb2YgY29sdW1ucyBybyByZW5hbWUgOiB7PG9sZF9uYW1lPjogPG5ld19uYW1lPiwgLi4ufQoKICAgIDpyZXR1cm5zOiBUaGUgZGF0YXNldCBhZnRlciB0aGUgZGVzaXJlZCBwcm9jZXNzCiAgICAiIiIKICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICBkYXRhc2V0ID0gZGF0YXNldC5yZW1vdmVfY29sdW1ucyhkcm9wX2NvbHVtbnMpCiAgICBpZiByZW5hbWVfY29sdW1uczoKICAgICAgICBkYXRhc2V0ID0gZGF0YXNldC5yZW5hbWVfY29sdW1ucyhyZW5hbWVfY29sdW1ucykKICAgIHJldHVybiBkYXRhc2V0CgoKZGVmIF9wcmVwYXJlX2RhdGFzZXQoCiAgICBjb250ZXh0OiBNTENsaWVudEN0eCwKICAgIGRhdGFzZXRfbmFtZTogc3RyLAogICAgbGFiZWxfbmFtZTogc3RyID0gTm9uZSwKICAgIGRyb3BfY29sdW1uczogT3B0aW9uYWxbTGlzdFtzdHJdXSA9IE5vbmUsCiAgICBudW1fb2ZfdHJhaW5fc2FtcGxlczogaW50ID0gTm9uZSwKICAgIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZTogZmxvYXQgPSBOb25lLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSBOb25lLAopIC0+IFR1cGxlW0RhdGFzZXQsIERhdGFzZXRdOgogICAgIiIiCiAgICBMb2FkaW5nIHRoZSBkYXRhc2V0IGFuZCBlZGl0aW5nIHRoZSBjb2x1bW5zCgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICAgICAgICBNTFJ1biBjb250ZXgKICAgIDpwYXJhbSBkYXRhc2V0X25hbWU6ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZ2V0IGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1YgogICAgOnBhcmFtIGxhYmVsX25hbWU6ICAgICAgICAgICAgICBUaGUgdGFyZ2V0IGxhYmVsIG9mIHRoZSBjb2x1bW4gaW4gdGhlIGRhdGFzZXQuCiAgICA6cGFyYW0gZHJvcF9jb2x1bW5zOiAgICAgICAgICAgIFRoZSBjb2x1bW5zIHRvIGRyb3AgZnJvbSB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSBudW1fb2ZfdHJhaW5fc2FtcGxlczogICAgTWF4IG51bWJlciBvZiB0cmFpbmluZyBzYW1wbGVzLCBmb3IgZGVidWdnaW5nLgogICAgOnBhcmFtIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZTogICBTaG91bGQgYmUgYmV0d2VlbiAwLjAgYW5kIDEuMCBhbmQgcmVwcmVzZW50IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBkYXRhc2V0IHRvIGluY2x1ZGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIHRlc3Qgc3BsaXQuCiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICAgICAgIFJhbmRvbSBzdGF0ZSBmb3IgdHJhaW5fdGVzdF9zcGxpdAoKICAgICIiIgoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oCiAgICAgICAgZiJMb2FkaW5nIGFuZCBlZGl0aW5nIHtkYXRhc2V0X25hbWV9IGRhdGFzZXQgZnJvbSBIdWdnaW5nIEZhY2UgaHViIgogICAgKQogICAgcmVuYW1lX2NvbHMgPSB7bGFiZWxfbmFtZTogImxhYmVscyJ9CgogICAgIyBMb2FkaW5nIGFuZCBlZGl0aW5nIGRhdGFzZXQ6CiAgICBkYXRhc2V0ID0gbG9hZF9kYXRhc2V0KGRhdGFzZXRfbmFtZSkKCiAgICAjIHRyYWluIHNldAogICAgdHJhaW5fZGF0YXNldCA9IGRhdGFzZXRbInRyYWluIl0KICAgIGlmIG51bV9vZl90cmFpbl9zYW1wbGVzOgogICAgICAgIHRyYWluX2RhdGFzZXQgPSB0cmFpbl9kYXRhc2V0LnNodWZmbGUoc2VlZD1yYW5kb21fc3RhdGUpLnNlbGVjdCgKICAgICAgICAgICAgbGlzdChyYW5nZShudW1fb2ZfdHJhaW5fc2FtcGxlcykpCiAgICAgICAgKQogICAgdHJhaW5fZGF0YXNldCA9IF9lZGl0X2NvbHVtbnModHJhaW5fZGF0YXNldCwgZHJvcF9jb2x1bW5zLCByZW5hbWVfY29scykKCiAgICAjIHRlc3Qgc2V0CiAgICB0ZXN0X2RhdGFzZXQgPSBkYXRhc2V0WyJ0ZXN0Il0KICAgIGlmIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSBvciBudW1fb2ZfdHJhaW5fc2FtcGxlczoKICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUgPSB0cmFpbl90ZXN0X3NwbGl0X3NpemUgb3IgMC4yCiAgICAgICAgbnVtX29mX3Rlc3Rfc2FtcGxlcyA9IGludCgKICAgICAgICAgICAgKHRyYWluX2RhdGFzZXQubnVtX3Jvd3MgKiB0cmFpbl90ZXN0X3NwbGl0X3NpemUpCiAgICAgICAgICAgIC8vICgxIC0gdHJhaW5fdGVzdF9zcGxpdF9zaXplKQogICAgICAgICkKICAgICAgICB0ZXN0X2RhdGFzZXQgPSB0ZXN0X2RhdGFzZXQuc2h1ZmZsZShzZWVkPXJhbmRvbV9zdGF0ZSkuc2VsZWN0KAogICAgICAgICAgICBsaXN0KHJhbmdlKG51bV9vZl90ZXN0X3NhbXBsZXMpKQogICAgICAgICkKICAgIHRlc3RfZGF0YXNldCA9IF9lZGl0X2NvbHVtbnModGVzdF9kYXRhc2V0LCBkcm9wX2NvbHVtbnMsIHJlbmFtZV9jb2xzKQoKICAgIHJldHVybiB0cmFpbl9kYXRhc2V0LCB0ZXN0X2RhdGFzZXQKCgpkZWYgdHJhaW4oCiAgICBjb250ZXh0OiBNTENsaWVudEN0eCwKICAgIGhmX2RhdGFzZXQ6IHN0ciA9IE5vbmUsCiAgICBkYXRhc2V0OiBEYXRhSXRlbSA9IE5vbmUsCiAgICB0ZXN0X3NldDogRGF0YUl0ZW0gPSBOb25lLAogICAgZHJvcF9jb2x1bW5zOiBPcHRpb25hbFtMaXN0W3N0cl1dID0gTm9uZSwKICAgIHByZXRyYWluZWRfdG9rZW5pemVyOiBzdHIgPSBOb25lLAogICAgcHJldHJhaW5lZF9tb2RlbDogc3RyID0gTm9uZSwKICAgIG1vZGVsX2NsYXNzOiBzdHIgPSBOb25lLAogICAgbW9kZWxfbmFtZTogc3RyID0gImh1Z2dpbmdmYWNlLW1vZGVsIiwKICAgIGxhYmVsX25hbWU6IHN0ciA9ICJsYWJlbHMiLAogICAgdGV4dF9jb2w6IHN0ciA9ICJ0ZXh0IiwKICAgIG51bV9vZl90cmFpbl9zYW1wbGVzOiBpbnQgPSBOb25lLAogICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplOiBmbG9hdCA9IE5vbmUsCiAgICBtZXRyaWNzOiBMaXN0W3N0cl0gPSBOb25lLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSBOb25lLAopOgogICAgIiIiCiAgICBUcmFpbmluZyBhbmQgZXZhbHVhdGluZyBhIHByZXRyYWluZWQgbW9kZWwgd2l0aCBhIHByZXRyYWluZWQgdG9rZW5pemVyIG92ZXIgYSBkYXRhc2V0LgogICAgVGhlIGRhdGFzZXQgY2FuIGJlIGVpdGhlciBiZSB0aGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0aGF0IGNvbnRhaW5zIGluIHRoZSBIdWdnaW5nRmFjZSBodWIsCiAgICBvciBhIFVSSSBvciBhIEZlYXR1cmVWZWN0b3IKCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICAgICAgIE1MUnVuIGNvbnRleHQKICAgIDpwYXJhbSBoZl9kYXRhc2V0OiAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZ2V0IGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1YgogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgICAgICAgICBUaGUgZGF0YXNldCB0byB0cmFpbiB0aGUgbW9kZWwgb24uIENhbiBiZSBlaXRoZXIgYSBVUkkgb3IgYSBGZWF0dXJlVmVjdG9yCiAgICA6cGFyYW0gdGVzdF9zZXQ6ICAgICAgICAgICAgICAgIFRoZSB0ZXN0IHNldCB0byB0cmFpbiB0aGUgbW9kZWwgd2l0aC4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgICAgICAgICAgVGhlIGNvbHVtbnMgdG8gZHJvcCBmcm9tIHRoZSBkYXRhc2V0LgogICAgOnBhcmFtIHByZXRyYWluZWRfdG9rZW5pemVyOiAgICBUaGUgbmFtZSBvZiB0aGUgcHJldHJhaW5lZCB0b2tlbml6ZXIgZnJvbSB0aGUgSHVnZ2luZ0ZhY2UgaHViLgogICAgOnBhcmFtIHByZXRyYWluZWRfbW9kZWw6ICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcHJldHJhaW5lZCBtb2RlbCBmcm9tIHRoZSBIdWdnaW5nRmFjZSBodWIuCiAgICA6cGFyYW0gbW9kZWxfbmFtZTogICAgICAgICAgICAgIFRoZSBtb2RlbCdzIG5hbWUgdG8gdXNlIGZvciBzdG9yaW5nIHRoZSBtb2RlbCBhcnRpZmFjdCwgZGVmYXVsdCB0byAnbW9kZWwnCiAgICA6cGFyYW0gbW9kZWxfY2xhc3M6ICAgICAgICAgICAgIFRoZSBjbGFzcyBvZiB0aGUgbW9kZWwsIGUuZy4gYHRyYW5zZm9ybWVycy5BdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uYAogICAgOnBhcmFtIGxhYmVsX25hbWU6ICAgICAgICAgICAgICBUaGUgdGFyZ2V0IGxhYmVsIG9mIHRoZSBjb2x1bW4gaW4gdGhlIGRhdGFzZXQuCiAgICA6cGFyYW0gdGV4dF9jb2w6ICAgICAgICAgICAgICAgIFRoZSBpbnB1dCB0ZXh0IGNvbHVtbiB1biB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSBudW1fb2ZfdHJhaW5fc2FtcGxlczogICAgTWF4IG51bWJlciBvZiB0cmFpbmluZyBzYW1wbGVzLCBmb3IgZGVidWdnaW5nLgogICAgOnBhcmFtIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZTogICBTaG91bGQgYmUgYmV0d2VlbiAwLjAgYW5kIDEuMCBhbmQgcmVwcmVzZW50IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBkYXRhc2V0IHRvIGluY2x1ZGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIHRlc3Qgc3BsaXQuCiAgICA6cGFyYW0gbWV0cmljczogICAgICAgICAgICAgICAgIExpc3Qgb2YgZGlmZmVyZW50IG1ldHJpY3MgZm9yIGV2YWx1YXRlIHRoZSBtb2RlbCBzdWNoIGFzIGYxLCBhY2N1cmFjeSBldGMuCiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICAgICAgIFJhbmRvbSBzdGF0ZSBmb3IgdHJhaW5fdGVzdF9zcGxpdAogICAgIiIiCgogICAgaWYgdHJhaW5fdGVzdF9zcGxpdF9zaXplIGlzIE5vbmUgYW5kIHRlc3Rfc2V0IGlzIE5vbmU6CiAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbygKICAgICAgICAgICAgIid0cmFpbl90ZXN0X3NwbGl0X3NpemUnIGlzIG5vdCBwcm92aWRlZCwgc2V0dGluZyB0cmFpbl90ZXN0X3NwbGl0X3NpemUgdG8gMC4yIgogICAgICAgICkKICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUgPSAwLjIKCiAgICAjIENyZWF0aW5nIHRva2VuaXplcjoKICAgIHRva2VuaXplciA9IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfdG9rZW5pemVyKQoKICAgIGRlZiBwcmVwcm9jZXNzX2Z1bmN0aW9uKGV4YW1wbGVzKToKICAgICAgICByZXR1cm4gdG9rZW5pemVyKGV4YW1wbGVzW3RleHRfY29sXSwgdHJ1bmNhdGlvbj1UcnVlKQoKICAgICMgcHJlcGFyZSBkYXRhIGZvciB0cmFpbmluZwogICAgaWYgaGZfZGF0YXNldDoKICAgICAgICB0cmFpbl9kYXRhc2V0LCB0ZXN0X2RhdGFzZXQgPSBfcHJlcGFyZV9kYXRhc2V0KAogICAgICAgICAgICBjb250ZXh0LAogICAgICAgICAgICBoZl9kYXRhc2V0LAogICAgICAgICAgICBsYWJlbF9uYW1lLAogICAgICAgICAgICBkcm9wX2NvbHVtbnMsCiAgICAgICAgICAgIG51bV9vZl90cmFpbl9zYW1wbGVzLAogICAgICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUsCiAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUsCiAgICAgICAgKQogICAgZWxpZiBkYXRhc2V0OgogICAgICAgICMgR2V0IERhdGFGcmFtZSBieSBVUkwgb3IgYnkgRmVhdHVyZVZlY3RvcjoKICAgICAgICB0cmFpbl9kYXRhc2V0LCBsYWJlbF9uYW1lID0gX2dldF9kYXRhZnJhbWUoCiAgICAgICAgICAgIGNvbnRleHQ9Y29udGV4dCwKICAgICAgICAgICAgZGF0YXNldD1kYXRhc2V0LAogICAgICAgICAgICBsYWJlbF9jb2x1bW5zPWxhYmVsX25hbWUsCiAgICAgICAgICAgIGRyb3BfY29sdW1ucz1kcm9wX2NvbHVtbnMsCiAgICAgICAgKQogICAgICAgIGlmIHRlc3Rfc2V0OgogICAgICAgICAgICB0ZXN0X2RhdGFzZXQsIF8gPSBfZ2V0X2RhdGFmcmFtZSgKICAgICAgICAgICAgICAgIGNvbnRleHQ9Y29udGV4dCwKICAgICAgICAgICAgICAgIGRhdGFzZXQ9dGVzdF9zZXQsCiAgICAgICAgICAgICAgICBsYWJlbF9jb2x1bW5zPWxhYmVsX25hbWUsCiAgICAgICAgICAgICAgICBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zLAogICAgICAgICAgICApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgdHJhaW5fZGF0YXNldCwgdGVzdF9kYXRhc2V0ID0gdHJhaW5fdGVzdF9zcGxpdCgKICAgICAgICAgICAgICAgIHRyYWluX2RhdGFzZXQsCiAgICAgICAgICAgICAgICB0ZXN0X3NpemU9dHJhaW5fdGVzdF9zcGxpdF9zaXplLAogICAgICAgICAgICAgICAgcmFuZG9tX3N0YXRlPXJhbmRvbV9zdGF0ZSwKICAgICAgICAgICAgKQogICAgICAgIHRyYWluX2RhdGFzZXQgPSBEYXRhc2V0LmZyb21fcGFuZGFzKHRyYWluX2RhdGFzZXQpCiAgICAgICAgdGVzdF9kYXRhc2V0ID0gRGF0YXNldC5mcm9tX3BhbmRhcyh0ZXN0X2RhdGFzZXQpCiAgICBlbHNlOgogICAgICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1bkludmFsaWRBcmd1bWVudEVycm9yKAogICAgICAgICAgICAiVHJhaW5pbmcgZGF0YSB3YXMgbm90IHByb3ZpZGVkLiBBIHRyYWluaW5nIGRhdGFzZXQgaXMgbWFuZGF0b3J5IGZvciB0cmFpbmluZy4iCiAgICAgICAgICAgICIgUGxlYXNlIHByb3ZpZGUgYSB0cmFpbmluZyBzZXQgdXNpbmcgb25lIG9mIHRoZSBhcmd1bWVudHMgJ2hmX2RhdGFzZXQnIG9yICdkYXRhc2V0Jy4iCiAgICAgICAgKQoKICAgICMgTWFwcGluZyBkYXRhc2V0cyB3aXRoIHRoZSB0b2tlbml6ZXI6CiAgICB0b2tlbml6ZWRfdHJhaW4gPSB0cmFpbl9kYXRhc2V0Lm1hcChwcmVwcm9jZXNzX2Z1bmN0aW9uLCBiYXRjaGVkPVRydWUpCiAgICB0b2tlbml6ZWRfdGVzdCA9IHRlc3RfZGF0YXNldC5tYXAocHJlcHJvY2Vzc19mdW5jdGlvbiwgYmF0Y2hlZD1UcnVlKQoKICAgICMgQ3JlYXRpbmcgZGF0YSBjb2xsYXRvciBmb3IgYmF0Y2hpbmc6CiAgICBkYXRhX2NvbGxhdG9yID0gRGF0YUNvbGxhdG9yV2l0aFBhZGRpbmcodG9rZW5pemVyPXRva2VuaXplcikKCiAgICAjIFBhcnNpbmcga3dhcmdzOgogICAgdHJhaW5fa3dhcmdzID0gX2dldF9zdWJfZGljdF9ieV9wcmVmaXgoCiAgICAgICAgc3JjPWNvbnRleHQucGFyYW1ldGVycywgcHJlZml4X2tleT1LV0FyZ3NQcmVmaXhlcy5UUkFJTgogICAgKQogICAgbW9kZWxfY2xhc3Nfa3dhcmdzID0gX2dldF9zdWJfZGljdF9ieV9wcmVmaXgoCiAgICAgICAgc3JjPWNvbnRleHQucGFyYW1ldGVycywgcHJlZml4X2tleT1LV0FyZ3NQcmVmaXhlcy5NT0RFTF9DTEFTUwogICAgKQoKICAgICMgTG9hZGluZyBvdXIgcHJldHJhaW5lZCBtb2RlbDoKICAgIG1vZGVsX2NsYXNzX2t3YXJnc1sicHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgiXSA9ICgKICAgICAgICBtb2RlbF9jbGFzc19rd2FyZ3MuZ2V0KCJwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCIpIG9yIHByZXRyYWluZWRfbW9kZWwKICAgICkKICAgIHRyYWluX2t3YXJnc1siaHViX3Rva2VuIl0gPSB0cmFpbl9rd2FyZ3MuZ2V0KCJodWJfdG9rZW4iKSBvciBwcmV0cmFpbmVkX3Rva2VuaXplcgogICAgaWYgbm90IG1vZGVsX2NsYXNzX2t3YXJnc1sicHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgiXToKICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5SdW50aW1lRXJyb3IoCiAgICAgICAgICAgICJNdXN0IHByb3ZpZGUgcHJldHJhaW5lZF9tb2RlbCBuYW1lIGFzICIKICAgICAgICAgICAgImZ1bmN0aW9uIGFyZ3VtZW50IG9yIGluIGV4dHJhIHBhcmFtcyIKICAgICAgICApCiAgICBtb2RlbCA9IGNyZWF0ZV9jbGFzcyhtb2RlbF9jbGFzcykuZnJvbV9wcmV0cmFpbmVkKCoqbW9kZWxfY2xhc3Nfa3dhcmdzKQoKICAgICMgUHJlcGFyaW5nIHRyYWluaW5nIGFyZ3VtZW50czoKICAgIHRyYWluaW5nX2FyZ3MgPSBUcmFpbmluZ0FyZ3VtZW50cygKICAgICAgICAqKnRyYWluX2t3YXJncywKICAgICkKCiAgICBjb21wdXRlX21ldHJpY3MgPSBfY3JlYXRlX2NvbXB1dGVfbWV0cmljcyhtZXRyaWNzKSBpZiBtZXRyaWNzIGVsc2UgTm9uZQogICAgdHJhaW5lciA9IFRyYWluZXIoCiAgICAgICAgbW9kZWw9bW9kZWwsCiAgICAgICAgYXJncz10cmFpbmluZ19hcmdzLAogICAgICAgIHRyYWluX2RhdGFzZXQ9dG9rZW5pemVkX3RyYWluLAogICAgICAgIGV2YWxfZGF0YXNldD10b2tlbml6ZWRfdGVzdCwKICAgICAgICB0b2tlbml6ZXI9dG9rZW5pemVyLAogICAgICAgIGRhdGFfY29sbGF0b3I9ZGF0YV9jb2xsYXRvciwKICAgICAgICBjb21wdXRlX21ldHJpY3M9Y29tcHV0ZV9tZXRyaWNzLAogICAgKQoKICAgIGFwcGx5X21scnVuKHRyYWluZXIsIG1vZGVsX25hbWU9bW9kZWxfbmFtZSkKCiAgICAjIEFwcGx5IHRyYWluaW5nIHdpdGggZXZhbHVhdGlvbjoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oZiJ0cmFpbmluZyAne21vZGVsX25hbWV9JyIpCiAgICB0cmFpbmVyLnRyYWluKCkKCgpkZWYgX2dldF9tb2RlbF9kaXIobW9kZWxfdXJpOiBzdHIpOgogICAgbW9kZWxfZmlsZSwgXywgXyA9IG1scnVuLmFydGlmYWN0cy5nZXRfbW9kZWwobW9kZWxfdXJpKQogICAgbW9kZWxfZGlyID0gdGVtcGZpbGUuZ2V0dGVtcGRpcigpCiAgICAjIFVuemlwIHRoZSBNb2RlbDoKICAgIHdpdGggemlwZmlsZS5aaXBGaWxlKG1vZGVsX2ZpbGUsICJyIikgYXMgemlwX2ZpbGU6CiAgICAgICAgemlwX2ZpbGUuZXh0cmFjdGFsbChtb2RlbF9kaXIpCgogICAgcmV0dXJuIG1vZGVsX2RpcgoKCmRlZiBvcHRpbWl6ZSgKICAgIG1vZGVsX3BhdGg6IHN0ciwKICAgIG1vZGVsX25hbWU6IHN0ciA9ICJvcHRpbWl6ZWRfbW9kZWwiLAogICAgdGFyZ2V0X2Rpcjogc3RyID0gIi4vb3B0aW1pemVkIiwKICAgIG9wdGltaXphdGlvbl9sZXZlbDogaW50ID0gMSwKKToKICAgICIiIgogICAgT3B0aW1pemluZyB0aGUgdHJhbnNmb3JtZXIgbW9kZWwgdXNpbmcgT05OWCBvcHRpbWl6YXRpb24uCgoKICAgIDpwYXJhbSBtb2RlbF9wYXRoOiAgICAgICAgICBUaGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gb3B0aW1pemUuCiAgICA6cGFyYW0gbW9kZWxfbmFtZTogICAgICAgICAgTmFtZSBvZiB0aGUgb3B0aW1pemVkIG1vZGVsLgogICAgOnBhcmFtIHRhcmdldF9kaXI6ICAgICAgICAgIFRoZSBkaXJlY3RvcnkgdG8gc2F2ZSB0aGUgT05OWCBtb2RlbC4KICAgIDpwYXJhbSBvcHRpbWl6YXRpb25fbGV2ZWw6ICBPcHRpbWl6YXRpb24gbGV2ZWwgcGVyZm9ybWVkIGJ5IE9OTlggUnVudGltZSBvZiB0aGUgbG9hZGVkIGdyYXBoLiAoZGVmYXVsdCBpcyAxKQogICAgIiIiCiAgICAjIFdlIGltcG9ydCB0aGVzZSBpbiB0aGUgZnVuY3Rpb24gc2NvcGUgc28gT05OWCB3b24ndCBiZSBtYW5kYXRvcnkgZm9yIHRoZSBvdGhlciBoYW5kbGVyczoKICAgIGZyb20gb3B0aW11bS5vbm54cnVudGltZSBpbXBvcnQgT1JUTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLCBPUlRPcHRpbWl6ZXIKICAgIGZyb20gb3B0aW11bS5vbm54cnVudGltZS5jb25maWd1cmF0aW9uIGltcG9ydCBPcHRpbWl6YXRpb25Db25maWcKCiAgICBtb2RlbF9kaXIgPSBfZ2V0X21vZGVsX2Rpcihtb2RlbF91cmk9bW9kZWxfcGF0aCkKICAgICMgQ3JlYXRpbmcgY29uZmlndXJhdGlvbiBmb3Igb3B0aW1pemF0aW9uIHN0ZXA6CiAgICBvcHRpbWl6YXRpb25fY29uZmlnID0gT3B0aW1pemF0aW9uQ29uZmlnKG9wdGltaXphdGlvbl9sZXZlbD1vcHRpbWl6YXRpb25fbGV2ZWwpCgogICAgIyBDb252ZXJ0aW5nIG91ciBwcmV0cmFpbmVkIG1vZGVsIHRvIGFuIE9OTlgtUnVudGltZSBtb2RlbDoKICAgIG9ydF9tb2RlbCA9IE9SVE1vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbi5mcm9tX3ByZXRyYWluZWQoCiAgICAgICAgbW9kZWxfZGlyLCBmcm9tX3RyYW5zZm9ybWVycz1UcnVlCiAgICApCgogICAgIyBDcmVhdGluZyBhbiBPTk5YLVJ1bnRpbWUgb3B0aW1pemVyIGZyb20gT05OWCBtb2RlbDoKICAgIG9wdGltaXplciA9IE9SVE9wdGltaXplci5mcm9tX3ByZXRyYWluZWQob3J0X21vZGVsKQoKICAgIGFwcGx5X21scnVuKG9wdGltaXplciwgbW9kZWxfbmFtZT1tb2RlbF9uYW1lKQogICAgIyBPcHRpbWl6aW5nIGFuZCBzYXZpbmcgdGhlIE9OTlggbW9kZWw6CiAgICBvcHRpbWl6ZXIub3B0aW1pemUoc2F2ZV9kaXI9dGFyZ2V0X2Rpciwgb3B0aW1pemF0aW9uX2NvbmZpZz1vcHRpbWl6YXRpb25fY29uZmlnKQo=
    base_image: mlrun/mlrun
    commands: []
    code_origin: ''
    origin_filename: ''
    requirements:
    - onnx~=1.14.1
    - onnxruntime~=1.16.1
    - optimum~=1.6.4
    - transformers~=4.26.1
    - datasets~=2.10.1
    - scikit-learn~=1.0.2
  entry_points:
    add_interface:
      name: add_interface
      doc: 'Enrich the object with this interface properties, methods and functions,
        so it will have this TensorFlow.Keras

        MLRuns features.'
      parameters:
      - name: cls
      - name: obj
        type: Trainer
        doc: The object to enrich his interface.
      - name: restoration
        type: MLRunInterfaceRestorationType
        doc: Restoration information tuple as returned from 'remove_interface' in
          order to add the interface in a certain state.
        default: null
      outputs: []
      lineno: 146
      has_varargs: false
      has_kwargs: false
    mlrun_optimize:
      name: mlrun_optimize
      doc: 'MLRun''s tf.keras.Model.fit wrapper. It will setup the optimizer when
        using horovod. The optimizer must be

        passed in a keyword argument and when using horovod, it must be passed as
        an Optimizer instance, not a string.


        raise MLRunInvalidArgumentError: In case the optimizer provided did not follow
        the instructions above.'
      parameters:
      - name: cls
      outputs: []
      lineno: 79
      has_varargs: false
      has_kwargs: false
    wrapper:
      name: wrapper
      doc: ''
      parameters:
      - name: self
        type: Trainer
      outputs: []
      lineno: 173
      has_varargs: true
      has_kwargs: true
    enable_auto_logging:
      name: enable_auto_logging
      doc: ''
      parameters:
      - name: self
      - name: context
        type: MLClientCtx
      - name: model_name
        type: str
        default: model
      - name: tag
        type: str
        default: ''
      - name: labels
        type: Dict[str, str]
        default: null
      - name: extra_data
        type: dict
        default: null
      outputs: []
      lineno: 114
      has_varargs: false
      has_kwargs: false
    mlrun_train:
      name: mlrun_train
      doc: 'MLRuns tf.keras.Model.fit wrapper. It will setup the optimizer when using
        horovod. The optimizer must be

        passed in a keyword argument and when using horovod, it must be passed as
        an Optimizer instance, not a string.


        raise MLRunInvalidArgumentError: In case the optimizer provided did not follow
        the instructions above.'
      parameters:
      - name: cls
      outputs: []
      lineno: 164
      has_varargs: false
      has_kwargs: false
    on_epoch_begin:
      name: on_epoch_begin
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      outputs: []
      lineno: 220
      has_varargs: false
      has_kwargs: true
    on_epoch_end:
      name: on_epoch_end
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      outputs: []
      lineno: 229
      has_varargs: false
      has_kwargs: true
    on_log:
      name: on_log
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      - name: logs
        type: Dict[str, float]
        default: null
      outputs: []
      lineno: 238
      has_varargs: false
      has_kwargs: true
    on_train_begin:
      name: on_train_begin
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      outputs: []
      lineno: 262
      has_varargs: false
      has_kwargs: true
    on_train_end:
      name: on_train_end
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      - name: model
        type: PreTrainedModel
        default: null
      - name: tokenizer
        type: PreTrainedTokenizer
        default: null
      outputs: []
      lineno: 271
      has_varargs: false
      has_kwargs: true
    on_evaluate:
      name: on_evaluate
      doc: ''
      parameters:
      - name: self
      - name: args
        type: TrainingArguments
      - name: state
        type: TrainerState
      - name: control
        type: TrainerControl
      outputs: []
      lineno: 322
      has_varargs: false
      has_kwargs: true
    apply_mlrun:
      name: apply_mlrun
      doc: Wrap the given model with MLRun's interface providing it with mlrun's additional
        features.
      parameters:
      - name: huggingface_object
        doc: The model to wrap. Can be loaded from the model path given as well.
      - name: model_name
        type: str
        doc: 'The model name to use for storing the model artifact. Default: "model".'
        default: null
      - name: tag
        type: str
        doc: The model's tag to log with.
        default: ''
      - name: context
        type: MLClientCtx
        doc: MLRun context to work with. If no context is given it will be retrieved
          via 'mlrun.get_or_create_ctx(None)'
        default: null
      - name: auto_log
        type: bool
        doc: 'Whether to enable MLRun''s auto logging. Default: True.'
        default: true
      - name: labels
        type: Dict[str, str]
        default: null
      - name: extra_data
        type: dict
        default: null
      outputs: []
      lineno: 421
      has_varargs: false
      has_kwargs: true
    train:
      name: train
      doc: 'Training and evaluating a pretrained model with a pretrained tokenizer
        over a dataset.

        The dataset can be either be the name of the dataset that contains in the
        HuggingFace hub,

        or a URI or a FeatureVector'
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context
      - name: hf_dataset
        type: str
        doc: The name of the dataset to get from the HuggingFace hub
        default: null
      - name: dataset
        type: DataItem
        doc: The dataset to train the model on. Can be either a URI or a FeatureVector
        default: null
      - name: test_set
        type: DataItem
        doc: The test set to train the model with.
        default: null
      - name: drop_columns
        type: Optional[List[str]]
        doc: The columns to drop from the dataset.
        default: null
      - name: pretrained_tokenizer
        type: str
        doc: The name of the pretrained tokenizer from the HuggingFace hub.
        default: null
      - name: pretrained_model
        type: str
        doc: The name of the pretrained model from the HuggingFace hub.
        default: null
      - name: model_class
        type: str
        doc: The class of the model, e.g. `transformers.AutoModelForSequenceClassification`
        default: null
      - name: model_name
        type: str
        doc: The model's name to use for storing the model artifact, default to 'model'
        default: huggingface-model
      - name: label_name
        type: str
        doc: The target label of the column in the dataset.
        default: labels
      - name: text_col
        type: str
        doc: The input text column un the dataset.
        default: text
      - name: num_of_train_samples
        type: int
        doc: Max number of training samples, for debugging.
        default: null
      - name: train_test_split_size
        type: float
        doc: Should be between 0.0 and 1.0 and represent the proportion of the dataset
          to include in the test split.
        default: null
      - name: metrics
        type: List[str]
        doc: List of different metrics for evaluate the model such as f1, accuracy
          etc.
        default: null
      - name: random_state
        type: int
        doc: Random state for train_test_split
        default: null
      outputs: []
      lineno: 647
      has_varargs: false
      has_kwargs: false
    preprocess_function:
      name: preprocess_function
      doc: ''
      parameters:
      - name: examples
      outputs: []
      lineno: 696
      has_varargs: false
      has_kwargs: false
    optimize:
      name: optimize
      doc: Optimizing the transformer model using ONNX optimization.
      parameters:
      - name: model_path
        type: str
        doc: The path of the model to optimize.
      - name: model_name
        type: str
        doc: Name of the optimized model.
        default: optimized_model
      - name: target_dir
        type: str
        doc: The directory to save the ONNX model.
        default: ./optimized
      - name: optimization_level
        type: int
        doc: Optimization level performed by ONNX Runtime of the loaded graph. (default
          is 1)
        default: 1
      outputs: []
      lineno: 799
      has_varargs: false
      has_kwargs: false
  description: Automatic train and optimize functions for HuggingFace framework
  default_handler: train
  disable_auto_mount: false
  clone_target_dir: ''
  env: []
  priority_class_name: ''
  preemption_mode: prevent
  affinity: null
  tolerations: null
  security_context: {}
verbose: false
