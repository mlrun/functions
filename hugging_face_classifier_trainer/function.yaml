kind: job
metadata:
  name: hugging-face-classifier-trainer
  tag: ''
  hash: fa99774ad6578d80ffca95b4184e68e3cdf0fb0e
  project: ''
  labels:
    author: davids
  categories:
  - machine-learning
  - model-training
spec:
  command: ''
  args: []
  image: mlrun/mlrun
  build:
    functionSourceCode: aW1wb3J0IG9zCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRlbXBmaWxlCmZyb20gYWJjIGltcG9ydCBBQkMKZnJvbSB0eXBpbmcgaW1wb3J0IERpY3QsIExpc3QsIE9wdGlvbmFsLCBBbnkKCmltcG9ydCBtbHJ1bgppbXBvcnQgbnVtcHkgYXMgbnAKCmltcG9ydCB0cmFuc2Zvcm1lcnMKZnJvbSBkYXRhc2V0cyBpbXBvcnQgRGF0YXNldCwgbG9hZF9kYXRhc2V0LCBsb2FkX21ldHJpYwpmcm9tIG1scnVuIGltcG9ydCBNTENsaWVudEN0eApmcm9tIG1scnVuLmFydGlmYWN0cyBpbXBvcnQgQXJ0aWZhY3QsIFBsb3RseUFydGlmYWN0CmZyb20gbWxydW4uZnJhbWV3b3Jrcy5fY29tbW9uIGltcG9ydCBDb21tb25UeXBlcywgTUxSdW5JbnRlcmZhY2UKZnJvbSBtbHJ1bi51dGlscyBpbXBvcnQgY3JlYXRlX2NsYXNzCmZyb20gcGxvdGx5IGltcG9ydCBncmFwaF9vYmplY3RzIGFzIGdvCgpmcm9tIHRyYW5zZm9ybWVycyBpbXBvcnQgKAogICAgQXV0b1Rva2VuaXplciwKICAgIERhdGFDb2xsYXRvcldpdGhQYWRkaW5nLAogICAgUHJlVHJhaW5lZE1vZGVsLAogICAgUHJlVHJhaW5lZFRva2VuaXplciwKICAgIFRyYWluZXIsCiAgICBUcmFpbmVyQ2FsbGJhY2ssCiAgICBUcmFpbmVyQ29udHJvbCwKICAgIFRyYWluZXJTdGF0ZSwKICAgIFRyYWluaW5nQXJndW1lbnRzLAopCgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tZnJvbSBNTFJVTi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmNsYXNzIEhGVHJhaW5lck1MUnVuSW50ZXJmYWNlKE1MUnVuSW50ZXJmYWNlLCBBQkMpOgogICAgIiIiCiAgICBJbnRlcmZhY2UgZm9yIGFkZGluZyBNTFJ1biBmZWF0dXJlcyBmb3IgdGVuc29yZmxvdyBrZXJhcyBBUEkuCiAgICAiIiIKCiAgICAjIE1MUnVucyBjb250ZXh0IGRlZmF1bHQgbmFtZToKICAgIERFRkFVTFRfQ09OVEVYVF9OQU1FID0gIm1scnVuLWh1Z2dpbmdmYWNlIgoKICAgICMgQXR0cmlidXRlcyB0byByZXBsYWNlIHNvIHRoZSBNTFJ1biBpbnRlcmZhY2Ugd2lsbCBiZSBmdWxseSBlbmFibGVkLgogICAgX1JFUExBQ0VEX01FVEhPRFMgPSBbCiAgICAgICAgInRyYWluIiwKICAgICAgICAjICJldmFsdWF0ZSIKICAgIF0KCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBhZGRfaW50ZXJmYWNlKAogICAgICAgIGNscywKICAgICAgICBvYmo6IFRyYWluZXIsCiAgICAgICAgcmVzdG9yYXRpb246IENvbW1vblR5cGVzLk1MUnVuSW50ZXJmYWNlUmVzdG9yYXRpb25UeXBlID0gTm9uZSwKICAgICk6CiAgICAgICAgIiIiCiAgICAgICAgRW5yaWNoIHRoZSBvYmplY3Qgd2l0aCB0aGlzIGludGVyZmFjZSBwcm9wZXJ0aWVzLCBtZXRob2RzIGFuZCBmdW5jdGlvbnMsIHNvIGl0IHdpbGwgaGF2ZSB0aGlzIFRlbnNvckZsb3cuS2VyYXMKICAgICAgICBNTFJ1bnMgZmVhdHVyZXMuCiAgICAgICAgOnBhcmFtIG9iajogICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IHRvIGVucmljaCBoaXMgaW50ZXJmYWNlLgogICAgICAgIDpwYXJhbSByZXN0b3JhdGlvbjogUmVzdG9yYXRpb24gaW5mb3JtYXRpb24gdHVwbGUgYXMgcmV0dXJuZWQgZnJvbSAncmVtb3ZlX2ludGVyZmFjZScgaW4gb3JkZXIgdG8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZCB0aGUgaW50ZXJmYWNlIGluIGEgY2VydGFpbiBzdGF0ZS4KICAgICAgICAiIiIKCiAgICAgICAgc3VwZXIoSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UsIGNscykuYWRkX2ludGVyZmFjZSgKICAgICAgICAgICAgb2JqPW9iaiwgcmVzdG9yYXRpb249cmVzdG9yYXRpb24KICAgICAgICApCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgbWxydW5fdHJhaW4oY2xzKToKCiAgICAgICAgIiIiCiAgICAgICAgTUxSdW5zIHRmLmtlcmFzLk1vZGVsLmZpdCB3cmFwcGVyLiBJdCB3aWxsIHNldHVwIHRoZSBvcHRpbWl6ZXIgd2hlbiB1c2luZyBob3Jvdm9kLiBUaGUgb3B0aW1pemVyIG11c3QgYmUKICAgICAgICBwYXNzZWQgaW4gYSBrZXl3b3JkIGFyZ3VtZW50IGFuZCB3aGVuIHVzaW5nIGhvcm92b2QsIGl0IG11c3QgYmUgcGFzc2VkIGFzIGFuIE9wdGltaXplciBpbnN0YW5jZSwgbm90IGEgc3RyaW5nLgoKICAgICAgICByYWlzZSBNTFJ1bkludmFsaWRBcmd1bWVudEVycm9yOiBJbiBjYXNlIHRoZSBvcHRpbWl6ZXIgcHJvdmlkZWQgZGlkIG5vdCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhYm92ZS4KICAgICAgICAiIiIKCiAgICAgICAgZGVmIHdyYXBwZXIoc2VsZjogVHJhaW5lciwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgIyBSZXN0b3JlIHRoZSBldmFsdWF0aW9uIG1ldGhvZCBhcyBgdHJhaW5gIHdpbGwgdXNlIGl0OgogICAgICAgICAgICAjIGNscy5fcmVzdG9yZV9hdHRyaWJ1dGUob2JqPXNlbGYsIGF0dHJpYnV0ZV9uYW1lPSJldmFsdWF0ZSIpCgogICAgICAgICAgICAjIENhbGwgdGhlIG9yaWdpbmFsIGZpdCBtZXRob2Q6CiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYub3JpZ2luYWxfdHJhaW4oKmFyZ3MsICoqa3dhcmdzKQoKICAgICAgICAgICAgIyBSZXBsYWNlIHRoZSBldmFsdWF0aW9uIG1ldGhvZCBhZ2FpbjoKICAgICAgICAgICAgIyBjbHMuX3JlcGxhY2VfZnVuY3Rpb24ob2JqPXNlbGYsIGZ1bmN0aW9uX25hbWU9ImV2YWx1YXRlIikKCiAgICAgICAgICAgIHJldHVybiByZXN1bHQKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCgpjbGFzcyBNTFJ1bkNhbGxiYWNrKFRyYWluZXJDYWxsYmFjayk6CiAgICAiIiIKICAgIENhbGxiYWNrIGZvciBjb2xsZWN0aW5nIGxvZ3MgZHVyaW5nIHRyYWluaW5nIC8gZXZhbHVhdGlvbiBvZiB0aGUgYFRyYWluZXJgIEFQSS4KICAgICIiIgoKICAgIGRlZiBfX2luaXRfXygKICAgICAgICBzZWxmLAogICAgICAgIGNvbnRleHQ6IG1scnVuLk1MQ2xpZW50Q3R4ID0gTm9uZSwKICAgICAgICBtb2RlbF9uYW1lOiBzdHIgPSAibW9kZWwiLAogICAgICAgIHRhZzogc3RyID0gIiIsCiAgICAgICAgbGFiZWxzOiBEaWN0W3N0ciwgc3RyXSA9IE5vbmUsCiAgICAgICAgZXh0cmFfZGF0YTogZGljdCA9IE5vbmUsCiAgICApOgogICAgICAgIHN1cGVyKCkuX19pbml0X18oKQoKICAgICAgICAjIFN0b3JlIHRoZSBjb25maWd1cmF0aW9uczoKICAgICAgICBzZWxmLl9jb250ZXh0ID0gKAogICAgICAgICAgICBjb250ZXh0CiAgICAgICAgICAgIGlmIGNvbnRleHQgaXMgbm90IE5vbmUKICAgICAgICAgICAgZWxzZSBtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eCgiLi9tbHJ1bi1odWdnaW5nZmFjZSIpCiAgICAgICAgKQogICAgICAgIHNlbGYuX21vZGVsX25hbWUgPSBtb2RlbF9uYW1lCiAgICAgICAgc2VsZi5fdGFnID0gdGFnCiAgICAgICAgc2VsZi5fbGFiZWxzID0gbGFiZWxzCiAgICAgICAgc2VsZi5fZXh0cmFfZGF0YSA9IGV4dHJhX2RhdGEgaWYgZXh0cmFfZGF0YSBpcyBub3QgTm9uZSBlbHNlIHt9CgogICAgICAgICMgU2V0IHVwIHRoZSBsb2dnaW5nIG1vZGU6CiAgICAgICAgc2VsZi5faXNfdHJhaW5pbmcgPSBGYWxzZQogICAgICAgIHNlbGYuX3N0ZXBzOiBMaXN0W0xpc3RbaW50XV0gPSBbXQogICAgICAgIHNlbGYuX21ldHJpY19zY29yZXM6IERpY3Rbc3RyLCBMaXN0W2Zsb2F0XV0gPSB7fQogICAgICAgIHNlbGYuX2FydGlmYWN0czogRGljdFtzdHIsIEFydGlmYWN0XSA9IHt9CgogICAgZGVmIG9uX2Vwb2NoX2JlZ2luKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICAqKmt3YXJncywKICAgICk6CiAgICAgICAgc2VsZi5fc3RlcHMuYXBwZW5kKFtdKQoKICAgIGRlZiBvbl9lcG9jaF9lbmQoCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9sb2dfbWV0cmljcygpCgogICAgZGVmIG9uX2xvZygKICAgICAgICBzZWxmLAogICAgICAgIGFyZ3M6IFRyYWluaW5nQXJndW1lbnRzLAogICAgICAgIHN0YXRlOiBUcmFpbmVyU3RhdGUsCiAgICAgICAgY29udHJvbDogVHJhaW5lckNvbnRyb2wsCiAgICAgICAgbG9nczogRGljdFtzdHIsIGZsb2F0XSA9IE5vbmUsCiAgICAgICAgKiprd2FyZ3MsCiAgICApOgogICAgICAgIHJlY2VudF9sb2dzID0gc3RhdGUubG9nX2hpc3RvcnlbLTFdLmNvcHkoKQoKICAgICAgICByZWNlbnRfbG9ncy5wb3AoImVwb2NoIikKICAgICAgICBjdXJyZW50X3N0ZXAgPSBpbnQocmVjZW50X2xvZ3MucG9wKCJzdGVwIikpCiAgICAgICAgaWYgY3VycmVudF9zdGVwIG5vdCBpbiBzZWxmLl9zdGVwc1stMV06CiAgICAgICAgICAgIHNlbGYuX3N0ZXBzWy0xXS5hcHBlbmQoY3VycmVudF9zdGVwKQoKICAgICAgICBmb3IgbWV0cmljX25hbWUsIG1ldHJpY19zY29yZSBpbiByZWNlbnRfbG9ncy5pdGVtcygpOgogICAgICAgICAgICBpZiBtZXRyaWNfbmFtZS5zdGFydHN3aXRoKCJ0cmFpbl8iKToKICAgICAgICAgICAgICAgIGlmIG1ldHJpY19uYW1lLnNwbGl0KCJ0cmFpbl8iKVsxXSBub3QgaW4gc2VsZi5fbWV0cmljX3Njb3JlczoKICAgICAgICAgICAgICAgICAgICBzZWxmLl9tZXRyaWNfc2NvcmVzW21ldHJpY19uYW1lXSA9IFttZXRyaWNfc2NvcmVdCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBpZiBtZXRyaWNfbmFtZSBub3QgaW4gc2VsZi5fbWV0cmljX3Njb3JlczoKICAgICAgICAgICAgICAgIHNlbGYuX21ldHJpY19zY29yZXNbbWV0cmljX25hbWVdID0gW10KICAgICAgICAgICAgc2VsZi5fbWV0cmljX3Njb3Jlc1ttZXRyaWNfbmFtZV0uYXBwZW5kKG1ldHJpY19zY29yZSkKCiAgICBkZWYgb25fdHJhaW5fYmVnaW4oCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9pc190cmFpbmluZyA9IFRydWUKCiAgICBkZWYgb25fdHJhaW5fZW5kKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICBtb2RlbDogUHJlVHJhaW5lZE1vZGVsID0gTm9uZSwKICAgICAgICB0b2tlbml6ZXI6IFByZVRyYWluZWRUb2tlbml6ZXIgPSBOb25lLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9sb2dfbWV0cmljcygpCgogICAgICAgIHRlbXBfZGlyZWN0b3J5ID0gdGVtcGZpbGUuZ2V0dGVtcGRpcigpCgogICAgICAgICMgU2F2ZSBhbmQgbG9nIHRoZSB0b2tlbml6ZXI6CiAgICAgICAgaWYgdG9rZW5pemVyIGlzIG5vdCBOb25lOgogICAgICAgICAgICAjIFNhdmUgdG9rZW5pemVyOgogICAgICAgICAgICB0b2tlbml6ZXJfZGlyID0gb3MucGF0aC5qb2luKHRlbXBfZGlyZWN0b3J5LCAidG9rZW5pemVyIikKICAgICAgICAgICAgdG9rZW5pemVyLnNhdmVfcHJldHJhaW5lZChzYXZlX2RpcmVjdG9yeT10b2tlbml6ZXJfZGlyKQogICAgICAgICAgICAjIFppcCB0aGUgdG9rZW5pemVyIGRpcmVjdG9yeToKICAgICAgICAgICAgdG9rZW5pemVyX3ppcCA9IHNodXRpbC5tYWtlX2FyY2hpdmUoCiAgICAgICAgICAgICAgICBiYXNlX25hbWU9InRva2VuaXplciIsCiAgICAgICAgICAgICAgICBmb3JtYXQ9InppcCIsCiAgICAgICAgICAgICAgICByb290X2Rpcj10b2tlbml6ZXJfZGlyLAogICAgICAgICAgICApCiAgICAgICAgICAgICMgTG9nIHRoZSB6aXAgZmlsZToKICAgICAgICAgICAgc2VsZi5fYXJ0aWZhY3RzWyJ0b2tlbml6ZXIiXSA9IHNlbGYuX2NvbnRleHQubG9nX2FydGlmYWN0KAogICAgICAgICAgICAgICAgaXRlbT0idG9rZW5pemVyIiwgbG9jYWxfcGF0aD10b2tlbml6ZXJfemlwCiAgICAgICAgICAgICkKCiAgICAgICAgIyBTYXZlIHRoZSBtb2RlbDoKICAgICAgICBtb2RlbF9kaXIgPSBvcy5wYXRoLmpvaW4odGVtcF9kaXJlY3RvcnksICJtb2RlbCIpCiAgICAgICAgbW9kZWwuc2F2ZV9wcmV0cmFpbmVkKHNhdmVfZGlyZWN0b3J5PW1vZGVsX2RpcikKCiAgICAgICAgIyBaaXAgdGhlIG1vZGVsIGRpcmVjdG9yeToKICAgICAgICBzaHV0aWwubWFrZV9hcmNoaXZlKAogICAgICAgICAgICBiYXNlX25hbWU9Im1vZGVsIiwKICAgICAgICAgICAgZm9ybWF0PSJ6aXAiLAogICAgICAgICAgICByb290X2Rpcj1tb2RlbF9kaXIsCiAgICAgICAgKQoKICAgICAgICAjIExvZyB0aGUgbW9kZWw6CiAgICAgICAgc2VsZi5fY29udGV4dC5sb2dfbW9kZWwoCiAgICAgICAgICAgIGtleT0ibW9kZWwiLAogICAgICAgICAgICBkYl9rZXk9c2VsZi5fbW9kZWxfbmFtZSwKICAgICAgICAgICAgbW9kZWxfZmlsZT0ibW9kZWwuemlwIiwKICAgICAgICAgICAgdGFnPXNlbGYuX3RhZywKICAgICAgICAgICAgZnJhbWV3b3JrPSJIdWdnaW5nIEZhY2UiLAogICAgICAgICAgICBsYWJlbHM9c2VsZi5fbGFiZWxzLAogICAgICAgICAgICBleHRyYV9kYXRhPXsqKnNlbGYuX2FydGlmYWN0cywgKipzZWxmLl9leHRyYV9kYXRhfSwKICAgICAgICApCgogICAgZGVmIG9uX2V2YWx1YXRlKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICAqKmt3YXJncywKICAgICk6CiAgICAgICAgc2VsZi5fbG9nX21ldHJpY3MoKQoKICAgICAgICBpZiBzZWxmLl9pc190cmFpbmluZzoKICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICMgVE9ETzogVXBkYXRlIHRoZSBtb2RlbCBvYmplY3QKCiAgICBkZWYgX2xvZ19tZXRyaWNzKHNlbGYpOgogICAgICAgIGZvciBtZXRyaWNfbmFtZSwgbWV0cmljX3Njb3JlcyBpbiBzZWxmLl9tZXRyaWNfc2NvcmVzLml0ZW1zKCk6CiAgICAgICAgICAgIHNlbGYuX2NvbnRleHQubG9nX3Jlc3VsdChrZXk9bWV0cmljX25hbWUsIHZhbHVlPW1ldHJpY19zY29yZXNbLTFdKQogICAgICAgICAgICBpZiBsZW4obWV0cmljX3Njb3JlcykgPiAxOgogICAgICAgICAgICAgICAgc2VsZi5fbG9nX21ldHJpY19wbG90KG5hbWU9bWV0cmljX25hbWUsIHNjb3Jlcz1tZXRyaWNfc2NvcmVzKQogICAgICAgIHNlbGYuX2NvbnRleHQuY29tbWl0KGNvbXBsZXRlZD1GYWxzZSkKCiAgICBkZWYgX2xvZ19tZXRyaWNfcGxvdChzZWxmLCBuYW1lOiBzdHIsIHNjb3JlczogTGlzdFtmbG9hdF0pOgogICAgICAgICMgSW5pdGlhbGl6ZSBhIHBsb3RseSBmaWd1cmU6CiAgICAgICAgbWV0cmljX2ZpZ3VyZSA9IGdvLkZpZ3VyZSgpCgogICAgICAgICMgQWRkIHRpdGxlczoKICAgICAgICBtZXRyaWNfZmlndXJlLnVwZGF0ZV9sYXlvdXQoCiAgICAgICAgICAgIHRpdGxlPW5hbWUuY2FwaXRhbGl6ZSgpLnJlcGxhY2UoIl8iLCAiICIpLAogICAgICAgICAgICB4YXhpc190aXRsZT0iU2FtcGxlcyIsCiAgICAgICAgICAgIHlheGlzX3RpdGxlPSJTY29yZXMiLAogICAgICAgICkKCiAgICAgICAgIyBEcmF3OgogICAgICAgIG1ldHJpY19maWd1cmUuYWRkX3RyYWNlKAogICAgICAgICAgICBnby5TY2F0dGVyKHg9bnAuYXJhbmdlKGxlbihzY29yZXMpKSwgeT1zY29yZXMsIG1vZGU9ImxpbmVzIikKICAgICAgICApCgogICAgICAgICMgQ3JlYXRlIHRoZSBwbG90bHkgYXJ0aWZhY3Q6CiAgICAgICAgYXJ0aWZhY3RfbmFtZSA9IGYie25hbWV9X3Bsb3QiCiAgICAgICAgYXJ0aWZhY3QgPSBQbG90bHlBcnRpZmFjdChrZXk9YXJ0aWZhY3RfbmFtZSwgZmlndXJlPW1ldHJpY19maWd1cmUpCiAgICAgICAgc2VsZi5fYXJ0aWZhY3RzW2FydGlmYWN0X25hbWVdID0gc2VsZi5fY29udGV4dC5sb2dfYXJ0aWZhY3QoYXJ0aWZhY3QpCgoKZGVmIGFwcGx5X21scnVuKAogICAgaHVnZ2luZ2ZhY2Vfb2JqZWN0OiB0cmFuc2Zvcm1lcnMuVHJhaW5lciwKICAgIG1vZGVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICB0YWc6IHN0ciA9ICIiLAogICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHggPSBOb25lLAogICAgYXV0b19sb2c6IGJvb2wgPSBUcnVlLAogICAgbGFiZWxzOiBEaWN0W3N0ciwgc3RyXSA9IE5vbmUsCiAgICBleHRyYV9kYXRhOiBkaWN0ID0gTm9uZSwKICAgICoqa3dhcmdzLAopOgogICAgIiIiCiAgICBXcmFwIHRoZSBnaXZlbiBtb2RlbCB3aXRoIE1MUnVuJ3MgaW50ZXJmYWNlIHByb3ZpZGluZyBpdCB3aXRoIG1scnVuJ3MgYWRkaXRpb25hbCBmZWF0dXJlcy4KICAgIDpwYXJhbSBodWdnaW5nZmFjZV9vYmplY3Q6IFRoZSBtb2RlbCB0byB3cmFwLiBDYW4gYmUgbG9hZGVkIGZyb20gdGhlIG1vZGVsIHBhdGggZ2l2ZW4gYXMgd2VsbC4KICAgIDpwYXJhbSBtb2RlbF9uYW1lOiAgICAgICAgIFRoZSBtb2RlbCBuYW1lIHRvIHVzZSBmb3Igc3RvcmluZyB0aGUgbW9kZWwgYXJ0aWZhY3QuIERlZmF1bHQ6ICJtb2RlbCIuCiAgICA6cGFyYW0gdGFnOiAgICAgICAgICAgICAgICBUaGUgbW9kZWwncyB0YWcgdG8gbG9nIHdpdGguCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICBNTFJ1biBjb250ZXh0IHRvIHdvcmsgd2l0aC4gSWYgbm8gY29udGV4dCBpcyBnaXZlbiBpdCB3aWxsIGJlIHJldHJpZXZlZCB2aWEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eChOb25lKScKICAgIDpwYXJhbSBhdXRvX2xvZzogICAgICAgICAgIFdoZXRoZXIgdG8gZW5hYmxlIE1MUnVuJ3MgYXV0byBsb2dnaW5nLiBEZWZhdWx0OiBUcnVlLgogICAgIiIiCiAgICBpZiBpc2luc3RhbmNlKGh1Z2dpbmdmYWNlX29iamVjdCwgdHJhbnNmb3JtZXJzLlRyYWluZXIpOgogICAgICAgIGlmIGNvbnRleHQgaXMgTm9uZToKICAgICAgICAgICAgY29udGV4dCA9IG1scnVuLmdldF9vcl9jcmVhdGVfY3R4KAogICAgICAgICAgICAgICAgSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UuREVGQVVMVF9DT05URVhUX05BTUUKICAgICAgICAgICAgKQoKICAgICAgICBIRlRyYWluZXJNTFJ1bkludGVyZmFjZS5hZGRfaW50ZXJmYWNlKG9iaj1odWdnaW5nZmFjZV9vYmplY3QpCgogICAgICAgIGlmIGF1dG9fbG9nOgogICAgICAgICAgICBodWdnaW5nZmFjZV9vYmplY3QuYWRkX2NhbGxiYWNrKAogICAgICAgICAgICAgICAgTUxSdW5DYWxsYmFjaygKICAgICAgICAgICAgICAgICAgICBjb250ZXh0PWNvbnRleHQsCiAgICAgICAgICAgICAgICAgICAgbW9kZWxfbmFtZT1tb2RlbF9uYW1lLAogICAgICAgICAgICAgICAgICAgIHRhZz10YWcsCiAgICAgICAgICAgICAgICAgICAgbGFiZWxzPWxhYmVscywKICAgICAgICAgICAgICAgICAgICBleHRyYV9kYXRhPWV4dHJhX2RhdGEsCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICkKICAgICAgICByZXR1cm4KICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1bkludmFsaWRBcmd1bWVudEVycm9yCgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGZyb20gYXV0b190cmFpbmVyLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgS1dBcmdzUHJlZml4ZXM6CiAgICBNT0RFTF9DTEFTUyA9ICJDTEFTU18iCiAgICBGSVQgPSAiRklUXyIKICAgIFRSQUlOID0gIlRSQUlOXyIKICAgIFBSRURJQ1QgPSAiUFJFRElDVF8iCgoKZGVmIF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KHNyYzogRGljdCwgcHJlZml4X2tleTogc3RyKSAtPiBEaWN0W3N0ciwgQW55XToKICAgICIiIgogICAgQ29sbGVjdCBhbGwgdGhlIGtleXMgZnJvbSB0aGUgZ2l2ZW4gZGljdCB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwcmVmaXggYW5kIGNyZWF0ZXMgYSBuZXcgZGljdGlvbmFyeSB3aXRoIHRoZXNlCiAgICBrZXlzLgoKICAgIDpwYXJhbSBzcmM6ICAgICAgICAgVGhlIHNvdXJjZSBkaWN0IHRvIGV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tLgogICAgOnBhcmFtIHByZWZpeF9rZXk6ICBPbmx5IGtleXMgd2l0aCB0aGlzIHByZWZpeCB3aWxsIGJlIHJldHVybmVkLiBUaGUga2V5cyBpbiB0aGUgcmVzdWx0IGRpY3Qgd2lsbCBiZSB3aXRob3V0IHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4LgogICAgIiIiCiAgICByZXR1cm4gewogICAgICAgIGtleS5yZXBsYWNlKHByZWZpeF9rZXksICIiKTogdmFsCiAgICAgICAgZm9yIGtleSwgdmFsIGluIHNyYy5pdGVtcygpCiAgICAgICAgaWYga2V5LnN0YXJ0c3dpdGgocHJlZml4X2tleSkKICAgIH0KCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSHVnZ2luZyBGYWNlIFRyYWluZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpkZWYgX2NyZWF0ZV9jb21wdXRlX21ldHJpY3MobWV0cmljczogTGlzdFtzdHJdKToKICAgIGRlZiBfY29tcHV0ZV9tZXRyaWNzKGV2YWxfcHJlZCk6CiAgICAgICAgbG9naXRzLCBsYWJlbHMgPSBldmFsX3ByZWQKICAgICAgICBwcmVkaWN0aW9ucyA9IG5wLmFyZ21heChsb2dpdHMsIGF4aXM9LTEpCiAgICAgICAgbWV0cmljX2RpY3RfcmVzdWx0cyA9IHt9CiAgICAgICAgZm9yIG1ldHJpYyBpbiBtZXRyaWNzOgogICAgICAgICAgICBsb2FkX21ldCA9IGxvYWRfbWV0cmljKG1ldHJpYykKICAgICAgICAgICAgbWV0cmljX3JlcyA9IGxvYWRfbWV0LmNvbXB1dGUocHJlZGljdGlvbnM9cHJlZGljdGlvbnMsIHJlZmVyZW5jZXM9bGFiZWxzKVsKICAgICAgICAgICAgICAgIG1ldHJpYwogICAgICAgICAgICBdCiAgICAgICAgICAgIG1ldHJpY19kaWN0X3Jlc3VsdHNbbWV0cmljXSA9IG1ldHJpY19yZXMKCiAgICAgICAgcmV0dXJuIG1ldHJpY19kaWN0X3Jlc3VsdHMKCiAgICByZXR1cm4gX2NvbXB1dGVfbWV0cmljcwoKCmRlZiB0cmFpbigKICAgIGNvbnRleHQ6IE1MQ2xpZW50Q3R4LAogICAgZGF0YXNldF9uYW1lOiBzdHIgPSBOb25lLAogICAgZHJvcF9jb2x1bW5zOiBPcHRpb25hbFtMaXN0W3N0cl1dID0gTm9uZSwKICAgIHByZXRyYWluZWRfdG9rZW5pemVyOiBzdHIgPSBOb25lLAogICAgcHJldHJhaW5lZF9tb2RlbDogc3RyID0gTm9uZSwKICAgIG1vZGVsX2NsYXNzOiBzdHIgPSBOb25lLAogICAgbW9kZWxfbmFtZTogc3RyID0gImh1Z2dpbmdmYWNlX21vZGVsIiwKICAgIGxhYmVsX25hbWU6IHN0ciA9ICJsYWJlbHMiLAogICAgdGV4dF9jb2w6IHN0ciA9ICJ0ZXh0IiwKICAgIG51bV9vZl90cmFpbl9zYW1wbGVzOiBpbnQgPSBOb25lLAogICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplOiBmbG9hdCA9IE5vbmUsCiAgICBtZXRyaWNzOiBMaXN0W3N0cl0gPSBOb25lLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSBOb25lLAopOgogICAgIiIiCiAgICBUcmFpbmluZyBhbmQgZXZhbHVhdGluZyBhIHByZXRyYWluZWQgbW9kZWwgd2l0aCBhIHByZXRyYWluZWQgdG9rZW5pemVyIG92ZXIgYSBkYXRhc2V0LgoKICAgIDpwYXJhbSBudW1fb2ZfdHJhaW5fc2FtcGxlczoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgICAgICAgTUxSdW4gY29udGV4dAogICAgOnBhcmFtIGRhdGFzZXRfbmFtZTogICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byBnZXQgZnJvbSB0aGUgSHVnZ2luZ0ZhY2UgaHViCiAgICA6cGFyYW0gZHJvcF9jb2x1bW5zOiAgICAgICAgICAgIFRoZSBjb2x1bW5zIHRvIGRyb3AgZnJvbSB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSBwcmV0cmFpbmVkX3Rva2VuaXplcjogICAgVGhlIG5hbWUgb2YgdGhlIHByZXRyYWluZWQgdG9rZW5pemVyIGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1Yi4KICAgIDpwYXJhbSBwcmV0cmFpbmVkX21vZGVsOiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHByZXRyYWluZWQgbW9kZWwgZnJvbSB0aGUgSHVnZ2luZ0ZhY2UgaHViLgogICAgOnBhcmFtIG1vZGVsX25hbWU6ICAgICAgICAgICAgICBUaGUgbW9kZWwncyBuYW1lIHRvIHVzZSBmb3Igc3RvcmluZyB0aGUgbW9kZWwgYXJ0aWZhY3QsIGRlZmF1bHQgdG8gJ21vZGVsJwogICAgOnBhcmFtIG1vZGVsX2NsYXNzOiAgICAgICAgICAgICBUaGUgY2xhc3Mgb2YgdGhlIG1vZGVsLCBlLmcuIGB0cmFuc2Zvcm1lcnMuQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbmAKICAgIDpwYXJhbSB0cmFpbl90ZXN0X3NwbGl0X3NpemU6ICAgU2hvdWxkIGJlIGJldHdlZW4gMC4wIGFuZCAxLjAgYW5kIHJlcHJlc2VudCB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgZGF0YXNldCB0byBpbmNsdWRlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSB0ZXN0IHNwbGl0LiBUaGUgc2l6ZSBvZiB0aGUgVHJhaW5pbmcgc2V0IGlzIHNldCB0byB0aGUgY29tcGxlbWVudCBvZiB0aGlzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLiBEZWZhdWx0ID0gMC4yCiAgICA6cGFyYW0gbGFiZWxfbmFtZXM6ICAgICAgICAgICAgIFRoZSB0YXJnZXQgbGFiZWwocykgb2YgdGhlIGNvbHVtbihzKSBpbiB0aGUgZGF0YXNldC4gZm9yIFJlZ3Jlc3Npb24gb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3NpZmljYXRpb24gdGFza3MKICAgIDpwYXJhbSBtZXRyaWNzOiAgICAgICAgICAgICAgICAgPz8/CiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICAgICAgIFJhbmRvbSBzdGF0ZSBmb3IgYHRyYWluX3Rlc3Rfc3BsaXRgCiAgICAiIiIKCiAgICBpZiBub3QgbGFiZWxfbmFtZSBvciBub3QgcHJldHJhaW5lZF90b2tlbml6ZXI6CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuUnVudGltZUVycm9yKAogICAgICAgICAgICAiTXVzdCBwcm92aWRlIGxhYmVsX25hbWVzIGFuZCBwcmV0cmFpbmVkX3Rva2VuaXplciIKICAgICAgICApCgogICAgaWYgdHJhaW5fdGVzdF9zcGxpdF9zaXplIGlzIE5vbmU6CiAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbygKICAgICAgICAgICAgInRlc3Rfc2V0IG9yIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSBhcmUgbm90IHByb3ZpZGVkLCBzZXR0aW5nIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSB0byAwLjIiCiAgICAgICAgKQogICAgICAgIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSA9IDAuMgoKICAgICMgQ3JlYXRpbmcgdG9rZW5pemVyOgogICAgdG9rZW5pemVyID0gQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF90b2tlbml6ZXIpCgogICAgZGVmIHByZXByb2Nlc3NfZnVuY3Rpb24oZXhhbXBsZXMpOgogICAgICAgIHJldHVybiB0b2tlbml6ZXIoZXhhbXBsZXNbdGV4dF9jb2xdLCB0cnVuY2F0aW9uPVRydWUpCgogICAgIyBwcmVwYXJlIGRhdGEgZm9yIHRyYWluaW5nCiAgICB0cmFpbl9kYXRhc2V0LCB0ZXN0X2RhdGFzZXQgPSBwcmVwYXJlX2RhdGFzZXQoCiAgICAgICAgY29udGV4dCwKICAgICAgICBkYXRhc2V0X25hbWUsCiAgICAgICAgbGFiZWxfbmFtZSwKICAgICAgICBkcm9wX2NvbHVtbnMsCiAgICAgICAgbnVtX29mX3RyYWluX3NhbXBsZXMsCiAgICAgICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplLAogICAgICAgIHRvX3BhbmRhcz1GYWxzZSwKICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlLAogICAgKQoKICAgICMgTWFwcGluZyBkYXRhc2V0cyB3aXRoIHRoZSB0b2tlbml6ZXI6CiAgICB0b2tlbml6ZWRfdHJhaW4gPSB0cmFpbl9kYXRhc2V0Lm1hcChwcmVwcm9jZXNzX2Z1bmN0aW9uLCBiYXRjaGVkPVRydWUpCiAgICB0b2tlbml6ZWRfdGVzdCA9IHRlc3RfZGF0YXNldC5tYXAocHJlcHJvY2Vzc19mdW5jdGlvbiwgYmF0Y2hlZD1UcnVlKQoKICAgICMgQ3JlYXRpbmcgZGF0YSBjb2xsYXRvciBmb3IgYmF0Y2hpbmc6CiAgICBkYXRhX2NvbGxhdG9yID0gRGF0YUNvbGxhdG9yV2l0aFBhZGRpbmcodG9rZW5pemVyPXRva2VuaXplcikKCiAgICAjIFBhcnNpbmcga3dhcmdzOgogICAgdHJhaW5fa3dhcmdzID0gX2dldF9zdWJfZGljdF9ieV9wcmVmaXgoCiAgICAgICAgc3JjPWNvbnRleHQucGFyYW1ldGVycywgcHJlZml4X2tleT1LV0FyZ3NQcmVmaXhlcy5UUkFJTgogICAgKQogICAgbW9kZWxfY2xhc3Nfa3dhcmdzID0gX2dldF9zdWJfZGljdF9ieV9wcmVmaXgoCiAgICAgICAgc3JjPWNvbnRleHQucGFyYW1ldGVycywgcHJlZml4X2tleT1LV0FyZ3NQcmVmaXhlcy5NT0RFTF9DTEFTUwogICAgKQoKICAgICMgTG9hZGluZyBvdXIgcHJldHJhaW5lZCBtb2RlbDoKICAgIG1vZGVsX2NsYXNzX2t3YXJnc1sicHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgiXSA9ICgKICAgICAgICBtb2RlbF9jbGFzc19rd2FyZ3MuZ2V0KCJwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCIpIG9yIHByZXRyYWluZWRfbW9kZWwKICAgICkKICAgIGlmIG5vdCBtb2RlbF9jbGFzc19rd2FyZ3NbInByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIl06CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuUnVudGltZUVycm9yKAogICAgICAgICAgICAiTXVzdCBwcm92aWRlIHByZXRyYWluZWRfbW9kZWwgbmFtZSBhcyAiCiAgICAgICAgICAgICJmdW5jdGlvbiBhcmd1bWVudCBvciBpbiBleHRyYSBwYXJhbXMiCiAgICAgICAgKQogICAgbW9kZWwgPSBjcmVhdGVfY2xhc3MobW9kZWxfY2xhc3MpLmZyb21fcHJldHJhaW5lZCgqKm1vZGVsX2NsYXNzX2t3YXJncykKCiAgICAjIFByZXBhcmluZyB0cmFpbmluZyBhcmd1bWVudHM6CiAgICB0cmFpbmluZ19hcmdzID0gVHJhaW5pbmdBcmd1bWVudHMoCiAgICAgICAgKip0cmFpbl9rd2FyZ3MsCiAgICApCgogICAgY29tcHV0ZV9tZXRyaWNzID0gX2NyZWF0ZV9jb21wdXRlX21ldHJpY3MobWV0cmljcykgaWYgbWV0cmljcyBlbHNlIE5vbmUKICAgIHRyYWluZXIgPSBUcmFpbmVyKAogICAgICAgIG1vZGVsPW1vZGVsLAogICAgICAgIGFyZ3M9dHJhaW5pbmdfYXJncywKICAgICAgICB0cmFpbl9kYXRhc2V0PXRva2VuaXplZF90cmFpbiwKICAgICAgICBldmFsX2RhdGFzZXQ9dG9rZW5pemVkX3Rlc3QsCiAgICAgICAgdG9rZW5pemVyPXRva2VuaXplciwKICAgICAgICBkYXRhX2NvbGxhdG9yPWRhdGFfY29sbGF0b3IsCiAgICAgICAgY29tcHV0ZV9tZXRyaWNzPWNvbXB1dGVfbWV0cmljcywKICAgICkKCiAgICBhcHBseV9tbHJ1bih0cmFpbmVyLCBtb2RlbF9uYW1lPW1vZGVsX25hbWUpCgogICAgIyBBcHBseSB0cmFpbmluZyB3aXRoIGV2YWx1YXRpb246CiAgICBjb250ZXh0LmxvZ2dlci5pbmZvKGYidHJhaW5pbmcgJ3ttb2RlbF9uYW1lfSciKQogICAgdHJhaW5lci50cmFpbigpCgoKZGVmIF9lZGl0X2NvbHVtbnMoCiAgICBkYXRhc2V0OiBEYXRhc2V0LAogICAgZHJvcF9jb2x1bW5zOiBMaXN0W3N0cl0gPSBOb25lLAogICAgcmVuYW1lX2NvbHVtbnM6IFtzdHIsIHN0cl0gPSBOb25lLAopOgogICAgaWYgZHJvcF9jb2x1bW5zOgogICAgICAgIGRhdGFzZXQgPSBkYXRhc2V0LnJlbW92ZV9jb2x1bW5zKGRyb3BfY29sdW1ucykKICAgIGlmIHJlbmFtZV9jb2x1bW5zOgogICAgICAgIGRhdGFzZXQgPSBkYXRhc2V0LnJlbmFtZV9jb2x1bW5zKHJlbmFtZV9jb2x1bW5zKQogICAgcmV0dXJuIGRhdGFzZXQKCgpkZWYgcHJlcGFyZV9kYXRhc2V0KAogICAgY29udGV4dDogTUxDbGllbnRDdHgsCiAgICBkYXRhc2V0X25hbWU6IHN0ciwKICAgIGxhYmVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICBkcm9wX2NvbHVtbnM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lLAogICAgbnVtX29mX3RyYWluX3NhbXBsZXM6IGludCA9IE5vbmUsCiAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemU6IGZsb2F0ID0gMC4yLAogICAgdG9fcGFuZGFzOiBib29sID0gVHJ1ZSwKICAgIHJhbmRvbV9zdGF0ZTogaW50ID0gTm9uZSwKKToKICAgICIiIgogICAgTG9hZGluZyB0aGUgZGF0YXNldCBhbmQgZWRpdGluZyB0aGUgY29sdW1ucwoKICAgIDpwYXJhbSBsYWJlbF9uYW1lOgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICAgICAgICBNTFJ1biBjb250ZXh0CiAgICA6cGFyYW0gdG9fcGFuZGFzOgogICAgOnBhcmFtIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZToKICAgIDpwYXJhbSBudW1fb2ZfdHJhaW5fc2FtcGxlczoKICAgIDpwYXJhbSBkYXRhc2V0X25hbWU6ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZ2V0IGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1YgogICAgOnBhcmFtIGRyb3BfY29sdW1uczogICAgICAgICAgICBUaGUgY29sdW1ucyB0byBkcm9wIGZyb20gdGhlIGRhdGFzZXQuCiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICAgICAgIFJhbmRvbSBzdGF0ZSBmb3IgYHRyYWluX3Rlc3Rfc3BsaXRgCgogICAgIiIiCgogICAgY29udGV4dC5sb2dnZXIuaW5mbygKICAgICAgICBmIkxvYWRpbmcgYW5kIGVkaXRpbmcge2RhdGFzZXRfbmFtZX0gZGF0YXNldCBmcm9tIEh1Z2dpbmcgRmFjZSBodWIiCiAgICApCiAgICByZW5hbWVfY29scyA9IHtsYWJlbF9uYW1lOiAibGFiZWxzIn0KCiAgICAjIExvYWRpbmcgYW5kIGVkaXRpbmcgZGF0YXNldDoKICAgIGRhdGFzZXQgPSBsb2FkX2RhdGFzZXQoZGF0YXNldF9uYW1lKQoKICAgICMgdHJhaW4gc2V0CiAgICB0cmFpbl9kYXRhc2V0ID0gZGF0YXNldFsidHJhaW4iXQogICAgaWYgbnVtX29mX3RyYWluX3NhbXBsZXM6CiAgICAgICAgdHJhaW5fZGF0YXNldCA9IHRyYWluX2RhdGFzZXQuc2h1ZmZsZShzZWVkPXJhbmRvbV9zdGF0ZSkuc2VsZWN0KAogICAgICAgICAgICBsaXN0KHJhbmdlKG51bV9vZl90cmFpbl9zYW1wbGVzKSkKICAgICAgICApCiAgICB0cmFpbl9kYXRhc2V0ID0gX2VkaXRfY29sdW1ucyh0cmFpbl9kYXRhc2V0LCBkcm9wX2NvbHVtbnMsIHJlbmFtZV9jb2xzKQoKICAgICMgdGVzdCBzZXQKICAgIG51bV9vZl90ZXN0X3NhbXBsZXMgPSBpbnQoCiAgICAgICAgKHRyYWluX2RhdGFzZXQubnVtX3Jvd3MgKiB0cmFpbl90ZXN0X3NwbGl0X3NpemUpIC8vICgxIC0gdHJhaW5fdGVzdF9zcGxpdF9zaXplKQogICAgKQogICAgdGVzdF9kYXRhc2V0ID0gKAogICAgICAgIGRhdGFzZXRbInRlc3QiXQogICAgICAgIC5zaHVmZmxlKHNlZWQ9cmFuZG9tX3N0YXRlKQogICAgICAgIC5zZWxlY3QobGlzdChyYW5nZShudW1fb2ZfdGVzdF9zYW1wbGVzKSkpCiAgICApCiAgICB0ZXN0X2RhdGFzZXQgPSBfZWRpdF9jb2x1bW5zKHRlc3RfZGF0YXNldCwgZHJvcF9jb2x1bW5zLCByZW5hbWVfY29scykKCiAgICBpZiB0b19wYW5kYXM6CiAgICAgICAgcmV0dXJuIHRyYWluX2RhdGFzZXQudG9fcGFuZGFzKCksIHRlc3RfZGF0YXNldC50b19wYW5kYXMoKQogICAgcmV0dXJuIHRyYWluX2RhdGFzZXQsIHRlc3RfZGF0YXNldAo=
    commands:
    - python -m pip install transformers datasets plotly
    code_origin: https://github.com/davesh0812/functions.git#896b005b16e7b6660650a9b5645a2853b93141d7:/Users/davids/Projects/functions/hugging_face_classifier_trainer/hugging_face_classifier_trainer.py
    origin_filename: /Users/davids/Projects/functions/hugging_face_classifier_trainer/hugging_face_classifier_trainer.py
  entry_points:
    add_interface:
      name: add_interface
      doc: 'Enrich the object with this interface properties, methods and functions,
        so it will have this TensorFlow.Keras

        MLRuns features.'
      parameters:
      - name: cls
        default: ''
      - name: obj
        type: Trainer
        doc: The object to enrich his interface.
        default: ''
      - name: restoration
        type: MLRunInterfaceRestorationType
        doc: Restoration information tuple as returned from 'remove_interface' in
          order to add the interface in a certain state.
        default: null
      outputs:
      - default: ''
      lineno: 46
    mlrun_train:
      name: mlrun_train
      doc: 'MLRuns tf.keras.Model.fit wrapper. It will setup the optimizer when using
        horovod. The optimizer must be

        passed in a keyword argument and when using horovod, it must be passed as
        an Optimizer instance, not a string.


        raise MLRunInvalidArgumentError: In case the optimizer provided did not follow
        the instructions above.'
      parameters:
      - name: cls
        default: ''
      outputs:
      - default: ''
      lineno: 64
    wrapper:
      name: wrapper
      doc: ''
      parameters:
      - name: self
        type: Trainer
        default: ''
      outputs:
      - default: ''
      lineno: 74
    on_epoch_begin:
      name: on_epoch_begin
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 121
    on_epoch_end:
      name: on_epoch_end
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 130
    on_log:
      name: on_log
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      - name: logs
        type: Dict[str, float]
        default: null
      outputs:
      - default: ''
      lineno: 139
    on_train_begin:
      name: on_train_begin
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 163
    on_train_end:
      name: on_train_end
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      - name: model
        type: PreTrainedModel
        default: null
      - name: tokenizer
        type: PreTrainedTokenizer
        default: null
      outputs:
      - default: ''
      lineno: 172
    on_evaluate:
      name: on_evaluate
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 223
    apply_mlrun:
      name: apply_mlrun
      doc: Wrap the given model with MLRun's interface providing it with mlrun's additional
        features.
      parameters:
      - name: huggingface_object
        type: Trainer
        doc: The model to wrap. Can be loaded from the model path given as well.
        default: ''
      - name: model_name
        type: str
        doc: 'The model name to use for storing the model artifact. Default: "model".'
        default: null
      - name: tag
        type: str
        doc: The model's tag to log with.
        default: ''
      - name: context
        type: MLClientCtx
        doc: MLRun context to work with. If no context is given it will be retrieved
          via 'mlrun.get_or_create_ctx(None)'
        default: null
      - name: auto_log
        type: bool
        doc: 'Whether to enable MLRun''s auto logging. Default: True.'
        default: true
      - name: labels
        type: Dict[str, str]
        default: null
      - name: extra_data
        type: dict
        default: null
      outputs:
      - default: ''
      lineno: 266
    train:
      name: train
      doc: Training and evaluating a pretrained model with a pretrained tokenizer
        over a dataset.
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context
        default: ''
      - name: dataset_name
        type: str
        doc: The name of the dataset to get from the HuggingFace hub
        default: null
      - name: drop_columns
        type: Optional[List[str]]
        doc: The columns to drop from the dataset.
        default: null
      - name: pretrained_tokenizer
        type: str
        doc: The name of the pretrained tokenizer from the HuggingFace hub.
        default: null
      - name: pretrained_model
        type: str
        doc: The name of the pretrained model from the HuggingFace hub.
        default: null
      - name: model_class
        type: str
        doc: The class of the model, e.g. `transformers.AutoModelForSequenceClassification`
        default: null
      - name: model_name
        type: str
        doc: The model's name to use for storing the model artifact, default to 'model'
        default: huggingface_model
      - name: label_name
        type: str
        default: labels
      - name: text_col
        type: str
        default: text
      - name: num_of_train_samples
        type: int
        default: null
      - name: train_test_split_size
        type: float
        doc: Should be between 0.0 and 1.0 and represent the proportion of the dataset
          to include in the test split. The size of the Training set is set to the
          complement of this value. Default = 0.2
        default: null
      - name: metrics
        type: List[str]
        doc: ???
        default: null
      - name: random_state
        type: int
        doc: Random state for `train_test_split`
        default: null
      outputs:
      - default: ''
      lineno: 351
    preprocess_function:
      name: preprocess_function
      doc: ''
      parameters:
      - name: examples
        default: ''
      outputs:
      - default: ''
      lineno: 400
    prepare_dataset:
      name: prepare_dataset
      doc: Loading the dataset and editing the columns
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context
        default: ''
      - name: dataset_name
        type: str
        doc: The name of the dataset to get from the HuggingFace hub
        default: ''
      - name: label_name
        type: str
        default: null
      - name: drop_columns
        type: Optional[List[str]]
        doc: The columns to drop from the dataset.
        default: null
      - name: num_of_train_samples
        type: int
        default: null
      - name: train_test_split_size
        type: float
        default: 0.2
      - name: to_pandas
        type: bool
        default: true
      - name: random_state
        type: int
        doc: Random state for `train_test_split`
        default: null
      outputs:
      - default: ''
      lineno: 476
  description: Automatic train, evaluate and predict functions for the ML frameworks
    - Scikit-Learn, XGBoost and LightGBM.
  default_handler: train
  disable_auto_mount: false
  env: []
  priority_class_name: ''
  preemption_mode: prevent
  affinity: null
  tolerations: null
  security_context: {}
verbose: false
