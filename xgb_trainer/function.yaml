kind: job
metadata:
  name: xgb-trainer
  tag: latest
  hash: aa3262072de9529a55826699a2a0697e448221e0
  project: ''
  labels:
    author: yjb
  categories:
  - models
  - classifier
spec:
  command: ''
  args: []
  image: mlrun/ml-models:0.4.6
  env: []
  default_handler: train_model
  entry_points:
    gen_xgb_model:
      name: gen_xgb_model
      doc: 'generate an xgboost model


        Multiple model types that can be estimated using

        the XGBoost Scikit-Learn API'
      parameters:
      - name: model_type
        type: str
        doc: one of "classifier", "regressor", "ranker", "rf_classifier", or "rf_regressor"
      - name: xgb_params
        type: dict
        doc: parameters passed through the  function execution context
      outputs: []
      lineno: 6
    get_sample:
      name: get_sample
      doc: "generate data sample to be split (candidate for mlrun)\n \nReturns features\
        \ matrix and header (x), and labels (y)"
      parameters:
      - name: src
        type: str
        doc: full path and filename of data artifact
      - name: sample
        type: int
        doc: sample size from data source, use negative  integers to sample randomly,
          positive to sample consecutively from the first row
      - name: label
        type: str
        doc: label column title
      - name: reader
        doc: pandas type reader (read_csv, read_parquet, ...) returning a pandas dataframe,
          and with a `dropna` attribute
      outputs: []
      lineno: 44
    get_splits:
      name: get_splits
      doc: 'generate train and test sets (candidate for mlrun)


        cross validation:

        1. cut out a test set

        2a. use the training set in a cross validation scheme, or

        2b. make another split to generate a validation set


        2 parts (n_ways=2): train and test set only

        3 parts (n_ways=3): train, validation and test set

        4 parts (n_ways=4): n_ways=3 + a held-out probability calibration set'
      parameters:
      - name: raw
        doc: dataframe or numpy array of raw features
      - name: labels
        doc: dataframe or numpy array of raw labels
      - name: n_ways
        type: int
        doc: (3) split data into 2, 3, or 4 parts
        default: 3
      - name: test_size
        type: float
        doc: proportion of raw data to set asid as test data
        default: 0.15
      - name: valid_size
        type: float
        doc: proportion of remaining data to be set as validation
        default: 0.3
      - name: label_names
        type: list
        doc: label names
        default:
        - labels
      - name: random_state
        type: int
        doc: (1) random number seed
        default: 1
      outputs: []
      lineno: 77
    save_test_set:
      name: save_test_set
      doc: log a held out test set
      parameters:
      - name: context
        doc: the function execution context
      - name: xtest
        doc: test features, as np.ndarray output from `get_splits`
      - name: ytest
        doc: test labels, as np.ndarray output from `get_splits`
      - name: header
        type: list
        doc: ([])features header if required
      - name: label
        type: str
        doc: ("labels") name of label column
        default: labels
      - name: file_ext
        type: str
        doc: format of test set file
        default: parquet
      - name: index
        type: bool
        doc: preserve index column
      - name: debug
        type: bool
        doc: (False)
      outputs: []
      lineno: 137
    dump_xgb_model:
      name: dump_xgb_model
      doc: 'serialize/log model


        XGBoost model can be save in 3 different ways:

        1. pickle the internal _booster object, inside the model

        2. using model.save_model("fn.bin") using a legacy binary xgb format

        2. using model.save_model("fn.json") using a portable json format'
      parameters:
      - name: context
        doc: the function"s execution context
      - name: model
        doc: the fitted xgboost model
      - name: dump_type
        type: str
        doc: '"pickle" legacy", or "json", '
      - name: dest_folder
        type: str
        doc: 'path for serialized model '
      - name: dest_name
        type: str
        doc: name for serialized model file
      outputs: []
      lineno: 171
    plot_confusion_matrix:
      name: plot_confusion_matrix
      doc: prints and plots the confusion matrix.
      parameters:
      - name: labels
      - name: predictions
      - name: classes
      - name: normalize
        default: all
      - name: title
        default: Confusion matrix
      - name: cmap
      outputs: []
      lineno: 206
    plot_roc:
      name: plot_roc
      doc: "plot roc curves\n\nTODO:  add averaging method (as string) that was used\
        \ to create probs, \ndisplay in legend"
      parameters:
      - name: context
        doc: the function context
      - name: y_labels
        doc: 'ground truth labels, hot encoded for multiclass  '
      - name: y_probs
        doc: model prediction probabilities
      - name: fpr_label
        type: str
        doc: ("false positive rate") x-axis labels
        default: false positive rate
      - name: tpr_label
        type: str
        doc: ("true positive rate") y-axis labels
        default: true positive rate
      - name: title
        type: str
        doc: ("roc curve") title of plot
        default: roc curve
      - name: legend_loc
        type: str
        doc: ("best") location of plot legend
        default: best
      outputs: []
      lineno: 244
    gen_proba:
      name: gen_proba
      doc: generate predictions and validation stats
      parameters:
      - name: context
        doc: the function execution context
      - name: feats
        doc: 'validation features array '
      - name: labels
        doc: validation ground-truth labels
      - name: model
        doc: estimated model
      - name: score_method
      - name: plots_dest
        doc: destination folder for plot artifacts
      - name: ntree_limit
        doc: (None) limit no. trees used in prediction
      - name: validate_features
        doc: (True) ensure consistent feature names  between model and input data
        default: true
      - name: base_margin
        doc: (None) undefined
      outputs: []
      lineno: 299
    proba_calibration:
      name: proba_calibration
      doc: 'calibrate output probabilities


        adapted from https://scikit-learn.org/stable/auto_examples/calibration/plot_calibration_curve.html#sphx-glr-auto-examples-calibration-plot-calibration-curve-py'
      parameters:
      - name: model
      - name: xcal
      - name: ycal
      outputs: []
      lineno: 351
    plot_calibration_curve:
      name: plot_calibration_curve
      doc: Plot calibration curve for est w/o and with calibration.
      parameters:
      - name: name
      - name: fig_index
      outputs: []
      lineno: 362
    train_model:
      name: train_model
      doc: train an xgboost model.
      parameters:
      - name: context
        doc: the function context
      - name: model_type
        type: str
        doc: the model type to train, 'classifier', 'regressor'...
      - name: dataset
        doc: ("data") name of raw data file
      - name: label_column
        type: str
        doc: ground-truth (y) labels
        default: labels
      - name: sample
        type: int
        doc: Selects the first n rows, or select a sample starting from the first.
          If negative <-1, select a random sample
        default: <_ast.USub object at 0x7f881e6ccd30>
      - name: test_size
        type: float
        doc: (0.05) test set size
        default: 0.05
      - name: valid_size
        type: float
        doc: (0.75) Once the test set has been removed the training set gets this
          proportion.
        default: 0.75
      - name: random_state
        type: int
        doc: (1) sklearn rng seed
        default: 1
      - name: model_filename
        type: str
        doc: model file filename, points to a directory
        default: model
      - name: models_dest
        type: str
        doc: models subfolder on artifact path
      - name: plots_dest
        type: str
        doc: plot subfolder on artifact path
      - name: score_method
        type: str
        doc: for multiclass classification
        default: micro
      - name: file_ext
        type: str
        doc: format for test_set_key hold out data
        default: parquet
      - name: model_pkg_file
        type: str
        doc: json model config file
      outputs: []
      lineno: 417
  description: train any classifier using scikit-learn's API
  build:
    functionSourceCode: IyBHZW5lcmF0ZWQgYnkgbnVjbGlvLmV4cG9ydC5OdWNsaW9FeHBvcnRlciBvbiAyMDIwLTA0LTI3IDIzOjQzCgppbXBvcnQgd2FybmluZ3MKd2FybmluZ3Muc2ltcGxlZmlsdGVyKGFjdGlvbj0iaWdub3JlIiwgY2F0ZWdvcnk9RnV0dXJlV2FybmluZykKCmRlZiBnZW5feGdiX21vZGVsKG1vZGVsX3R5cGU6IHN0ciwgeGdiX3BhcmFtczogZGljdCk6CiAgICAiIiJnZW5lcmF0ZSBhbiB4Z2Jvb3N0IG1vZGVsCiAgICAKICAgIE11bHRpcGxlIG1vZGVsIHR5cGVzIHRoYXQgY2FuIGJlIGVzdGltYXRlZCB1c2luZwogICAgdGhlIFhHQm9vc3QgU2Npa2l0LUxlYXJuIEFQSQogICAgCiAgICA6cGFyYW0gbW9kZWxfdHlwZTogb25lIG9mICJjbGFzc2lmaWVyIiwgInJlZ3Jlc3NvciIsCiAgICAgICAgICAgICAgICAgICAgICAgInJhbmtlciIsICJyZl9jbGFzc2lmaWVyIiwgb3IKICAgICAgICAgICAgICAgICAgICAgICJyZl9yZWdyZXNzb3IiCiAgICA6cGFyYW0geGdiX3BhcmFtczogcGFyYW1ldGVycyBwYXNzZWQgdGhyb3VnaCB0aGUgCiAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgICIiIgogICAgZnJvbSBqc29uIGltcG9ydCBsb2FkCiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdldF9jbGFzc19maXQsIGNyZWF0ZV9jbGFzcwoKICAgIG10eXBlcyA9IHsKICAgICAgICAiY2xhc3NpZmllciIgICA6ICJ4Z2Jvb3N0LlhHQkNsYXNzaWZpZXIiLAogICAgICAgICJyZWdyZXNzb3IiICAgIDogInhnYm9vc3QuWEdCUmVncmVzc29yIiwKICAgICAgICAicmFua2VyIiAgICAgICA6ICJ4Z2Jvb3N0LlhHQkNsYXNzaWZpZXIiLAogICAgICAgICJyZl9jbGFzc2lmaWVyIjogInhnYm9vc3QuWEdCUkZDbGFzc2lmaWVyIiwKICAgICAgICAicmZfcmVncmVzc29yIiA6ICJ4Z2Jvb3N0LlhHQlJGUmVncmVzc29yIgogICAgfQogICAgaWYgbW9kZWxfdHlwZSBub3QgaW4gbXR5cGVzLmtleXMoKToKICAgICAgICByYWlzZSBFeGNlcHRpb24oInVucmVjb2duaXplZCBtb2RlbCB0eXBlcywgc2VlIGhlbHAgZG9jdW1lbnRhdGlvbiIpCiAgICAKICAgIG1vZGVsX2NvbmZpZyA9IGdldF9jbGFzc19maXQobXR5cGVzW21vZGVsX3R5cGVdKQoKICAgIGZvciBrLCB2IGluIHhnYl9wYXJhbXM6CiAgICAgICAgaWYgay5zdGFydHN3aXRoKCJDTEFTU18iKToKICAgICAgICAgICAgbW9kZWxfY29uZmlnWyJDTEFTUyJdW2tbNjpdXSA9IHYKICAgICAgICBpZiBrLnN0YXJ0c3dpdGgoIkZJVF8iKToKICAgICAgICAgICAgbW9kZWxfY29uZmlnWyJGSVQiXVtrWzQ6XV0gPSB2CgogICAgQ2xhc3NpZmllckNsYXNzID0gY3JlYXRlX2NsYXNzKG1vZGVsX2NvbmZpZ1siTUVUQSJdWyJjbGFzcyJdKQogICAgbW9kZWwgPSBDbGFzc2lmaWVyQ2xhc3MoKiptb2RlbF9jb25maWdbIkNMQVNTIl0pCgogICAgcmV0dXJuIG1vZGVsLCBtb2RlbF9jb25maWcKCmRlZiBnZXRfc2FtcGxlKHNyYzpzdHIsIHNhbXBsZTogaW50LCBsYWJlbDogc3RyLCByZWFkZXI9Tm9uZSk6CiAgICAiIiJnZW5lcmF0ZSBkYXRhIHNhbXBsZSB0byBiZSBzcGxpdCAoY2FuZGlkYXRlIGZvciBtbHJ1bikKICAgICAKICAgIFJldHVybnMgZmVhdHVyZXMgbWF0cml4IGFuZCBoZWFkZXIgKHgpLCBhbmQgbGFiZWxzICh5KQogICAgOnBhcmFtIHNyYzogICAgZnVsbCBwYXRoIGFuZCBmaWxlbmFtZSBvZiBkYXRhIGFydGlmYWN0CiAgICA6cGFyYW0gc2FtcGxlOiBzYW1wbGUgc2l6ZSBmcm9tIGRhdGEgc291cmNlLCB1c2UgbmVnYXRpdmUgCiAgICAgICAgICAgICAgICAgICBpbnRlZ2VycyB0byBzYW1wbGUgcmFuZG9tbHksIHBvc2l0aXZlIHRvCiAgICAgICAgICAgICAgICAgICBzYW1wbGUgY29uc2VjdXRpdmVseSBmcm9tIHRoZSBmaXJzdCByb3cKICAgIDpwYXJhbSBsYWJlbDogIGxhYmVsIGNvbHVtbiB0aXRsZQogICAgOnBhcmFtIHJlYWRlcjogcGFuZGFzIHR5cGUgcmVhZGVyIChyZWFkX2NzdiwgcmVhZF9wYXJxdWV0LCAuLi4pIHJldHVybmluZwogICAgICAgICAgICAgICAgICAgYSBwYW5kYXMgZGF0YWZyYW1lLCBhbmQgd2l0aCBhIGBkcm9wbmFgIGF0dHJpYnV0ZQogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICAKICAgIGlmIG5vdCByZWFkZXI6CiAgICAgICAgaWYgc3JjLmVuZHN3aXRoKCJjc3YiKToKICAgICAgICAgICAgcmVhZGVyID0gcGQucmVhZF9jc3YKICAgICAgICBlbGlmIHNyYy5lbmRzd2l0aCgicGFycXVldCIpIG9yIHNyYy5lbmRzd2l0aCgicHEiKToKICAgICAgICAgICAgcmVhZGVyID0gcGQucmVhZF9wYXJxdWV0CiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmFpc2UgRXhjZXB0aW9uKGYiZmlsZSB0eXBlIHVuaGFuZGxlZCB7c3JjfSIpCgogICAgaWYgKHNhbXBsZSA9PSAtMSkgb3IgKHNhbXBsZSA+PSAxKToKICAgICAgICByYXcgPSByZWFkZXIoc3JjKS5kcm9wbmEoKQogICAgICAgIGxhYmVscyA9IHJhdy5wb3AobGFiZWwpCiAgICAgICAgcmF3ID0gcmF3Lmlsb2NbOnNhbXBsZSwgOl0KICAgICAgICBsYWJlbHMgPSBsYWJlbHMuaWxvY1s6c2FtcGxlXQogICAgZWxzZToKICAgICAgICByYXcgPSByZWFkZXIoc3JjKS5kcm9wbmEoKS5zYW1wbGUoc2FtcGxlICogLTEpCiAgICAgICAgbGFiZWxzID0gcmF3LnBvcChsYWJlbCkKCiAgICByZXR1cm4gcmF3LCBsYWJlbHMsIHJhdy5jb2x1bW5zLnZhbHVlcwoKZGVmIGdldF9zcGxpdHMoCiAgICByYXcsIAogICAgbGFiZWxzLCAKICAgIG5fd2F5czogaW50ID0gMywKICAgIHRlc3Rfc2l6ZTogZmxvYXQgPSAwLjE1LAogICAgdmFsaWRfc2l6ZTogZmxvYXQgPSAwLjMwLAogICAgbGFiZWxfbmFtZXM6IGxpc3QgPSBbImxhYmVscyJdLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSAxCik6CiAgICAiIiJnZW5lcmF0ZSB0cmFpbiBhbmQgdGVzdCBzZXRzIChjYW5kaWRhdGUgZm9yIG1scnVuKQoKICAgIGNyb3NzIHZhbGlkYXRpb246CiAgICAxLiBjdXQgb3V0IGEgdGVzdCBzZXQKICAgIDJhLiB1c2UgdGhlIHRyYWluaW5nIHNldCBpbiBhIGNyb3NzIHZhbGlkYXRpb24gc2NoZW1lLCBvcgogICAgMmIuIG1ha2UgYW5vdGhlciBzcGxpdCB0byBnZW5lcmF0ZSBhIHZhbGlkYXRpb24gc2V0CiAgICAKICAgIDIgcGFydHMgKG5fd2F5cz0yKTogdHJhaW4gYW5kIHRlc3Qgc2V0IG9ubHkKICAgIDMgcGFydHMgKG5fd2F5cz0zKTogdHJhaW4sIHZhbGlkYXRpb24gYW5kIHRlc3Qgc2V0CiAgICA0IHBhcnRzIChuX3dheXM9NCk6IG5fd2F5cz0zICsgYSBoZWxkLW91dCBwcm9iYWJpbGl0eSBjYWxpYnJhdGlvbiBzZXQKICAgIAogICAgOnBhcmFtIHJhdzogICAgICAgICAgICBkYXRhZnJhbWUgb3IgbnVtcHkgYXJyYXkgb2YgcmF3IGZlYXR1cmVzCiAgICA6cGFyYW0gbGFiZWxzOiAgICAgICAgIGRhdGFmcmFtZSBvciBudW1weSBhcnJheSBvZiByYXcgbGFiZWxzCiAgICA6cGFyYW0gbl93YXlzOiAgICAgICAgICgzKSBzcGxpdCBkYXRhIGludG8gMiwgMywgb3IgNCBwYXJ0cwogICAgOnBhcmFtIHRlc3Rfc2l6ZTogICAgICBwcm9wb3J0aW9uIG9mIHJhdyBkYXRhIHRvIHNldCBhc2lkIGFzIHRlc3QgZGF0YQogICAgOnBhcmFtIHZhbGlkX3NpemU6ICAgICBwcm9wb3J0aW9uIG9mIHJlbWFpbmluZyBkYXRhIHRvIGJlIHNldCBhcyB2YWxpZGF0aW9uCiAgICA6cGFyYW0gbGFiZWxfbmFtZXM6ICAgICAgICAgbGFiZWwgbmFtZXMKICAgIDpwYXJhbSByYW5kb21fc3RhdGU6ICAgKDEpIHJhbmRvbSBudW1iZXIgc2VlZAogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICBpbXBvcnQgbnVtcHkgYXMgbnAKICAgIGZyb20gc2tsZWFybi5tb2RlbF9zZWxlY3Rpb24gaW1wb3J0IHRyYWluX3Rlc3Rfc3BsaXQKICAgIAogICAgaWYgaXNpbnN0YW5jZShyYXcsIG5wLm5kYXJyYXkpOgogICAgICAgIGlmIGxhYmVscy5uZGltPT0xOgogICAgICAgICAgICBsYWJlbHM9bGFiZWxzLnJlc2hhcGUoLTEsMSkKICAgICAgICB4eSA9IG5wLmNvbmNhdGVuYXRlKFtyYXcsIGxhYmVsc10sIGF4aXM9MSkKICAgIGVsc2U6CiAgICAgICAgaWYgaXNpbnN0YW5jZShsYWJlbHMsIHBkLlNlcmllcyk6CiAgICAgICAgICAgIHByaW50KGxhYmVscykKICAgICAgICAgICAgcHJpbnQobGFiZWxfbmFtZXMpCiAgICAgICAgICAgIGxhYmVscyA9IHBkLkRhdGFGcmFtZShkYXRhPWxhYmVscywgY29sdW1ucz1sYWJlbF9uYW1lcykKICAgICAgICB4eSA9IHBkLmNvbmNhdChbcmF3LCBsYWJlbHNdLCBheGlzPTEpCiAgICAgICAgCiAgICB4LCB4dGUsIHksIHl0ZSA9IHRyYWluX3Rlc3Rfc3BsaXQoeHksIGxhYmVscywgdGVzdF9zaXplPXRlc3Rfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgaWYgbl93YXlzPT0yOgogICAgICAgIHJldHVybiAoeCwgeSksICh4dGUsIHl0ZSksIE5vbmUsIE5vbmUKICAgIGVsaWYgbl93YXlzPT0zOgogICAgICAgIHh0ciwgeHZhLCB5dHIsIHl2YSA9IHRyYWluX3Rlc3Rfc3BsaXQoeCwgeSx0cmFpbl9zaXplPXZhbGlkX3NpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgICAgIHJldHVybiAoeHRyLCB5dHIpLCAoeHZhLCB5dmEpLCAoeHRlLCB5dGUpLCBOb25lCiAgICBlbGlmIG5fd2F5cz09NDoKICAgICAgICB4dCwgeHZhLCB5dCwgeXZhID0gdHJhaW5fdGVzdF9zcGxpdCh4LCB5LHRyYWluX3NpemU9dmFsaWRfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICAgICAgeHRyLCB4Y2FsLCB5dHIsIHljYWwgPSB0cmFpbl90ZXN0X3NwbGl0KHh0LCB5dCwgdHJhaW5fc2l6ZT0wLjgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgICAgIHJldHVybiAoeHRyLCB5dHIpLCAoeHZhLCB5dmEpLCAoeHRlLCB5dGUpLCAoeGNhbCwgeWNhbCkKICAgIGVsc2U6CiAgICAgICAgcmFpc2UgRXhjZXB0aW9uKCJuX3dheXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzIsNF0iKQoKZGVmIHNhdmVfdGVzdF9zZXQoCiAgICBjb250ZXh0LCAKICAgIHh0ZXN0LCAKICAgIHl0ZXN0LCAKICAgIGhlYWRlcjogbGlzdCwgCiAgICBsYWJlbDogc3RyID0gImxhYmVscyIsIAogICAgZmlsZV9leHQ6IHN0ciA9ICJwYXJxdWV0IiwgCiAgICBpbmRleDogYm9vbCA9IEZhbHNlLAogICAgZGVidWc6IGJvb2wgPSBGYWxzZQopOgogICAgIiIibG9nIGEgaGVsZCBvdXQgdGVzdCBzZXQKCiAgICA6cGFyYW0gY29udGV4dDogICAgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0geHRlc3Q6ICAgICAgdGVzdCBmZWF0dXJlcywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSB5dGVzdDogICAgICB0ZXN0IGxhYmVscywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSBoZWFkZXI6ICAgICAoW10pZmVhdHVyZXMgaGVhZGVyIGlmIHJlcXVpcmVkCiAgICA6cGFyYW0gbGFiZWw6ICAgICAgKCJsYWJlbHMiKSBuYW1lIG9mIGxhYmVsIGNvbHVtbgogICAgOnBhcmFtIGZpbGVfZXh0OiAgIGZvcm1hdCBvZiB0ZXN0IHNldCBmaWxlCiAgICA6cGFyYW0gaW5kZXg6ICAgICAgcHJlc2VydmUgaW5kZXggY29sdW1uCiAgICA6cGFyYW0gZGVidWc6ICAgICAgKEZhbHNlKQogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICBmcm9tIG1scnVuIGltcG9ydCBtbGNvbmYKICAgIAogICAgdGVzdF9zZXQgPSBwZC5jb25jYXQoCiAgICAgICAgW3BkLkRhdGFGcmFtZShkYXRhPXh0ZXN0LCBjb2x1bW5zPWhlYWRlciksCiAgICAgICAgIHBkLkRhdGFGcmFtZShkYXRhPXl0ZXN0LnZhbHVlcywgY29sdW1ucz1bbGFiZWxdKV0sCiAgICAgICAgYXhpcz0xLCkKICAgIAogICAgaWYgZGVidWc6CiAgICAgICAgdGVzdF9zZXQudG9fcGFycXVldChtbGNvbmYuYXJ0aWZhY3RfcGF0aCsnL3Rlc3Rfc2V0LWRldi5wYXJxdWV0JykKICAgICAgICAKICAgIGNvbnRleHQubG9nX2RhdGFzZXQoInRlc3Rfc2V0IiwgZGY9dGVzdF9zZXQsIGZvcm1hdD1maWxlX2V4dCwgaW5kZXg9aW5kZXgpCgpkZWYgZHVtcF94Z2JfbW9kZWwoCiAgICBjb250ZXh0LCAKICAgIG1vZGVsLAogICAgZHVtcF90eXBlOiBzdHIsCiAgICBkZXN0X2ZvbGRlcjogc3RyLAogICAgZGVzdF9uYW1lOiBzdHIKKToKICAgICIiInNlcmlhbGl6ZS9sb2cgbW9kZWwKICAgIAogICAgWEdCb29zdCBtb2RlbCBjYW4gYmUgc2F2ZSBpbiAzIGRpZmZlcmVudCB3YXlzOgogICAgMS4gcGlja2xlIHRoZSBpbnRlcm5hbCBfYm9vc3RlciBvYmplY3QsIGluc2lkZSB0aGUgbW9kZWwKICAgIDIuIHVzaW5nIG1vZGVsLnNhdmVfbW9kZWwoImZuLmJpbiIpIHVzaW5nIGEgbGVnYWN5IGJpbmFyeSB4Z2IgZm9ybWF0CiAgICAyLiB1c2luZyBtb2RlbC5zYXZlX21vZGVsKCJmbi5qc29uIikgdXNpbmcgYSBwb3J0YWJsZSBqc29uIGZvcm1hdAogICAgCiAgICA6cGFyYW0gY29udGV4dDogICAgIHRoZSBmdW5jdGlvbiJzIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0gbW9kZWw6ICAgICAgIHRoZSBmaXR0ZWQgeGdib29zdCBtb2RlbAogICAgOnBhcmFtIGR1bXBfdHlwZTogICAicGlja2xlIiBsZWdhY3kiLCBvciAianNvbiIsIAogICAgOnBhcmFtIGRlc3RfZm9sZGVyOiBwYXRoIGZvciBzZXJpYWxpemVkIG1vZGVsIAogICAgOnBhcmFtIGRlc3RfbmFtZTogICBuYW1lIGZvciBzZXJpYWxpemVkIG1vZGVsIGZpbGUKICAgICIiIgogICAgZnJvbSBjbG91ZHBpY2tsZSBpbXBvcnQgZHVtcHMsIGR1bXAKICAgIHRyeToKICAgICAgICBtb2RlbC5zYXZlX21vZGVsKGYie2Rlc3RfZm9sZGVyfS97ZGVzdF9uYW1lfS1zYXZlX21vZGVsLnBrbCIpCiAgICAgICAgCiAgICAgICAgbW9kZWwuc2F2ZV9tb2RlbChmIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0tc2F2ZV9tb2RlbC5qc29uIikKICAgICAgICAKICAgICAgICBfYm9vc3RlciA9IG1vZGVsLmdldF9ib29zdGVyKCkKICAgICAgICBkdW1wKF9ib29zdGVyLCBvcGVuKGYie2Rlc3RfZm9sZGVyfS97ZGVzdF9uYW1lfS1kdW1wLnBrbCIsICJ3YiIpKQogICAgICAgIGR1bXAobW9kZWwsIG9wZW4oZiJ7ZGVzdF9mb2xkZXJ9L3tkZXN0X25hbWV9LWR1bXAtbW9kZWwucGtsIiwgIndiIikpCiAgICAgICAgCiAgICAgICAgZGF0YSA9IGR1bXBzKF9ib29zdGVyKQogICAgICAgIGNvbnRleHQubG9nX2FydGlmYWN0KCJtb2RlbCIsIGJvZHk9ZGF0YSwgbG9jYWxfcGF0aD1mIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0ucGtsIikKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBwcmludCgieGdib29zdCBtb2RlbCBzZXJpYWxpemF0aW9uIGVycm9yIiwgc3RyKGUpKQoKZGVmIHBsb3RfY29uZnVzaW9uX21hdHJpeCgKICAgIGxhYmVscywKICAgIHByZWRpY3Rpb25zLAogICAgY2xhc3NlcywKICAgIG5vcm1hbGl6ZT0iYWxsIiwKICAgIHRpdGxlPSdDb25mdXNpb24gbWF0cml4JywKICAgIGNtYXA9Tm9uZQopOgogICAgIiIicHJpbnRzIGFuZCBwbG90cyB0aGUgY29uZnVzaW9uIG1hdHJpeC4KICAgIAogICAgIiIiCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIGltcG9ydCBudW1weSBhcyBucAogICAgaW1wb3J0IGl0ZXJ0b29scwogICAgCiAgICBpZiBub3QgY21hcDoKICAgICAgICBjbWFwID0gcGx0LmNtLkJsdWVzCgogICAgY20gPSBtZXRyaWNzLmNvbmZ1c2lvbl9tYXRyaXgobGFiZWxzLCBwcmVkaWN0aW9ucywgbm9ybWFsaXplPW5vcm1hbGl6ZSkKICAgIAogICAgcGx0Lmltc2hvdyhjbSwgaW50ZXJwb2xhdGlvbj0nbmVhcmVzdCcsIGNtYXA9Y21hcCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5jb2xvcmJhcigpCiAgICB0aWNrX21hcmtzID0gbnAuYXJhbmdlKGxlbihjbGFzc2VzKSkKICAgIHBsdC54dGlja3ModGlja19tYXJrcywgY2xhc3Nlcywgcm90YXRpb249NDUpCiAgICBwbHQueXRpY2tzKHRpY2tfbWFya3MsIGNsYXNzZXMpCgogICAgdGhyZXNoID0gY20ubWF4KCkgLyAyLgogICAgZm9yIGksIGogaW4gaXRlcnRvb2xzLnByb2R1Y3QocmFuZ2UoY20uc2hhcGVbMF0pLCByYW5nZShjbS5zaGFwZVsxXSkpOgogICAgICAgIHBsdC50ZXh0KGosIGksIHJvdW5kKGNtW2ksIGpdLCAyKSwKICAgICAgICAgICAgICAgICBob3Jpem9udGFsYWxpZ25tZW50PSJjZW50ZXIiLAogICAgICAgICAgICAgICAgIGNvbG9yPSJ3aGl0ZSIgaWYgY21baSwgal0gPiB0aHJlc2ggZWxzZSAiYmxhY2siKQoKICAgIHBsdC55bGFiZWwoJ1RydWUgbGFiZWwnKQogICAgcGx0LnhsYWJlbCgnUHJlZGljdGVkIGxhYmVsJykKICAgIHJldHVybiBwbHQuZ2NmKCkKCmRlZiBwbG90X3JvYygKICAgIGNvbnRleHQsCiAgICB5X2xhYmVscywKICAgIHlfcHJvYnMsCiAgICBmcHJfbGFiZWw6IHN0ciA9ICJmYWxzZSBwb3NpdGl2ZSByYXRlIiwKICAgIHRwcl9sYWJlbDogc3RyID0gInRydWUgcG9zaXRpdmUgcmF0ZSIsCiAgICB0aXRsZTogc3RyID0gInJvYyBjdXJ2ZSIsCiAgICBsZWdlbmRfbG9jOiBzdHIgPSAiYmVzdCIsCik6CiAgICAiIiJwbG90IHJvYyBjdXJ2ZXMKCiAgICBUT0RPOiAgYWRkIGF2ZXJhZ2luZyBtZXRob2QgKGFzIHN0cmluZykgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgcHJvYnMsIAogICAgZGlzcGxheSBpbiBsZWdlbmQKCiAgICA6cGFyYW0gY29udGV4dDogICAgICB0aGUgZnVuY3Rpb24gY29udGV4dAogICAgOnBhcmFtIHlfbGFiZWxzOiAgICAgZ3JvdW5kIHRydXRoIGxhYmVscywgaG90IGVuY29kZWQgZm9yIG11bHRpY2xhc3MgIAogICAgOnBhcmFtIHlfcHJvYnM6ICAgICAgbW9kZWwgcHJlZGljdGlvbiBwcm9iYWJpbGl0aWVzCiAgICA6cGFyYW0ga2V5OiAgICAgICAgICAoInJvYyIpIGtleSBvZiBwbG90IGluIGFydGlmYWN0IHN0b3JlCiAgICA6cGFyYW0gcGxvdHNfZGlyOiAgICAoInBsb3RzIikgZGVzdGluYXRpb24gZm9sZGVyIHJlbGF0aXZlIHBhdGggdG8gYXJ0aWZhY3QgcGF0aAogICAgOnBhcmFtIGZtdDogICAgICAgICAgKCJwbmciKSBwbG90IGZvcm1hdAogICAgOnBhcmFtIGZwcl9sYWJlbDogICAgKCJmYWxzZSBwb3NpdGl2ZSByYXRlIikgeC1heGlzIGxhYmVscwogICAgOnBhcmFtIHRwcl9sYWJlbDogICAgKCJ0cnVlIHBvc2l0aXZlIHJhdGUiKSB5LWF4aXMgbGFiZWxzCiAgICA6cGFyYW0gdGl0bGU6ICAgICAgICAoInJvYyBjdXJ2ZSIpIHRpdGxlIG9mIHBsb3QKICAgIDpwYXJhbSBsZWdlbmRfbG9jOiAgICgiYmVzdCIpIGxvY2F0aW9uIG9mIHBsb3QgbGVnZW5kCiAgICAiIiIKICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgZnJvbSBtbHJ1bi5tbHV0aWxzIGltcG9ydCBnY2ZfY2xlYXIKICAgIAogICAgZ2NmX2NsZWFyKHBsdCkKCiAgICBwbHQucGxvdChbMCwgMV0sIFswLCAxXSwgImstLSIpCgogICAgcGx0LnhsYWJlbChmcHJfbGFiZWwpCiAgICBwbHQueWxhYmVsKHRwcl9sYWJlbCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5sZWdlbmQobG9jPWxlZ2VuZF9sb2MpCgogICAgcHJpbnQoeV9sYWJlbHMuc2hhcGUpCiAgICBpZiB5X2xhYmVscy5uZGltID4gMjoKICAgICAgICBmcHIgPSBkaWN0KCkKICAgICAgICB0cHIgPSBkaWN0KCkKICAgICAgICByb2NfYXVjID0gZGljdCgpCiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoeV9sYWJlbHNbOiwgOi0xXS5zaGFwZVsxXSk6CiAgICAgICAgICAgIGZwcltpXSwgdHByW2ldLCBfID0gbWV0cmljcy5yb2NfY3VydmUoCiAgICAgICAgICAgICAgICB5X2xhYmVsc1s6LCBpXSwgeV9wcm9ic1s6LCBpXSwgcG9zX2xhYmVsPTEKICAgICAgICAgICAgKQogICAgICAgICAgICByb2NfYXVjW2ldID0gbWV0cmljcy5hdWMoZnByW2ldLCB0cHJbaV0pCiAgICAgICAgICAgIHBsdC5wbG90KGZwcltpXSwgdHByW2ldLCBsYWJlbD1mImNsYXNzIHtpfSIpCiAgICBlbHNlOgogICAgICAgIGZwciwgdHByLCBfID0gbWV0cmljcy5yb2NfY3VydmUoeV9sYWJlbHMsIHlfcHJvYnNbOiwtMV0pCiAgICAgICAgcGx0LnBsb3QoZnByLCB0cHIsIGxhYmVsPWYicG9zaXRpdmUgY2xhc3MiKQoKICAgIHJldHVybiBwbHQuZ2NmKCkKCmRlZiBnZW5fcHJvYmEoCiAgICBjb250ZXh0LAogICAgZmVhdHMsCiAgICBsYWJlbHMsCiAgICBtb2RlbCwKICAgIHNjb3JlX21ldGhvZCwKICAgIHBsb3RzX2Rlc3QsCiAgICBudHJlZV9saW1pdD1Ob25lLAogICAgdmFsaWRhdGVfZmVhdHVyZXM9VHJ1ZSwKICAgIGJhc2VfbWFyZ2luPU5vbmUKKToKICAgICIiIiBnZW5lcmF0ZSBwcmVkaWN0aW9ucyBhbmQgdmFsaWRhdGlvbiBzdGF0cwogICAgCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgIHRoZSBmdW5jdGlvbiBleGVjdXRpb24gY29udGV4dAogICAgOnBhcmFtIGZlYXRzOiAgICAgICAgICAgICB2YWxpZGF0aW9uIGZlYXR1cmVzIGFycmF5IAogICAgOnBhcmFtIGxhYmVsczogICAgICAgICAgICB2YWxpZGF0aW9uIGdyb3VuZC10cnV0aCBsYWJlbHMKICAgIDpwYXJhbSBtb2RlbDogICAgICAgICAgICAgZXN0aW1hdGVkIG1vZGVsCiAgICA6cGFyYW0gc2Nyb3JlX21ldGhvZDogICAgICgiYXZlcmFnZSIpIG11bHRpY2xhc3Mgc2NvcmluZwogICAgOnBhcmFtIHBsb3RzX2Rlc3Q6ICAgICAgICBkZXN0aW5hdGlvbiBmb2xkZXIgZm9yIHBsb3QgYXJ0aWZhY3RzCiAgICA6cGFyYW0gbnRyZWVfbGltaXQ6ICAgICAgIChOb25lKSBsaW1pdCBuby4gdHJlZXMgdXNlZCBpbiBwcmVkaWN0aW9uCiAgICA6cGFyYW0gdmFsaWRhdGVfZmVhdHVyZXM6IChUcnVlKSBlbnN1cmUgY29uc2lzdGVudCBmZWF0dXJlIG5hbWVzIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXR3ZWVuIG1vZGVsIGFuZCBpbnB1dCBkYXRhCiAgICA6cGFyYW0gYmFzZV9tYXJnaW46ICAgICAgIChOb25lKSB1bmRlZmluZWQKICAgICIiIgogICAgZnJvbSBza2xlYXJuIGltcG9ydCBtZXRyaWNzCiAgICBmcm9tIG1scnVuLmFydGlmYWN0cyBpbXBvcnQgUGxvdEFydGlmYWN0CiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdjZl9jbGVhcgogICAgZnJvbSB4Z2Jvb3N0IGltcG9ydCBYR0JDbGFzc2lmaWVyCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICAKICAgIHlwcmVkID0gbW9kZWwucHJlZGljdChmZWF0cywgRmFsc2UsIG50cmVlX2xpbWl0LCB2YWxpZGF0ZV9mZWF0dXJlcywgYmFzZV9tYXJnaW4pCiAgICAKICAgIHlfcHJvYmEgPSBbXQogICAgaWYgaGFzYXR0cihtb2RlbCwgInByZWRpY3RfcHJvYmEiKToKICAgICAgICB5X3Byb2JhID0gbW9kZWwucHJlZGljdF9wcm9iYShmZWF0cywgbnRyZWVfbGltaXQsIHZhbGlkYXRlX2ZlYXR1cmVzLCBiYXNlX21hcmdpbikKICAgIHlwcmVkX2JpbmFyeSA9IFtyb3VuZCh2YWx1ZSkgZm9yIHZhbHVlIGluIHlfcHJvYmFbOiwtMV1dCiAgICAKICAgIGF2ZXJhZ2VfcHJlY2lzaW9uID0gbWV0cmljcy5hdmVyYWdlX3ByZWNpc2lvbl9zY29yZShsYWJlbHMsIHlfcHJvYmFbOiwtMV0sIGF2ZXJhZ2U9c2NvcmVfbWV0aG9kKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYiYXZnX3ByZWNpc2lvbiIsIGF2ZXJhZ2VfcHJlY2lzaW9uKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYicm9jYXVjIiwgbWV0cmljcy5yb2NfYXVjX3Njb3JlKGxhYmVscywgeV9wcm9iYVs6LC0xXSkpCiAgICBjb250ZXh0LmxvZ19yZXN1bHQoZiJhY2N1cmFjeV9zY29yZSIsIGZsb2F0KG1ldHJpY3MuYWNjdXJhY3lfc2NvcmUobGFiZWxzLCB5cHJlZF9iaW5hcnkpKSkKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmImYxX3Njb3JlIiwgbWV0cmljcy5mMV9zY29yZShsYWJlbHMsIHlwcmVkX2JpbmFyeSwgYXZlcmFnZT1zY29yZV9tZXRob2QpKQogICAgCiAgICBjb250ZXh0LmxvZ19hcnRpZmFjdChQbG90QXJ0aWZhY3QoInJvYyIsIGJvZHk9cGxvdF9yb2MoY29udGV4dCwgbGFiZWxzLCB5X3Byb2JhKSksCiAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbF9wYXRoPWYie3Bsb3RzX2Rlc3R9L3JvYy5odG1sIikKICAgIGdjZl9jbGVhcihwbHQpCgogICAgYm9keSA9IHBsb3RfY29uZnVzaW9uX21hdHJpeChsYWJlbHMsIHlwcmVkX2JpbmFyeSwgY2xhc3Nlcz1sYWJlbHMubGFiZWxzLnVuaXF1ZSgpKSAKICAgIGNvbnRleHQubG9nX2FydGlmYWN0KFBsb3RBcnRpZmFjdCgiY29uZnVzaW9uIiwgYm9keT1ib2R5KSwgbG9jYWxfcGF0aD1mIntwbG90c19kZXN0fS9jb25mdXNpb24uaHRtbCIpCiAgICAKICAgIHJldHVybiB5X3Byb2JhCgpkZWYgcHJvYmFfY2FsaWJyYXRpb24obW9kZWwsIHhjYWwsIHljYWwpOgogICAgIiIiY2FsaWJyYXRlIG91dHB1dCBwcm9iYWJpbGl0aWVzCiAgICAKICAgIGFkYXB0ZWQgZnJvbSBodHRwczovL3NjaWtpdC1sZWFybi5vcmcvc3RhYmxlL2F1dG9fZXhhbXBsZXMvY2FsaWJyYXRpb24vcGxvdF9jYWxpYnJhdGlvbl9jdXJ2ZS5odG1sI3NwaHgtZ2xyLWF1dG8tZXhhbXBsZXMtY2FsaWJyYXRpb24tcGxvdC1jYWxpYnJhdGlvbi1jdXJ2ZS1weQogICAgIiIiCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICBmcm9tIHNrbGVhcm4uY2FsaWJyYXRpb24gaW1wb3J0IChDYWxpYnJhdGVkQ2xhc3NpZmllckNWLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsaWJyYXRpb25fY3VydmUpCiAgICBmcm9tIHNrbGVhcm4ubGluZWFyX21vZGVsIGltcG9ydCBMb2dpc3RpY1JlZ3Jlc3Npb24KICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgCiAgICBkZWYgcGxvdF9jYWxpYnJhdGlvbl9jdXJ2ZShuYW1lLCBmaWdfaW5kZXgpOgogICAgICAgICIiIlBsb3QgY2FsaWJyYXRpb24gY3VydmUgZm9yIGVzdCB3L28gYW5kIHdpdGggY2FsaWJyYXRpb24uICIiIgogICAgICAgIGlzb3RvbmljID0gQ2FsaWJyYXRlZENsYXNzaWZpZXJDVihtb2RlbCwgY3Y9InByZWZpdCIsIG1ldGhvZD0naXNvdG9uaWMnKQoKICAgICAgICBzaWdtb2lkID0gQ2FsaWJyYXRlZENsYXNzaWZpZXJDVihtb2RlbCwgY3Y9InByZWZpdCIsIG1ldGhvZD0nc2lnbW9pZCcpCgogICAgICAgIGxyID0gTG9naXN0aWNSZWdyZXNzaW9uKEM9MS4pCgogICAgICAgIGZpZyA9IHBsdC5maWd1cmUoZmlnX2luZGV4LCBmaWdzaXplPSgxMCwgMTApKQogICAgICAgIGF4MSA9IHBsdC5zdWJwbG90MmdyaWQoKDMsIDEpLCAoMCwgMCksIHJvd3NwYW49MikKICAgICAgICBheDIgPSBwbHQuc3VicGxvdDJncmlkKCgzLCAxKSwgKDIsIDApKQoKICAgICAgICBheDEucGxvdChbMCwgMV0sIFswLCAxXSwgIms6IiwgbGFiZWw9IlBlcmZlY3RseSBjYWxpYnJhdGVkIikKICAgICAgICBmb3IgY2xmLCBuYW1lIGluIFsobHIsICdMb2dpc3RpYycpLAogICAgICAgICAgICAgICAgICAgICAgICAgIChtb2RlbCwgbmFtZSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzb3RvbmljLCBuYW1lICsgJyArIElzb3RvbmljJyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgKHNpZ21vaWQsIG5hbWUgKyAnICsgU2lnbW9pZCcpXToKICAgICAgICAgICAgY2xmLmZpdCh4Y2FsLCB5Y2FsKQogICAgICAgICAgICB5X3ByZWQgPSBjbGYucHJlZGljdCh4Y2FsKQogICAgICAgICAgICBpZiBoYXNhdHRyKGNsZiwgInByZWRpY3RfcHJvYmEiKToKICAgICAgICAgICAgICAgIHByb2JfcG9zID0gY2xmLnByZWRpY3RfcHJvYmEoeGNhbClbOiwgMV0KICAgICAgICAgICAgZWxzZTogICMgdXNlIGRlY2lzaW9uIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICBwcm9iX3BvcyA9IGNsZi5kZWNpc2lvbl9mdW5jdGlvbih4Y2FsKQogICAgICAgICAgICAgICAgcHJvYl9wb3MgPSAgICAgICAgICAgICAgICAgICAgIChwcm9iX3BvcyAtIHByb2JfcG9zLm1pbigpKSAvIChwcm9iX3Bvcy5tYXgoKSAtIHByb2JfcG9zLm1pbigpKQoKICAgICAgICAgICAgY2xmX3Njb3JlID0gbWV0cmljcy5icmllcl9zY29yZV9sb3NzKHljYWwsIHByb2JfcG9zLCBwb3NfbGFiZWw9MSkgIyBwb3NfbGFiZWw9eWNhbC5tYXgoKSkKICAgICAgICAgICAgcHJpbnQoIiVzOiIgJSBuYW1lKQogICAgICAgICAgICBwcmludCgiXHRCcmllcjogJTEuM2YiICUgKGNsZl9zY29yZSkpCiAgICAgICAgICAgIHByaW50KCJcdFByZWNpc2lvbjogJTEuM2YiICUgbWV0cmljcy5wcmVjaXNpb25fc2NvcmUoeWNhbCwgeV9wcmVkKSkKICAgICAgICAgICAgcHJpbnQoIlx0UmVjYWxsOiAlMS4zZiIgJSBtZXRyaWNzLnJlY2FsbF9zY29yZSh5Y2FsLCB5X3ByZWQpKQogICAgICAgICAgICBwcmludCgiXHRGMTogJTEuM2ZcbiIgJSBtZXRyaWNzLmYxX3Njb3JlKHljYWwsIHlfcHJlZCkpCgogICAgICAgICAgICBmcmFjdGlvbl9vZl9wb3NpdGl2ZXMsIG1lYW5fcHJlZGljdGVkX3ZhbHVlID0gICAgICAgICAgICAgICAgIGNhbGlicmF0aW9uX2N1cnZlKHljYWwsIHByb2JfcG9zLCBuX2JpbnM9MTApCgogICAgICAgICAgICBheDEucGxvdChtZWFuX3ByZWRpY3RlZF92YWx1ZSwgZnJhY3Rpb25fb2ZfcG9zaXRpdmVzLCAicy0iLAogICAgICAgICAgICAgICAgICAgICBsYWJlbD0iJXMgKCUxLjNmKSIgJSAobmFtZSwgY2xmX3Njb3JlKSkKCiAgICAgICAgICAgIGF4Mi5oaXN0KHByb2JfcG9zLCByYW5nZT0oMCwgMSksIGJpbnM9MTAsIGxhYmVsPW5hbWUsCiAgICAgICAgICAgICAgICAgICAgIGhpc3R0eXBlPSJzdGVwIiwgbHc9MikKCiAgICAgICAgYXgxLnNldF95bGFiZWwoIkZyYWN0aW9uIG9mIHBvc2l0aXZlcyIpCiAgICAgICAgYXgxLnNldF95bGltKFstMC4wNSwgMS4wNV0pCiAgICAgICAgYXgxLmxlZ2VuZChsb2M9Imxvd2VyIHJpZ2h0IikKICAgICAgICBheDEuc2V0X3RpdGxlKCdDYWxpYnJhdGlvbiBwbG90cyAgKHJlbGlhYmlsaXR5IGN1cnZlKScpCgogICAgICAgIGF4Mi5zZXRfeGxhYmVsKCJNZWFuIHByZWRpY3RlZCB2YWx1ZSIpCiAgICAgICAgYXgyLnNldF95bGFiZWwoIkNvdW50IikKICAgICAgICBheDIubGVnZW5kKGxvYz0idXBwZXIgY2VudGVyIiwgbmNvbD0yKQoKICAgICAgICBwbHQudGlnaHRfbGF5b3V0KCkKCiAgICBwbG90X2NhbGlicmF0aW9uX2N1cnZlKCJYR0Jvb3N0IiwgMSkKCiAgICBwbHQuc2hvdygpCgpkZWYgdHJhaW5fbW9kZWwoCiAgICBjb250ZXh0LAogICAgbW9kZWxfdHlwZTogc3RyLAogICAgZGF0YXNldCwKICAgIGxhYmVsX2NvbHVtbjogc3RyID0gImxhYmVscyIsCiAgICBzYW1wbGU6IGludCA9IC0xLAogICAgdGVzdF9zaXplOiBmbG9hdCA9IDAuMDUsCiAgICB2YWxpZF9zaXplOiBmbG9hdCA9IDAuNzUsCiAgICByYW5kb21fc3RhdGU6IGludCA9IDEsCiAgICBtb2RlbF9maWxlbmFtZTogc3RyID0gIm1vZGVsIiwKICAgIG1vZGVsc19kZXN0OiBzdHIgPSAiIiwKICAgIHBsb3RzX2Rlc3Q6IHN0ciA9ICIiLAogICAgc2NvcmVfbWV0aG9kOiBzdHIgPSAibWljcm8iLAogICAgZmlsZV9leHQ6IHN0ciA9ICJwYXJxdWV0IiwKICAgIG1vZGVsX3BrZ19maWxlOiBzdHIgPSAiIiwgICAgCikgLT4gTm9uZToKICAgICIiInRyYWluIGFuIHhnYm9vc3QgbW9kZWwuCgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICB0aGUgZnVuY3Rpb24gY29udGV4dAogICAgOnBhcmFtIG1vZGVsX3R5cGU6ICAgICAgICB0aGUgbW9kZWwgdHlwZSB0byB0cmFpbiwgJ2NsYXNzaWZpZXInLCAncmVncmVzc29yJy4uLgogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgICAoImRhdGEiKSBuYW1lIG9mIHJhdyBkYXRhIGZpbGUKICAgIDpwYXJhbSBsYWJlbF9jb2x1bW46ICAgICAgZ3JvdW5kLXRydXRoICh5KSBsYWJlbHMKICAgIDpwYXJhbSBzYW1wbGU6ICAgICAgICAgICAgU2VsZWN0cyB0aGUgZmlyc3QgbiByb3dzLCBvciBzZWxlY3QgYSBzYW1wbGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3QuIElmIG5lZ2F0aXZlIDwtMSwgc2VsZWN0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcmFuZG9tIHNhbXBsZQogICAgOnBhcmFtIG1vZGVsX2ZpbGVuYW1lOiAgICBtb2RlbCBmaWxlIGZpbGVuYW1lLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgdG8gYSBkaXJlY3RvcnkKICAgIDpwYXJhbSB0ZXN0X3NpemU6ICAgICAgICAgKDAuMDUpIHRlc3Qgc2V0IHNpemUKICAgIDpwYXJhbSB2YWxpZF9zaXplOiAgICAgICAgICAoMC43NSkgT25jZSB0aGUgdGVzdCBzZXQgaGFzIGJlZW4gcmVtb3ZlZCB0aGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaW5pbmcgc2V0IGdldHMgdGhpcyBwcm9wb3J0aW9uLgogICAgOnBhcmFtIHJhbmRvbV9zdGF0ZTogICAgICAoMSkgc2tsZWFybiBybmcgc2VlZAogICAgOnBhcmFtIG1vZGVsc19kZXN0OiAgICAgICBtb2RlbHMgc3ViZm9sZGVyIG9uIGFydGlmYWN0IHBhdGgKICAgIDpwYXJhbSBwbG90c19kZXN0OiAgICAgICAgcGxvdCBzdWJmb2xkZXIgb24gYXJ0aWZhY3QgcGF0aAogICAgOnBhcmFtIHNjb3JlX21ldGhvZDogICAgICBmb3IgbXVsdGljbGFzcyBjbGFzc2lmaWNhdGlvbgogICAgCiAgICA6cGFyYW0gZmlsZV9leHQ6ICAgICAgICAgIGZvcm1hdCBmb3IgdGVzdF9zZXRfa2V5IGhvbGQgb3V0IGRhdGEKICAgIDpwYXJhbSBtb2RlbF9wa2dfZmlsZTogICAganNvbiBtb2RlbCBjb25maWcgZmlsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICIiIgogICAgbW9kZWxzX2Rlc3QgPSBtb2RlbHNfZGVzdCBvciAibW9kZWxzIgogICAgcGxvdHNfZGVzdCA9IHBsb3RzX2Rlc3Qgb3IgZiJwbG90cy97Y29udGV4dC5uYW1lfSIKICAgIAogICAgcmF3LCBsYWJlbHMsIGhlYWRlciA9IGdldF9zYW1wbGUoc3RyKGRhdGFzZXQpLCBzYW1wbGUsIGxhYmVsX2NvbHVtbikKICAgIAogICAgKHh0cix5dHIpLCAoeHZhLHl2YSksICh4dGUseXRlKSwgKHhjYWwsIHljYWwpID0gZ2V0X3NwbGl0cyhyYXcsIGxhYmVscywgNCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdF9zaXplLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRfc2l6ZSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsibGFiZWxzIl0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZSkKICAgICAgICAKICAgIG1vZGVsLCBtb2RlbF9jb25maWcgPSBnZW5feGdiX21vZGVsKG1vZGVsX3R5cGUsIGNvbnRleHQucGFyYW1ldGVycy5pdGVtcygpKQogICAgCiAgICBtb2RlbF9jb25maWdbIkZJVCJdLnVwZGF0ZSh7IlgiOiB4dHIsInkiOiB5dHIudmFsdWVzfSkKICAgIAogICAgbW9kZWwuZml0KCoqbW9kZWxfY29uZmlnWyJGSVQiXSkKICAgIAogICAgZHVtcF94Z2JfbW9kZWwoY29udGV4dCwgbW9kZWwsICJqc29uIiwgbW9kZWxzX2Rlc3QsIG1vZGVsX2ZpbGVuYW1lKQoKICAgIHlfcHJvYmEgPSBnZW5fcHJvYmEoY29udGV4dCwgeHZhLCB5dmEsIG1vZGVsLCBzY29yZV9tZXRob2QsIHBsb3RzX2Rlc3QpCiAgICAKICAgIHlfcHJvYmFfY2FsID0gcHJvYmFfY2FsaWJyYXRpb24obW9kZWwsIHhjYWwsIHljYWwpCgo=
    commands: []
    code_origin: https://github.com/yjb-ds/functions.git#c60c94ad4d2a306375baed5b643068c20bb4ced5:xgb_trainer.ipynb
