spec:
  default_handler: train
  entry_points:
    train:
      has_kwargs: true
      lineno: 121
      has_varargs: false
      doc: "Training a model with the given dataset.\n\nexample::\n\n    import mlrun\n\
        \n    project = mlrun.get_or_create_project(\"my-project\")\n    project.set_function(\"\
        hub://auto_trainer\", \"train\")\n    trainer_run = project.run(\n       \
        \ name=\"train\",\n        handler=\"train\",\n        inputs={\"dataset\"\
        : \"./path/to/dataset.csv\"},\n        params={\n            \"model_class\"\
        : \"sklearn.linear_model.LogisticRegression\",\n            \"label_columns\"\
        : \"label\",\n            \"drop_columns\": \"id\",\n            \"model_name\"\
        : \"my-model\",\n            \"tag\": \"v1.0.0\",\n            \"sample_set\"\
        : \"./path/to/sample_set.csv\",\n            \"test_set\": \"./path/to/test_set.csv\"\
        ,\n            \"CLASS_solver\": \"liblinear\",\n        },\n    )"
      name: train
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context
      - name: dataset
        type: DataItem
        doc: The dataset to train the model on. Can be either a URI or a FeatureVector
      - name: model_class
        type: str
        doc: The class of the model, e.g. `sklearn.linear_model.LogisticRegression`
      - name: label_columns
        doc: The target label(s) of the column(s) in the dataset. for Regression or
          Classification tasks. Mandatory when dataset is not a FeatureVector.
        default: null
      - name: drop_columns
        type: list[str]
        doc: str or a list of strings that represent the columns to drop
        default: null
      - name: model_name
        type: str
        doc: The model's name to use for storing the model artifact, default to 'model'
        default: model
      - name: tag
        type: str
        doc: The model's tag to log with
        default: ''
      - name: sample_set
        type: DataItem
        doc: A sample set of inputs for the model for logging its stats along the
          model in favour of model monitoring. Can be either a URI or a FeatureVector
        default: null
      - name: test_set
        type: DataItem
        doc: The test set to train the model with.
        default: null
      - name: train_test_split_size
        type: float
        doc: if test_set was provided then this argument is ignored. Should be between
          0.0 and 1.0 and represent the proportion of the dataset to include in the
          test split. The size of the Training set is set to the complement of this
          value. Default = 0.2
        default: null
      - name: random_state
        type: int
        doc: 'Relevant only when using train_test_split_size. A random state seed
          to shuffle the data. For more information, see: https://scikit-learn.org/stable/glossary.html#term-random_state
          Notice that here we only pass integer values.'
        default: null
      - name: labels
        type: dict
        doc: Labels to log with the model
        default: null
    evaluate:
      has_kwargs: true
      lineno: 274
      has_varargs: false
      doc: Evaluating a model. Artifacts generated by the MLHandler.
      name: evaluate
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context.
      - name: model
        type: str
        doc: The model Store path.
      - name: dataset
        type: DataItem
        doc: The dataset to evaluate the model on. Can be either a URI or a FeatureVector.
      - name: drop_columns
        type: list[str]
        doc: str or a list of strings that represent the columns to drop.
        default: null
      - name: label_columns
        doc: The target label(s) of the column(s) in the dataset. for Regression or
          Classification tasks. Mandatory when dataset is not a FeatureVector.
        default: null
    predict:
      has_kwargs: true
      lineno: 328
      has_varargs: false
      doc: Predicting dataset by a model.
      name: predict
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context.
      - name: model
        type: str
        doc: The model Store path.
      - name: dataset
        type: DataItem
        doc: The dataset to predict the model on. Can be either a URI, a FeatureVector
          or a sample in a shape of a list/dict. When passing a sample, pass the dataset
          as a field in `params` instead of `inputs`.
      - name: drop_columns
        doc: str/int or a list of strings/ints that represent the column names/indices
          to drop. When the dataset is a list/dict this parameter should be represented
          by integers.
        default: null
      - name: label_columns
        doc: The target label(s) of the column(s) in the dataset. for Regression or
          Classification tasks. Mandatory when dataset is not a FeatureVector.
        default: null
      - name: result_set
        doc: The db key to set name of the prediction result and the filename. Default
          to 'prediction'.
        default: null
  filename: auto_trainer.py
  image: mlrun/mlrun
  command: ''
  disable_auto_mount: false
  build:
    origin_filename: ''
    code_origin: ''
    functionSourceCode: IyBDb3B5cmlnaHQgMjAxOSBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiMKIyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKIyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KIyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiMgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiMKZnJvbSBwYXRobGliIGltcG9ydCBQYXRoCmZyb20gdHlwaW5nIGltcG9ydCBBbnksIFVuaW9uCgppbXBvcnQgbWxydW4KaW1wb3J0IG1scnVuLmRhdGFzdG9yZQppbXBvcnQgbWxydW4udXRpbHMKaW1wb3J0IHBhbmRhcyBhcyBwZApmcm9tIG1scnVuIGltcG9ydCBmZWF0dXJlX3N0b3JlIGFzIGZzCmZyb20gbWxydW4uZGF0YXN0b3JlIGltcG9ydCBEYXRhSXRlbQpmcm9tIG1scnVuLmV4ZWN1dGlvbiBpbXBvcnQgTUxDbGllbnRDdHgKZnJvbSBtbHJ1bi5mcmFtZXdvcmtzLmF1dG9fbWxydW4gaW1wb3J0IEF1dG9NTFJ1bgpmcm9tIG1scnVuLnV0aWxzLmhlbHBlcnMgaW1wb3J0IGNyZWF0ZV9jbGFzcwpmcm9tIHNrbGVhcm4ubW9kZWxfc2VsZWN0aW9uIGltcG9ydCB0cmFpbl90ZXN0X3NwbGl0CgpQYXRoVHlwZSA9IFVuaW9uW3N0ciwgUGF0aF0KCgpjbGFzcyBLV0FyZ3NQcmVmaXhlczoKICAgIE1PREVMX0NMQVNTID0gIkNMQVNTXyIKICAgIEZJVCA9ICJGSVRfIgogICAgVFJBSU4gPSAiVFJBSU5fIgoKCmRlZiBfZ2V0X3N1Yl9kaWN0X2J5X3ByZWZpeChzcmM6IGRpY3QsIHByZWZpeF9rZXk6IHN0cikgLT4gZGljdFtzdHIsIEFueV06CiAgICAiIiIKICAgIENvbGxlY3QgYWxsIHRoZSBrZXlzIGZyb20gdGhlIGdpdmVuIGRpY3QgdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IGFuZCBjcmVhdGVzIGEgbmV3IGRpY3Rpb25hcnkgd2l0aCB0aGVzZQogICAga2V5cy4KCiAgICA6cGFyYW0gc3JjOiAgICAgICAgIFRoZSBzb3VyY2UgZGljdCB0byBleHRyYWN0IHRoZSB2YWx1ZXMgZnJvbS4KICAgIDpwYXJhbSBwcmVmaXhfa2V5OiAgT25seSBrZXlzIHdpdGggdGhpcyBwcmVmaXggd2lsbCBiZSByZXR1cm5lZC4gVGhlIGtleXMgaW4gdGhlIHJlc3VsdCBkaWN0IHdpbGwgYmUgd2l0aG91dCB0aGlzCiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeC4KICAgICIiIgogICAgcmV0dXJuIHsKICAgICAgICBrZXkucmVwbGFjZShwcmVmaXhfa2V5LCAiIik6IHZhbAogICAgICAgIGZvciBrZXksIHZhbCBpbiBzcmMuaXRlbXMoKQogICAgICAgIGlmIGtleS5zdGFydHN3aXRoKHByZWZpeF9rZXkpCiAgICB9CgoKZGVmIF9nZXRfZGF0YWZyYW1lKAogICAgY29udGV4dDogTUxDbGllbnRDdHgsCiAgICBkYXRhc2V0OiBEYXRhSXRlbSwKICAgIGxhYmVsX2NvbHVtbnM6IHN0ciB8IGxpc3Rbc3RyXSB8IE5vbmUgPSBOb25lLAogICAgZHJvcF9jb2x1bW5zOiBzdHIgfCBsaXN0W3N0cl0gfCBpbnQgfCBsaXN0W2ludF0gPSBOb25lLAopIC0+IHR1cGxlW3BkLkRhdGFGcmFtZSwgc3RyIHwgbGlzdFtzdHJdIHwgTm9uZV06CiAgICAiIiIKICAgIEdldHRpbmcgdGhlIERhdGFGcmFtZSBvZiB0aGUgZGF0YXNldCBhbmQgZHJvcCB0aGUgY29sdW1ucyBhY2NvcmRpbmdseS4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICBNTFJ1biBjb250ZXh0LgogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgVGhlIGRhdGFzZXQgdG8gdHJhaW4gdGhlIG1vZGVsIG9uLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIGVpdGhlciBhIGxpc3Qgb2YgbGlzdHMsIGRpY3QsIFVSSSBvciBhIEZlYXR1cmVWZWN0b3IuCiAgICA6cGFyYW0gbGFiZWxfY29sdW1uczogICBUaGUgdGFyZ2V0IGxhYmVsKHMpIG9mIHRoZSBjb2x1bW4ocykgaW4gdGhlIGRhdGFzZXQuIGZvciBSZWdyZXNzaW9uIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzc2lmaWNhdGlvbiB0YXNrcy4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgIHN0ci9pbnQgb3IgYSBsaXN0IG9mIHN0cmluZ3MvaW50cyB0aGF0IHJlcHJlc2VudCB0aGUgY29sdW1uIG5hbWVzL2luZGljZXMgdG8gZHJvcC4KICAgICIiIgogICAgc3RvcmVfdXJpX3ByZWZpeCwgXyA9IG1scnVuLmRhdGFzdG9yZS5wYXJzZV9zdG9yZV91cmkoZGF0YXNldC5hcnRpZmFjdF91cmwpCgogICAgIyBHZXR0aW5nIHRoZSBkYXRhc2V0OgogICAgaWYgbWxydW4udXRpbHMuU3RvcmVQcmVmaXguRmVhdHVyZVZlY3RvciA9PSBzdG9yZV91cmlfcHJlZml4OgogICAgICAgIGxhYmVsX2NvbHVtbnMgPSBsYWJlbF9jb2x1bW5zIG9yIGRhdGFzZXQubWV0YS5zdGF0dXMubGFiZWxfY29sdW1uCiAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbyhmImxhYmVsIGNvbHVtbnM6IHtsYWJlbF9jb2x1bW5zfSIpCiAgICAgICAgIyBGZWF0dXJlVmVjdG9yIGNhc2U6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBmdiA9IG1scnVuLmRhdGFzdG9yZS5nZXRfc3RvcmVfcmVzb3VyY2UoZGF0YXNldC5hcnRpZmFjdF91cmwpCiAgICAgICAgICAgIGRhdGFzZXQgPSBmdi5nZXRfb2ZmbGluZV9mZWF0dXJlcyhkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zKS50b19kYXRhZnJhbWUoKQogICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoKICAgICAgICAgICAgIyBMZWF2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eQogICAgICAgICAgICBkYXRhc2V0ID0gZnMuZ2V0X29mZmxpbmVfZmVhdHVyZXMoCiAgICAgICAgICAgICAgICBkYXRhc2V0Lm1ldGEudXJpLCBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zCiAgICAgICAgICAgICkudG9fZGF0YWZyYW1lKCkKCiAgICBlbGlmIG5vdCBsYWJlbF9jb2x1bW5zOgogICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8oCiAgICAgICAgICAgICJsYWJlbF9jb2x1bW5zIG5vdCBwcm92aWRlZCwgbWFuZGF0b3J5IHdoZW4gZGF0YXNldCBpcyBub3QgYSBGZWF0dXJlVmVjdG9yIgogICAgICAgICkKICAgICAgICByYWlzZSBWYWx1ZUVycm9yCgogICAgZWxpZiBpc2luc3RhbmNlKGRhdGFzZXQsIChsaXN0LCBkaWN0KSk6CiAgICAgICAgIyBsaXN0L2RpY3QgY2FzZToKICAgICAgICBkYXRhc2V0ID0gcGQuRGF0YUZyYW1lKGRhdGFzZXQpCiAgICAgICAgIyBDaGVja2luZyBpZiBkcm9wX2NvbHVtbnMgcHJvdmlkZWQgYnkgaW50ZWdlciB0eXBlOgogICAgICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShkcm9wX2NvbHVtbnMsIHN0cikgb3IgKAogICAgICAgICAgICAgICAgaXNpbnN0YW5jZShkcm9wX2NvbHVtbnMsIGxpc3QpCiAgICAgICAgICAgICAgICBhbmQgYW55KGlzaW5zdGFuY2UoY29sLCBzdHIpIGZvciBjb2wgaW4gZHJvcF9jb2x1bW5zKQogICAgICAgICAgICApOgogICAgICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuZXJyb3IoCiAgICAgICAgICAgICAgICAgICAgImRyb3BfY29sdW1ucyBtdXN0IGJlIGFuIGludGVnZXIvbGlzdCBvZiBpbnRlZ2VycyBpZiBub3QgcHJvdmlkZWQgd2l0aCBhIFVSSS9GZWF0dXJlVmVjdG9yIGRhdGFzZXQiCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yCiAgICAgICAgICAgIGRhdGFzZXQuZHJvcChkcm9wX2NvbHVtbnMsIGF4aXM9MSwgaW5wbGFjZT1UcnVlKQoKICAgIGVsc2U6CiAgICAgICAgIyBzaW1wbGUgVVJMIGNhc2U6CiAgICAgICAgZGF0YXNldCA9IGRhdGFzZXQuYXNfZGYoKQogICAgICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICAgICAgaWYgYWxsKGNvbCBpbiBkYXRhc2V0IGZvciBjb2wgaW4gZHJvcF9jb2x1bW5zKToKICAgICAgICAgICAgICAgIGRhdGFzZXQgPSBkYXRhc2V0LmRyb3AoZHJvcF9jb2x1bW5zLCBheGlzPTEpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKAogICAgICAgICAgICAgICAgICAgICJub3QgYWxsIG9mIHRoZSBjb2x1bW5zIHRvIGRyb3AgaW4gdGhlIGRhdGFzZXQsIGRyb3AgY29sdW1ucyBwcm9jZXNzIHNraXBwZWQiCiAgICAgICAgICAgICAgICApCgogICAgcmV0dXJuIGRhdGFzZXQsIGxhYmVsX2NvbHVtbnMKCgpkZWYgdHJhaW4oCiAgICBjb250ZXh0OiBNTENsaWVudEN0eCwKICAgIGRhdGFzZXQ6IERhdGFJdGVtLAogICAgbW9kZWxfY2xhc3M6IHN0ciwKICAgIGxhYmVsX2NvbHVtbnM6IHN0ciB8IGxpc3Rbc3RyXSB8IE5vbmUgPSBOb25lLAogICAgZHJvcF9jb2x1bW5zOiBsaXN0W3N0cl0gPSBOb25lLAogICAgbW9kZWxfbmFtZTogc3RyID0gIm1vZGVsIiwKICAgIHRhZzogc3RyID0gIiIsCiAgICBzYW1wbGVfc2V0OiBEYXRhSXRlbSA9IE5vbmUsCiAgICB0ZXN0X3NldDogRGF0YUl0ZW0gPSBOb25lLAogICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplOiBmbG9hdCA9IE5vbmUsCiAgICByYW5kb21fc3RhdGU6IGludCA9IE5vbmUsCiAgICBsYWJlbHM6IGRpY3QgPSBOb25lLAogICAgKiprd2FyZ3MsCik6CiAgICAiIiIKICAgIFRyYWluaW5nIGEgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gZGF0YXNldC4KCiAgICBleGFtcGxlOjoKCiAgICAgICAgaW1wb3J0IG1scnVuCgogICAgICAgIHByb2plY3QgPSBtbHJ1bi5nZXRfb3JfY3JlYXRlX3Byb2plY3QoIm15LXByb2plY3QiKQogICAgICAgIHByb2plY3Quc2V0X2Z1bmN0aW9uKCJodWI6Ly9hdXRvX3RyYWluZXIiLCAidHJhaW4iKQogICAgICAgIHRyYWluZXJfcnVuID0gcHJvamVjdC5ydW4oCiAgICAgICAgICAgIG5hbWU9InRyYWluIiwKICAgICAgICAgICAgaGFuZGxlcj0idHJhaW4iLAogICAgICAgICAgICBpbnB1dHM9eyJkYXRhc2V0IjogIi4vcGF0aC90by9kYXRhc2V0LmNzdiJ9LAogICAgICAgICAgICBwYXJhbXM9ewogICAgICAgICAgICAgICAgIm1vZGVsX2NsYXNzIjogInNrbGVhcm4ubGluZWFyX21vZGVsLkxvZ2lzdGljUmVncmVzc2lvbiIsCiAgICAgICAgICAgICAgICAibGFiZWxfY29sdW1ucyI6ICJsYWJlbCIsCiAgICAgICAgICAgICAgICAiZHJvcF9jb2x1bW5zIjogImlkIiwKICAgICAgICAgICAgICAgICJtb2RlbF9uYW1lIjogIm15LW1vZGVsIiwKICAgICAgICAgICAgICAgICJ0YWciOiAidjEuMC4wIiwKICAgICAgICAgICAgICAgICJzYW1wbGVfc2V0IjogIi4vcGF0aC90by9zYW1wbGVfc2V0LmNzdiIsCiAgICAgICAgICAgICAgICAidGVzdF9zZXQiOiAiLi9wYXRoL3RvL3Rlc3Rfc2V0LmNzdiIsCiAgICAgICAgICAgICAgICAiQ0xBU1Nfc29sdmVyIjogImxpYmxpbmVhciIsCiAgICAgICAgICAgIH0sCiAgICAgICAgKQoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgICAgICAgTUxSdW4gY29udGV4dAogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgICAgICAgICBUaGUgZGF0YXNldCB0byB0cmFpbiB0aGUgbW9kZWwgb24uIENhbiBiZSBlaXRoZXIgYSBVUkkgb3IgYSBGZWF0dXJlVmVjdG9yCiAgICA6cGFyYW0gbW9kZWxfY2xhc3M6ICAgICAgICAgICAgIFRoZSBjbGFzcyBvZiB0aGUgbW9kZWwsIGUuZy4gYHNrbGVhcm4ubGluZWFyX21vZGVsLkxvZ2lzdGljUmVncmVzc2lvbmAKICAgIDpwYXJhbSBsYWJlbF9jb2x1bW5zOiAgICAgICAgICAgVGhlIHRhcmdldCBsYWJlbChzKSBvZiB0aGUgY29sdW1uKHMpIGluIHRoZSBkYXRhc2V0LiBmb3IgUmVncmVzc2lvbiBvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzc2lmaWNhdGlvbiB0YXNrcy4gTWFuZGF0b3J5IHdoZW4gZGF0YXNldCBpcyBub3QgYSBGZWF0dXJlVmVjdG9yLgogICAgOnBhcmFtIGRyb3BfY29sdW1uczogICAgICAgICAgICBzdHIgb3IgYSBsaXN0IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgdGhlIGNvbHVtbnMgdG8gZHJvcAogICAgOnBhcmFtIG1vZGVsX25hbWU6ICAgICAgICAgICAgICBUaGUgbW9kZWwncyBuYW1lIHRvIHVzZSBmb3Igc3RvcmluZyB0aGUgbW9kZWwgYXJ0aWZhY3QsIGRlZmF1bHQgdG8gJ21vZGVsJwogICAgOnBhcmFtIHRhZzogICAgICAgICAgICAgICAgICAgICBUaGUgbW9kZWwncyB0YWcgdG8gbG9nIHdpdGgKICAgIDpwYXJhbSBzYW1wbGVfc2V0OiAgICAgICAgICAgICAgQSBzYW1wbGUgc2V0IG9mIGlucHV0cyBmb3IgdGhlIG1vZGVsIGZvciBsb2dnaW5nIGl0cyBzdGF0cyBhbG9uZyB0aGUgbW9kZWwgaW4gZmF2b3VyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIG1vZGVsIG1vbml0b3JpbmcuIENhbiBiZSBlaXRoZXIgYSBVUkkgb3IgYSBGZWF0dXJlVmVjdG9yCiAgICA6cGFyYW0gdGVzdF9zZXQ6ICAgICAgICAgICAgICAgIFRoZSB0ZXN0IHNldCB0byB0cmFpbiB0aGUgbW9kZWwgd2l0aC4KICAgIDpwYXJhbSB0cmFpbl90ZXN0X3NwbGl0X3NpemU6ICAgaWYgdGVzdF9zZXQgd2FzIHByb3ZpZGVkIHRoZW4gdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaG91bGQgYmUgYmV0d2VlbiAwLjAgYW5kIDEuMCBhbmQgcmVwcmVzZW50IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBkYXRhc2V0IHRvIGluY2x1ZGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIHRlc3Qgc3BsaXQuIFRoZSBzaXplIG9mIHRoZSBUcmFpbmluZyBzZXQgaXMgc2V0IHRvIHRoZSBjb21wbGVtZW50IG9mIHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuIERlZmF1bHQgPSAwLjIKICAgIDpwYXJhbSByYW5kb21fc3RhdGU6ICAgICAgICAgICAgUmVsZXZhbnQgb25seSB3aGVuIHVzaW5nIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZS4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSByYW5kb20gc3RhdGUgc2VlZCB0byBzaHVmZmxlIHRoZSBkYXRhLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL3NjaWtpdC1sZWFybi5vcmcvc3RhYmxlL2dsb3NzYXJ5Lmh0bWwjdGVybS1yYW5kb21fc3RhdGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90aWNlIHRoYXQgaGVyZSB3ZSBvbmx5IHBhc3MgaW50ZWdlciB2YWx1ZXMuCiAgICA6cGFyYW0gbGFiZWxzOiAgICAgICAgICAgICAgICAgIExhYmVscyB0byBsb2cgd2l0aCB0aGUgbW9kZWwKICAgIDpwYXJhbSBrd2FyZ3M6ICAgICAgICAgICAgICAgICAgSGVyZSB5b3UgY2FuIHBhc3Mga2V5d29yZCBhcmd1bWVudHMgd2l0aCBwcmVmaXhlcywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3aWxsIGJlIHBhcnNlZCBhbmQgcGFzc2VkIHRvIHRoZSByZWxldmFudCBmdW5jdGlvbiwgYnkgdGhlIGZvbGxvd2luZyBwcmVmaXhlczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgQ0xBU1NfYCAtIGZvciB0aGUgbW9kZWwgY2xhc3MgYXJndW1lbnRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYEZJVF9gIC0gZm9yIHRoZSBgZml0YCBmdW5jdGlvbiBhcmd1bWVudHMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgVFJBSU5fYCAtIGZvciB0aGUgYHRyYWluYCBmdW5jdGlvbiAoaW4geGdiIG9yIGxnYm0gdHJhaW4gZnVuY3Rpb24gLSBmdXR1cmUpCgogICAgIiIiCiAgICAjIFZhbGlkYXRlIGlucHV0czoKICAgICMgQ2hlY2sgaWYgZXhhY3RseSBvbmUgb2YgdGhlbSBpcyBzdXBwbGllZDoKICAgIGlmIHRlc3Rfc2V0IGlzIE5vbmU6CiAgICAgICAgaWYgdHJhaW5fdGVzdF9zcGxpdF9zaXplIGlzIE5vbmU6CiAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8oCiAgICAgICAgICAgICAgICAidGVzdF9zZXQgb3IgdHJhaW5fdGVzdF9zcGxpdF9zaXplIGFyZSBub3QgcHJvdmlkZWQsIHNldHRpbmcgdHJhaW5fdGVzdF9zcGxpdF9zaXplIHRvIDAuMiIKICAgICAgICAgICAgKQogICAgICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUgPSAwLjIKCiAgICBlbGlmIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZToKICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKAogICAgICAgICAgICAidGVzdF9zZXQgcHJvdmlkZWQsIGlnbm9yaW5nIGdpdmVuIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSB2YWx1ZSIKICAgICAgICApCiAgICAgICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplID0gTm9uZQoKICAgICMgR2V0IERhdGFGcmFtZSBieSBVUkwgb3IgYnkgRmVhdHVyZVZlY3RvcjoKICAgIGRhdGFzZXQsIGxhYmVsX2NvbHVtbnMgPSBfZ2V0X2RhdGFmcmFtZSgKICAgICAgICBjb250ZXh0PWNvbnRleHQsCiAgICAgICAgZGF0YXNldD1kYXRhc2V0LAogICAgICAgIGxhYmVsX2NvbHVtbnM9bGFiZWxfY29sdW1ucywKICAgICAgICBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zLAogICAgKQoKICAgICMgR2V0dGluZyB0aGUgc2FtcGxlIHNldDoKICAgIGlmIHNhbXBsZV9zZXQgaXMgTm9uZToKICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKAogICAgICAgICAgICAiU2FtcGxlIHNldCBub3QgZ2l2ZW4sIHVzaW5nIHRoZSB3aG9sZSB0cmFpbmluZyBzZXQgYXMgdGhlIHNhbXBsZSBzZXQiCiAgICAgICAgKQogICAgICAgIHNhbXBsZV9zZXQgPSBkYXRhc2V0CiAgICBlbHNlOgogICAgICAgIHNhbXBsZV9zZXQsIF8gPSBfZ2V0X2RhdGFmcmFtZSgKICAgICAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgICAgICBkYXRhc2V0PXNhbXBsZV9zZXQsCiAgICAgICAgICAgIGxhYmVsX2NvbHVtbnM9bGFiZWxfY29sdW1ucywKICAgICAgICAgICAgZHJvcF9jb2x1bW5zPWRyb3BfY29sdW1ucywKICAgICAgICApCgogICAgIyBQYXJzaW5nIGt3YXJnczoKICAgICMgVE9ETzogVXNlIGluIHhnYiBvciBsZ2JtIHRyYWluIGZ1bmN0aW9uLgogICAgdHJhaW5fa3dhcmdzID0gX2dldF9zdWJfZGljdF9ieV9wcmVmaXgoc3JjPWt3YXJncywgcHJlZml4X2tleT1LV0FyZ3NQcmVmaXhlcy5UUkFJTikKICAgIGZpdF9rd2FyZ3MgPSBfZ2V0X3N1Yl9kaWN0X2J5X3ByZWZpeChzcmM9a3dhcmdzLCBwcmVmaXhfa2V5PUtXQXJnc1ByZWZpeGVzLkZJVCkKICAgIG1vZGVsX2NsYXNzX2t3YXJncyA9IF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KAogICAgICAgIHNyYz1rd2FyZ3MsIHByZWZpeF9rZXk9S1dBcmdzUHJlZml4ZXMuTU9ERUxfQ0xBU1MKICAgICkKCiAgICAjIENoZWNrIGlmIG1vZGVsIG9yIGZ1bmN0aW9uOgogICAgaWYgaGFzYXR0cihtb2RlbF9jbGFzcywgInRyYWluIik6CiAgICAgICAgIyBUT0RPOiBOZWVkIHRvIGNhbGw6IG1vZGVsKCksIGFmdGVyd2FyZHMgdG8gc3RhcnQgdGhlIHRyYWluIGZ1bmN0aW9uLgogICAgICAgICMgbW9kZWwgPSBjcmVhdGVfZnVuY3Rpb24oZiJ7bW9kZWxfY2xhc3N9LnRyYWluIikKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yCiAgICBlbHNlOgogICAgICAgICMgQ3JlYXRpbmcgbW9kZWwgaW5zdGFuY2U6CiAgICAgICAgbW9kZWwgPSBjcmVhdGVfY2xhc3MobW9kZWxfY2xhc3MpKCoqbW9kZWxfY2xhc3Nfa3dhcmdzKQoKICAgIHggPSBkYXRhc2V0LmRyb3AobGFiZWxfY29sdW1ucywgYXhpcz0xKQogICAgeSA9IGRhdGFzZXRbbGFiZWxfY29sdW1uc10KICAgIGlmIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZToKICAgICAgICB4X3RyYWluLCB4X3Rlc3QsIHlfdHJhaW4sIHlfdGVzdCA9IHRyYWluX3Rlc3Rfc3BsaXQoCiAgICAgICAgICAgIHgsIHksIHRlc3Rfc2l6ZT10cmFpbl90ZXN0X3NwbGl0X3NpemUsIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUKICAgICAgICApCiAgICBlbHNlOgogICAgICAgIHhfdHJhaW4sIHlfdHJhaW4gPSB4LCB5CgogICAgICAgIHRlc3Rfc2V0ID0gdGVzdF9zZXQuYXNfZGYoKQogICAgICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICAgICAgdGVzdF9zZXQgPSBkYXRhc2V0LmRyb3AoZHJvcF9jb2x1bW5zLCBheGlzPTEpCgogICAgICAgIHhfdGVzdCwgeV90ZXN0ID0gdGVzdF9zZXQuZHJvcChsYWJlbF9jb2x1bW5zLCBheGlzPTEpLCB0ZXN0X3NldFtsYWJlbF9jb2x1bW5zXQoKICAgIEF1dG9NTFJ1bi5hcHBseV9tbHJ1bigKICAgICAgICBtb2RlbD1tb2RlbCwKICAgICAgICBtb2RlbF9uYW1lPW1vZGVsX25hbWUsCiAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgIHRhZz10YWcsCiAgICAgICAgc2FtcGxlX3NldD1zYW1wbGVfc2V0LAogICAgICAgIHlfY29sdW1ucz1sYWJlbF9jb2x1bW5zLAogICAgICAgIHRlc3Rfc2V0PXRlc3Rfc2V0LAogICAgICAgIHhfdGVzdD14X3Rlc3QsCiAgICAgICAgeV90ZXN0PXlfdGVzdCwKICAgICAgICBhcnRpZmFjdHM9Y29udGV4dC5hcnRpZmFjdHMsCiAgICAgICAgbGFiZWxzPWxhYmVscywKICAgICkKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oZiJ0cmFpbmluZyAne21vZGVsX25hbWV9JyIpCiAgICBtb2RlbC5maXQoeF90cmFpbiwgeV90cmFpbiwgKipmaXRfa3dhcmdzKQoKCmRlZiBldmFsdWF0ZSgKICAgIGNvbnRleHQ6IE1MQ2xpZW50Q3R4LAogICAgbW9kZWw6IHN0ciwKICAgIGRhdGFzZXQ6IG1scnVuLkRhdGFJdGVtLAogICAgZHJvcF9jb2x1bW5zOiBsaXN0W3N0cl0gPSBOb25lLAogICAgbGFiZWxfY29sdW1uczogc3RyIHwgbGlzdFtzdHJdIHwgTm9uZSA9IE5vbmUsCiAgICAqKmt3YXJncywKKToKICAgICIiIgogICAgRXZhbHVhdGluZyBhIG1vZGVsLiBBcnRpZmFjdHMgZ2VuZXJhdGVkIGJ5IHRoZSBNTEhhbmRsZXIuCgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICAgICAgICBNTFJ1biBjb250ZXh0LgogICAgOnBhcmFtIG1vZGVsOiAgICAgICAgICAgICAgICAgICBUaGUgbW9kZWwgU3RvcmUgcGF0aC4KICAgIDpwYXJhbSBkYXRhc2V0OiAgICAgICAgICAgICAgICAgVGhlIGRhdGFzZXQgdG8gZXZhbHVhdGUgdGhlIG1vZGVsIG9uLiBDYW4gYmUgZWl0aGVyIGEgVVJJIG9yIGEgRmVhdHVyZVZlY3Rvci4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgICAgICAgICAgc3RyIG9yIGEgbGlzdCBvZiBzdHJpbmdzIHRoYXQgcmVwcmVzZW50IHRoZSBjb2x1bW5zIHRvIGRyb3AuCiAgICA6cGFyYW0gbGFiZWxfY29sdW1uczogICAgICAgICAgIFRoZSB0YXJnZXQgbGFiZWwocykgb2YgdGhlIGNvbHVtbihzKSBpbiB0aGUgZGF0YXNldC4gZm9yIFJlZ3Jlc3Npb24gb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3NpZmljYXRpb24gdGFza3MuIE1hbmRhdG9yeSB3aGVuIGRhdGFzZXQgaXMgbm90IGEgRmVhdHVyZVZlY3Rvci4KICAgIDpwYXJhbSBrd2FyZ3M6ICAgICAgICAgICAgICAgICAgSGVyZSB5b3UgY2FuIHBhc3Mga2V5d29yZCBhcmd1bWVudHMgdG8gdGhlIHByZWRpY3QgZnVuY3Rpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBSRURJQ1RfIHByZWZpeCBpcyBub3QgcmVxdWlyZWQpLgogICAgIiIiCiAgICAjIEdldCBkYXRhc2V0IGJ5IFVSTCBvciBieSBGZWF0dXJlVmVjdG9yOgogICAgZGF0YXNldCwgbGFiZWxfY29sdW1ucyA9IF9nZXRfZGF0YWZyYW1lKAogICAgICAgIGNvbnRleHQ9Y29udGV4dCwKICAgICAgICBkYXRhc2V0PWRhdGFzZXQsCiAgICAgICAgbGFiZWxfY29sdW1ucz1sYWJlbF9jb2x1bW5zLAogICAgICAgIGRyb3BfY29sdW1ucz1kcm9wX2NvbHVtbnMsCiAgICApCgogICAgIyBQYXJzaW5nIGxhYmVsX2NvbHVtbnM6CiAgICBwYXJzZWRfbGFiZWxfY29sdW1ucyA9IFtdCiAgICBpZiBsYWJlbF9jb2x1bW5zOgogICAgICAgIGxhYmVsX2NvbHVtbnMgPSAoCiAgICAgICAgICAgIGxhYmVsX2NvbHVtbnMgaWYgaXNpbnN0YW5jZShsYWJlbF9jb2x1bW5zLCBsaXN0KSBlbHNlIFtsYWJlbF9jb2x1bW5zXQogICAgICAgICkKICAgICAgICBmb3IgbGMgaW4gbGFiZWxfY29sdW1uczoKICAgICAgICAgICAgaWYgZnMuY29tbW9uLmZlYXR1cmVfc2VwYXJhdG9yIGluIGxjOgogICAgICAgICAgICAgICAgZmVhdHVyZV9zZXRfbmFtZSwgbGFiZWxfbmFtZSwgYWxpYXMgPSBmcy5jb21tb24ucGFyc2VfZmVhdHVyZV9zdHJpbmcobGMpCiAgICAgICAgICAgICAgICBwYXJzZWRfbGFiZWxfY29sdW1ucy5hcHBlbmQoYWxpYXMgb3IgbGFiZWxfbmFtZSkKICAgICAgICBpZiBwYXJzZWRfbGFiZWxfY29sdW1uczoKICAgICAgICAgICAgbGFiZWxfY29sdW1ucyA9IHBhcnNlZF9sYWJlbF9jb2x1bW5zCgogICAgeCA9IGRhdGFzZXQuZHJvcChsYWJlbF9jb2x1bW5zLCBheGlzPTEpCiAgICB5ID0gZGF0YXNldFtsYWJlbF9jb2x1bW5zXQoKICAgICMgTG9hZGluZyB0aGUgbW9kZWwgYW5kIHByZWRpY3Rpbmc6CiAgICBtb2RlbF9oYW5kbGVyID0gQXV0b01MUnVuLmxvYWRfbW9kZWwoCiAgICAgICAgbW9kZWxfcGF0aD1tb2RlbCwgY29udGV4dD1jb250ZXh0LCBtb2RlbF9uYW1lPSJtb2RlbF9MaW5lYXJSZWdyZXNzaW9uIgogICAgKQogICAgQXV0b01MUnVuLmFwcGx5X21scnVuKG1vZGVsX2hhbmRsZXIubW9kZWwsIHlfdGVzdD15LCBtb2RlbF9wYXRoPW1vZGVsKQoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oZiJldmFsdWF0aW5nICd7bW9kZWxfaGFuZGxlci5tb2RlbF9uYW1lfSciKQogICAgbW9kZWxfaGFuZGxlci5tb2RlbC5wcmVkaWN0KHgsICoqa3dhcmdzKQoKCmRlZiBwcmVkaWN0KAogICAgY29udGV4dDogTUxDbGllbnRDdHgsCiAgICBtb2RlbDogc3RyLAogICAgZGF0YXNldDogbWxydW4uRGF0YUl0ZW0sCiAgICBkcm9wX2NvbHVtbnM6IHN0ciB8IGxpc3Rbc3RyXSB8IGludCB8IGxpc3RbaW50XSA9IE5vbmUsCiAgICBsYWJlbF9jb2x1bW5zOiBzdHIgfCBsaXN0W3N0cl0gfCBOb25lID0gTm9uZSwKICAgIHJlc3VsdF9zZXQ6IHN0ciB8IE5vbmUgPSBOb25lLAogICAgKiprd2FyZ3MsCik6CiAgICAiIiIKICAgIFByZWRpY3RpbmcgZGF0YXNldCBieSBhIG1vZGVsLgoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgICAgICAgTUxSdW4gY29udGV4dC4KICAgIDpwYXJhbSBtb2RlbDogICAgICAgICAgICAgICAgICAgVGhlIG1vZGVsIFN0b3JlIHBhdGguCiAgICA6cGFyYW0gZGF0YXNldDogICAgICAgICAgICAgICAgIFRoZSBkYXRhc2V0IHRvIHByZWRpY3QgdGhlIG1vZGVsIG9uLiBDYW4gYmUgZWl0aGVyIGEgVVJJLCBhIEZlYXR1cmVWZWN0b3Igb3IgYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGUgaW4gYSBzaGFwZSBvZiBhIGxpc3QvZGljdC4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBwYXNzaW5nIGEgc2FtcGxlLCBwYXNzIHRoZSBkYXRhc2V0IGFzIGEgZmllbGQgaW4gYHBhcmFtc2AgaW5zdGVhZCBvZiBgaW5wdXRzYC4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgICAgICAgICAgc3RyL2ludCBvciBhIGxpc3Qgb2Ygc3RyaW5ncy9pbnRzIHRoYXQgcmVwcmVzZW50IHRoZSBjb2x1bW4gbmFtZXMvaW5kaWNlcyB0byBkcm9wLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHRoZSBkYXRhc2V0IGlzIGEgbGlzdC9kaWN0IHRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSByZXByZXNlbnRlZCBieSBpbnRlZ2Vycy4KICAgIDpwYXJhbSBsYWJlbF9jb2x1bW5zOiAgICAgICAgICAgVGhlIHRhcmdldCBsYWJlbChzKSBvZiB0aGUgY29sdW1uKHMpIGluIHRoZSBkYXRhc2V0LiBmb3IgUmVncmVzc2lvbiBvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzc2lmaWNhdGlvbiB0YXNrcy4gTWFuZGF0b3J5IHdoZW4gZGF0YXNldCBpcyBub3QgYSBGZWF0dXJlVmVjdG9yLgogICAgOnBhcmFtIHJlc3VsdF9zZXQ6ICAgICAgICAgICAgICBUaGUgZGIga2V5IHRvIHNldCBuYW1lIG9mIHRoZSBwcmVkaWN0aW9uIHJlc3VsdCBhbmQgdGhlIGZpbGVuYW1lLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvICdwcmVkaWN0aW9uJy4KICAgIDpwYXJhbSBrd2FyZ3M6ICAgICAgICAgICAgICAgICAgSGVyZSB5b3UgY2FuIHBhc3Mga2V5d29yZCBhcmd1bWVudHMgdG8gdGhlIHByZWRpY3QgZnVuY3Rpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBSRURJQ1RfIHByZWZpeCBpcyBub3QgcmVxdWlyZWQpLgogICAgIiIiCiAgICAjIEdldCBkYXRhc2V0IGJ5IFVSTCBvciBieSBGZWF0dXJlVmVjdG9yOgogICAgZGF0YXNldCwgbGFiZWxfY29sdW1ucyA9IF9nZXRfZGF0YWZyYW1lKAogICAgICAgIGNvbnRleHQ9Y29udGV4dCwKICAgICAgICBkYXRhc2V0PWRhdGFzZXQsCiAgICAgICAgbGFiZWxfY29sdW1ucz1sYWJlbF9jb2x1bW5zLAogICAgICAgIGRyb3BfY29sdW1ucz1kcm9wX2NvbHVtbnMsCiAgICApCgogICAgIyBsb2FkaW5nIHRoZSBtb2RlbCwgYW5kIGdldHRpbmcgdGhlIG1vZGVsIGhhbmRsZXI6CiAgICBtb2RlbF9oYW5kbGVyID0gQXV0b01MUnVuLmxvYWRfbW9kZWwobW9kZWxfcGF0aD1tb2RlbCwgY29udGV4dD1jb250ZXh0KQoKICAgICMgRHJvcHBpbmcgbGFiZWwgY29sdW1ucyBpZiBuZWNlc3Nhcnk6CiAgICBpZiBub3QgbGFiZWxfY29sdW1uczoKICAgICAgICBsYWJlbF9jb2x1bW5zID0gW10KICAgIGVsaWYgaXNpbnN0YW5jZShsYWJlbF9jb2x1bW5zLCBzdHIpOgogICAgICAgIGxhYmVsX2NvbHVtbnMgPSBbbGFiZWxfY29sdW1uc10KCiAgICAjIFByZWRpY3Rpbmc6CiAgICBjb250ZXh0LmxvZ2dlci5pbmZvKGYibWFraW5nIHByZWRpY3Rpb24gYnkgJ3ttb2RlbF9oYW5kbGVyLm1vZGVsX25hbWV9JyIpCiAgICB5X3ByZWQgPSBtb2RlbF9oYW5kbGVyLm1vZGVsLnByZWRpY3QoZGF0YXNldCwgKiprd2FyZ3MpCgogICAgIyBQcmVwYXJpbmcgYW5kIHZhbGlkYXRpbmcgbGFiZWwgY29sdW1ucyBmb3IgdGhlIGRhdGFmcmFtZSBvZiB0aGUgcHJlZGljdGlvbiByZXN1bHQ6CiAgICBudW1fcHJlZGljdGVkID0gMSBpZiBsZW4oeV9wcmVkLnNoYXBlKSA9PSAxIGVsc2UgeV9wcmVkLnNoYXBlWzFdCgogICAgaWYgbnVtX3ByZWRpY3RlZCA+IGxlbihsYWJlbF9jb2x1bW5zKToKICAgICAgICBpZiBudW1fcHJlZGljdGVkID09IDE6CiAgICAgICAgICAgIGxhYmVsX2NvbHVtbnMgPSBbInByZWRpY3RlZCBsYWJlbHMiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGxhYmVsX2NvbHVtbnMuZXh0ZW5kKAogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICAgIGYicHJlZGljdGVkX2xhYmVsX3tpICsgMSArIGxlbihsYWJlbF9jb2x1bW5zKX0iCiAgICAgICAgICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobnVtX3ByZWRpY3RlZCAtIGxlbihsYWJlbF9jb2x1bW5zKSkKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgKQogICAgZWxpZiBudW1fcHJlZGljdGVkIDwgbGVuKGxhYmVsX2NvbHVtbnMpOgogICAgICAgIGNvbnRleHQubG9nZ2VyLmVycm9yKAogICAgICAgICAgICBmIm51bWJlciBvZiBwcmVkaWN0ZWQgbGFiZWxzOiB7bnVtX3ByZWRpY3RlZH0gaXMgc21hbGxlciB0aGFuIG51bWJlciBvZiBsYWJlbCBjb2x1bW5zOiB7bGVuKGxhYmVsX2NvbHVtbnMpfSIKICAgICAgICApCiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcgoKICAgIGFydGlmYWN0X25hbWUgPSByZXN1bHRfc2V0IG9yICJwcmVkaWN0aW9uIgogICAgbGFiZWxzX2luc2lkZV9kZiA9IHNldChsYWJlbF9jb2x1bW5zKSAmIHNldChkYXRhc2V0LmNvbHVtbnMudG9saXN0KCkpCiAgICBpZiBsYWJlbHNfaW5zaWRlX2RmOgogICAgICAgIGNvbnRleHQubG9nZ2VyLmVycm9yKAogICAgICAgICAgICBmIlRoZSBsYWJlbHM6IHtsYWJlbHNfaW5zaWRlX2RmfSBhcmUgYWxyZWFkeSBleGlzdGVkIGluIHRoZSBkYXRhZnJhbWUiCiAgICAgICAgKQogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IKICAgIHByZWRfZGYgPSBwZC5jb25jYXQoW2RhdGFzZXQsIHBkLkRhdGFGcmFtZSh5X3ByZWQsIGNvbHVtbnM9bGFiZWxfY29sdW1ucyldLCBheGlzPTEpCiAgICBjb250ZXh0LmxvZ19kYXRhc2V0KGFydGlmYWN0X25hbWUsIHByZWRfZGYsIGRiX2tleT1yZXN1bHRfc2V0KQo=
  description: Automatic train, evaluate and predict functions for the ML frameworks
    - Scikit-Learn, XGBoost and LightGBM.
verbose: false
kind: job
metadata:
  tag: ''
  categories:
  - machine-learning
  - model-training
  name: auto-trainer
