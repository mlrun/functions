spec:
  entry_points:
    generate_multi_speakers_audio:
      name: generate_multi_speakers_audio
      has_kwargs: false
      doc: Generate audio files from text files.
      outputs:
      - doc: 'A tuple of: - The output directory path. - The generated audio files
          dataframe. - The errors'' dictionary.'
        type: Tuple[str, pd.DataFrame, dict]
      lineno: 39
      has_varargs: false
      parameters:
      - name: data_path
        type: str
        doc: Path to the text file or directory containing the text files to generate
          audio from.
      - name: speakers
        type: Union[List[str], Dict[str, int]]
        doc: List / Dict of speakers to generate audio for. If a list is given, the
          speakers will be assigned to channels in the order given. If dictionary,
          the keys will be the speakers and the values will be the channels.
      - name: available_voices
        type: List[str]
        doc: 'List of available voices to use for the generation. See here for the
          available voices for bark engine: https://suno-ai.notion.site/8b8e8749ed514b0cbf3f699013548683?v=bc67cff786b04b50b3ceb756fd05f68c
          See here for the available voices for openai engine: https://beta.openai.com/docs/api-reference/speech'
      - name: engine
        type: str
        doc: The engine to use for the generation. Select either "bark" or "openai".
          Default is "openai".
        default: openai
      - name: output_directory
        type: str
        doc: Path to the directory to save the generated audio files to.
        default: null
      - name: use_gpu
        type: Optional[bool]
        doc: Whether to use the GPU for the generation. Supported only in "bark" engine.
        default: null
      - name: use_small_models
        type: Optional[bool]
        doc: Whether to use the small models for the generation. Supported only in
          "bark" engine.
        default: null
      - name: offload_cpu
        type: Optional[bool]
        doc: To reduce the memory footprint, the models can be offloaded to the CPU
          after loading. Supported only in "bark" engine.
        default: null
      - name: model
        type: Optional[str]
        doc: Which model to use for the generation. Supported only in "openai" engine.
          Default is "tts-1".
        default: null
      - name: speed
        type: Optional[float]
        doc: The speed of the generated audio. Select a value from `0.25` to `4.0`.
          `1.0` is the default.
        default: null
      - name: sample_rate
        type: int
        doc: The sampling rate of the generated audio.
        default: 16000
      - name: file_format
        type: str
        doc: The format of the generated audio files.
        default: wav
      - name: verbose
        type: bool
        doc: Whether to print the progress of the generation.
        default: true
      - name: bits_per_sample
        type: Optional[int]
        doc: Changes the bit depth for the supported formats. Supported only in "wav"
          or "flac" formats.
        default: null
  image: ''
  description: Generate audio file from text using different speakers
  disable_auto_mount: false
  command: ''
  default_handler: generate_multi_speakers_audio
  build:
    base_image: mlrun/mlrun
    code_origin: ''
    origin_filename: ''
    functionSourceCode: IyBDb3B5cmlnaHQgMjAyMyBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAojCiMgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQojIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiMgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiMgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAojIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgppbXBvcnQgaW1wb3J0bGliCmltcG9ydCBpbwppbXBvcnQgbG9nZ2luZwppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHJhbmRvbQppbXBvcnQgdGVtcGZpbGUKZnJvbSBhYmMgaW1wb3J0IEFCQywgYWJzdHJhY3RtZXRob2QKZnJvbSB0eXBpbmcgaW1wb3J0IERpY3QsIExpc3QsIE9wdGlvbmFsLCBUdXBsZSwgVW5pb24KCmltcG9ydCBudW1weSBhcyBucAppbXBvcnQgcGFuZGFzIGFzIHBkCmltcG9ydCB0b3JjaAppbXBvcnQgdG9yY2hhdWRpbwppbXBvcnQgdHFkbQpmcm9tIHB5ZHViIGltcG9ydCBBdWRpb1NlZ21lbnQKCiMgR2V0IHRoZSBnbG9iYWwgbG9nZ2VyOgpfTE9HR0VSID0gbG9nZ2luZy5nZXRMb2dnZXIoKQoKT1BFTkFJX0FQSV9LRVkgPSAiT1BFTkFJX0FQSV9LRVkiCk9QRU5BSV9CQVNFX1VSTCA9ICJPUEVOQUlfQVBJX0JBU0UiClNBTVBMRV9SQVRFID0gMjQwMDAKCgpkZWYgZ2VuZXJhdGVfbXVsdGlfc3BlYWtlcnNfYXVkaW8oCiAgICBkYXRhX3BhdGg6IHN0ciwKICAgIHNwZWFrZXJzOiBVbmlvbltMaXN0W3N0cl0sIERpY3Rbc3RyLCBpbnRdXSwKICAgIGF2YWlsYWJsZV92b2ljZXM6IExpc3Rbc3RyXSwKICAgIGVuZ2luZTogc3RyID0gIm9wZW5haSIsCiAgICBvdXRwdXRfZGlyZWN0b3J5OiBzdHIgPSBOb25lLAogICAgdXNlX2dwdTogT3B0aW9uYWxbYm9vbF0gPSBOb25lLAogICAgdXNlX3NtYWxsX21vZGVsczogT3B0aW9uYWxbYm9vbF0gPSBOb25lLAogICAgb2ZmbG9hZF9jcHU6IE9wdGlvbmFsW2Jvb2xdID0gTm9uZSwKICAgIG1vZGVsOiBPcHRpb25hbFtzdHJdID0gTm9uZSwKICAgIHNwZWVkOiBPcHRpb25hbFtmbG9hdF0gPSBOb25lLAogICAgc2FtcGxlX3JhdGU6IGludCA9IDE2MDAwLAogICAgZmlsZV9mb3JtYXQ6IHN0ciA9ICJ3YXYiLAogICAgdmVyYm9zZTogYm9vbCA9IFRydWUsCiAgICBiaXRzX3Blcl9zYW1wbGU6IE9wdGlvbmFsW2ludF0gPSBOb25lLAopIC0+IFR1cGxlW3N0ciwgcGQuRGF0YUZyYW1lLCBkaWN0XToKICAgICIiIgogICAgR2VuZXJhdGUgYXVkaW8gZmlsZXMgZnJvbSB0ZXh0IGZpbGVzLgoKICAgIDpwYXJhbSBkYXRhX3BhdGg6ICAgICAgICAgICBQYXRoIHRvIHRoZSB0ZXh0IGZpbGUgb3IgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIHRleHQgZmlsZXMgdG8gZ2VuZXJhdGUgYXVkaW8gZnJvbS4KICAgIDpwYXJhbSBzcGVha2VyczogICAgICAgICAgICBMaXN0IC8gRGljdCBvZiBzcGVha2VycyB0byBnZW5lcmF0ZSBhdWRpbyBmb3IuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSBsaXN0IGlzIGdpdmVuLCB0aGUgc3BlYWtlcnMgd2lsbCBiZSBhc3NpZ25lZCB0byBjaGFubmVscyBpbiB0aGUgb3JkZXIgZ2l2ZW4uCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZGljdGlvbmFyeSwgdGhlIGtleXMgd2lsbCBiZSB0aGUgc3BlYWtlcnMgYW5kIHRoZSB2YWx1ZXMgd2lsbCBiZSB0aGUgY2hhbm5lbHMuCiAgICA6cGFyYW0gYXZhaWxhYmxlX3ZvaWNlczogICAgTGlzdCBvZiBhdmFpbGFibGUgdm9pY2VzIHRvIHVzZSBmb3IgdGhlIGdlbmVyYXRpb24uCiAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBoZXJlIGZvciB0aGUgYXZhaWxhYmxlIHZvaWNlcyBmb3IgYmFyayBlbmdpbmU6CiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vc3Vuby1haS5ub3Rpb24uc2l0ZS84YjhlODc0OWVkNTE0YjBjYmYzZjY5OTAxMzU0ODY4Mz92PWJjNjdjZmY3ODZiMDRiNTBiM2NlYjc1NmZkMDVmNjhjCiAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBoZXJlIGZvciB0aGUgYXZhaWxhYmxlIHZvaWNlcyBmb3Igb3BlbmFpIGVuZ2luZToKICAgICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9iZXRhLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3NwZWVjaAogICAgOnBhcmFtIGVuZ2luZTogICAgICAgICAgICAgIFRoZSBlbmdpbmUgdG8gdXNlIGZvciB0aGUgZ2VuZXJhdGlvbi4gU2VsZWN0IGVpdGhlciAiYmFyayIgb3IgIm9wZW5haSIuIERlZmF1bHQgaXMgIm9wZW5haSIuCiAgICA6cGFyYW0gb3V0cHV0X2RpcmVjdG9yeTogICAgUGF0aCB0byB0aGUgZGlyZWN0b3J5IHRvIHNhdmUgdGhlIGdlbmVyYXRlZCBhdWRpbyBmaWxlcyB0by4KICAgIDpwYXJhbSB1c2VfZ3B1OiAgICAgICAgICAgICBXaGV0aGVyIHRvIHVzZSB0aGUgR1BVIGZvciB0aGUgZ2VuZXJhdGlvbi4gU3VwcG9ydGVkIG9ubHkgaW4gImJhcmsiIGVuZ2luZS4KICAgIDpwYXJhbSB1c2Vfc21hbGxfbW9kZWxzOiAgICBXaGV0aGVyIHRvIHVzZSB0aGUgc21hbGwgbW9kZWxzIGZvciB0aGUgZ2VuZXJhdGlvbi4gU3VwcG9ydGVkIG9ubHkgaW4gImJhcmsiIGVuZ2luZS4KICAgIDpwYXJhbSBvZmZsb2FkX2NwdTogICAgICAgICBUbyByZWR1Y2UgdGhlIG1lbW9yeSBmb290cHJpbnQsIHRoZSBtb2RlbHMgY2FuIGJlIG9mZmxvYWRlZCB0byB0aGUgQ1BVIGFmdGVyIGxvYWRpbmcuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VwcG9ydGVkIG9ubHkgaW4gImJhcmsiIGVuZ2luZS4KICAgIDpwYXJhbSBtb2RlbDogICAgICAgICAgICAgICBXaGljaCBtb2RlbCB0byB1c2UgZm9yIHRoZSBnZW5lcmF0aW9uLiBTdXBwb3J0ZWQgb25seSBpbiAib3BlbmFpIiBlbmdpbmUuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAidHRzLTEiLgogICAgOnBhcmFtIHNwZWVkOiAgICAgICAgICAgICAgIFRoZSBzcGVlZCBvZiB0aGUgZ2VuZXJhdGVkIGF1ZGlvLiBTZWxlY3QgYSB2YWx1ZSBmcm9tIGAwLjI1YCB0byBgNC4wYC4gYDEuMGAgaXMgdGhlIGRlZmF1bHQuCiAgICA6cGFyYW0gc2FtcGxlX3JhdGU6ICAgICAgICAgVGhlIHNhbXBsaW5nIHJhdGUgb2YgdGhlIGdlbmVyYXRlZCBhdWRpby4KICAgIDpwYXJhbSBmaWxlX2Zvcm1hdDogICAgICAgICBUaGUgZm9ybWF0IG9mIHRoZSBnZW5lcmF0ZWQgYXVkaW8gZmlsZXMuCiAgICA6cGFyYW0gdmVyYm9zZTogICAgICAgICAgICAgV2hldGhlciB0byBwcmludCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGdlbmVyYXRpb24uCiAgICA6cGFyYW0gYml0c19wZXJfc2FtcGxlOiAgICAgQ2hhbmdlcyB0aGUgYml0IGRlcHRoIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHMuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VwcG9ydGVkIG9ubHkgaW4gIndhdiIgb3IgImZsYWMiIGZvcm1hdHMuCgogICAgOnJldHVybnM6ICAgICAgICAgICAgICAgICAgIEEgdHVwbGUgb2Y6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3V0cHV0IGRpcmVjdG9yeSBwYXRoLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGdlbmVyYXRlZCBhdWRpbyBmaWxlcyBkYXRhZnJhbWUuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgZXJyb3JzJyBkaWN0aW9uYXJ5LgogICAgIiIiCgogICAgZ2xvYmFsIF9MT0dHRVIKICAgIF9MT0dHRVIgPSBfZ2V0X2xvZ2dlcigpCiAgICAjIEdldCB0aGUgaW5wdXQgdGV4dCBmaWxlcyB0byB0dXJuIHRvIGF1ZGlvOgogICAgZGF0YV9wYXRoID0gcGF0aGxpYi5QYXRoKGRhdGFfcGF0aCkuYWJzb2x1dGUoKQogICAgdGV4dF9maWxlcyA9IF9nZXRfdGV4dF9maWxlcyhkYXRhX3BhdGg9ZGF0YV9wYXRoKQoKCiAgICAjIFByZXBhcmUgdGhlIHNwZWVjaCBlbmdpbmU6CiAgICBlbmdpbmUgPSBfZ2V0X2VuZ2luZSgKICAgICAgICBlbmdpbmU9ZW5naW5lLAogICAgICAgIHVzZV9ncHU9dXNlX2dwdSwKICAgICAgICB1c2Vfc21hbGxfbW9kZWxzPXVzZV9zbWFsbF9tb2RlbHMsCiAgICAgICAgb2ZmbG9hZF9jcHU9b2ZmbG9hZF9jcHUsCiAgICAgICAgbW9kZWw9bW9kZWwsCiAgICAgICAgZmlsZV9mb3JtYXQ9ZmlsZV9mb3JtYXQsCiAgICAgICAgc3BlZWQ9c3BlZWQKICAgICkKCiAgICAjIENoZWNrIGZvciBwZXIgY2hhbm5lbCBnZW5lcmF0aW9uOgogICAgaWYgaXNpbnN0YW5jZShzcGVha2VycywgZGljdCk6CiAgICAgICAgc3BlYWtlcl9wZXJfY2hhbm5lbCA9IFRydWUKICAgICAgICAjIFNvcnQgdGhlIGdpdmVuIHNwZWFrZXJzIGJ5IGNoYW5uZWxzOgogICAgICAgIHNwZWFrZXJzID0gewogICAgICAgICAgICBzcGVha2VyOiBjaGFubmVsCiAgICAgICAgICAgIGZvciBzcGVha2VyLCBjaGFubmVsIGluIHNvcnRlZChzcGVha2Vycy5pdGVtcygpLCBrZXk9bGFtYmRhIGl0ZW06IGl0ZW1bMV0pCiAgICAgICAgfQogICAgZWxzZToKICAgICAgICBzcGVha2VyX3Blcl9jaGFubmVsID0gRmFsc2UKCiAgICAjIFByZXBhcmUgdGhlIHJlc2FtcGxpbmcgbW9kdWxlOgogICAgcmVzYW1wbGVyID0gdG9yY2hhdWRpby50cmFuc2Zvcm1zLlJlc2FtcGxlKAogICAgICAgIG9yaWdfZnJlcT1TQU1QTEVfUkFURSwgbmV3X2ZyZXE9c2FtcGxlX3JhdGUsIGR0eXBlPXRvcmNoLmZsb2F0MzIKICAgICkKCiAgICAjIFByZXBhcmUgdGhlIGdhcCBiZXR3ZWVuIGVhY2ggc3BlYWtlcjoKICAgIGdhcF9iZXR3ZWVuX3NwZWFrZXJzID0gbnAuemVyb3MoaW50KDAuNSAqIFNBTVBMRV9SQVRFKSkKCiAgICAjIFByZXBhcmUgdGhlIHN1Y2Nlc3NlcyBkYXRhZnJhbWUgYW5kIGVycm9ycyBkaWN0aW9uYXJ5IHRvIGJlIHJldHVybmVkOgogICAgc3VjY2Vzc2VzID0gW10KICAgIGVycm9ycyA9IHt9CgogICAgIyBDcmVhdGUgdGhlIG91dHB1dCBkaXJlY3Rvcnk6CiAgICBpZiBvdXRwdXRfZGlyZWN0b3J5IGlzIE5vbmU6CiAgICAgICAgb3V0cHV0X2RpcmVjdG9yeSA9IHRlbXBmaWxlLm1rZHRlbXAoKQogICAgb3V0cHV0X2RpcmVjdG9yeSA9IHBhdGhsaWIuUGF0aChvdXRwdXRfZGlyZWN0b3J5KQogICAgaWYgbm90IG91dHB1dF9kaXJlY3RvcnkuZXhpc3RzKCk6CiAgICAgICAgb3V0cHV0X2RpcmVjdG9yeS5ta2RpcihleGlzdF9vaz1UcnVlLCBwYXJlbnRzPVRydWUpCgogICAgIyBTdGFydCBnZW5lcmF0aW5nIGF1ZGlvOgogICAgIyBHbyBvdmVyIHRoZSBhdWRpbyBmaWxlcyBhbmQgdHJhbnNjcmliZToKICAgIGZvciB0ZXh0X2ZpbGUgaW4gdHFkbS50cWRtKAogICAgICAgIHRleHRfZmlsZXMsIGRlc2M9IkdlbmVyYXRpbmciLCB1bml0PSJmaWxlIiwgZGlzYWJsZT1ub3QgdmVyYm9zZQogICAgKToKCiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIFJhbmRvbWl6ZSB2b2ljZXMgZm9yIGVhY2ggc3BlYWtlcjoKICAgICAgICAgICAgY2hvc2VuX3ZvaWNlcyA9IHt9CiAgICAgICAgICAgIGF2YWlsYWJsZV92b2ljZXNfY29weSA9IGF2YWlsYWJsZV92b2ljZXMuY29weSgpCiAgICAgICAgICAgIGZvciBzcGVha2VyIGluIHNwZWFrZXJzOgogICAgICAgICAgICAgICAgdm9pY2UgPSByYW5kb20uY2hvaWNlKGF2YWlsYWJsZV92b2ljZXNfY29weSkKICAgICAgICAgICAgICAgIGNob3Nlbl92b2ljZXNbc3BlYWtlcl0gPSB2b2ljZQogICAgICAgICAgICAgICAgYXZhaWxhYmxlX3ZvaWNlc19jb3B5LnJlbW92ZSh2b2ljZSkKICAgICAgICAgICAgIyBSZWFkIHRleHQ6CiAgICAgICAgICAgIHdpdGggb3Blbih0ZXh0X2ZpbGUsICJyIikgYXMgZnA6CiAgICAgICAgICAgICAgICB0ZXh0ID0gZnAucmVhZCgpCiAgICAgICAgICAgICMgUHJlcGFyZSBhIGhvbGRlciBmb3IgYWxsIHRoZSBnZW5lcmF0ZWQgcGllY2VzIChpZiBwZXIgY2hhbm5lbCBlYWNoIHNwZWFrZXIgd2lsbCBoYXZlIGl0cyBvd24pOgogICAgICAgICAgICBhdWRpb19waWVjZXMgPSAoCiAgICAgICAgICAgICAgICB7c3BlYWtlcjogW10gZm9yIHNwZWFrZXIgaW4gc3BlYWtlcnN9CiAgICAgICAgICAgICAgICBpZiBzcGVha2VyX3Blcl9jaGFubmVsCiAgICAgICAgICAgICAgICBlbHNlIHsiYWxsIjogW119CiAgICAgICAgICAgICkKCiAgICAgICAgICAgICMgR2VuZXJhdGUgYXVkaW8gcGVyIGxpbmU6CiAgICAgICAgICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXRsaW5lcygpOgogICAgICAgICAgICAgICAgIyBWYWxpZGF0ZSBsaW5lIGlzIGluIGNvcnJlY3Qgc3BlYWtlciBmb3JtYXQ6CgogICAgICAgICAgICAgICAgaWYgIjogIiBub3QgaW4gbGluZToKICAgICAgICAgICAgICAgICAgICBpZiB2ZXJib3NlOgogICAgICAgICAgICAgICAgICAgICAgICBfTE9HR0VSLndhcm5pbmcoZiJTa2lwcGluZyBsaW5lOiB7bGluZX0iKQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAjIFNwbGl0IGxpbmUgdG8gc3BlYWtlciBhbmQgaGlzIHdvcmRzOgogICAgICAgICAgICAgICAgY3VycmVudF9zcGVha2VyLCBzZW50ZW5jZXMgPSBsaW5lLnNwbGl0KCI6ICIsIDEpCiAgICAgICAgICAgICAgICAjIFZhbGlkYXRlIHNwZWFrZXIgaXMga25vd246CiAgICAgICAgICAgICAgICBpZiBjdXJyZW50X3NwZWFrZXIgbm90IGluIHNwZWFrZXJzOgogICAgICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIGYiVW5rbm93biBzcGVha2VyOiB7Y3VycmVudF9zcGVha2VyfS4gR2l2ZW4gc3BlYWtlcnMgYXJlOiB7c3BlYWtlcnN9IgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIGZvciBzZW50ZW5jZSBpbiBfc3BsaXRfbGluZShsaW5lPXNlbnRlbmNlcyk6CiAgICAgICAgICAgICAgICAgICAgIyBHZW5lcmF0ZSB3b3JkcyBhdWRpbzoKICAgICAgICAgICAgICAgICAgICBhdWRpbyA9IGVuZ2luZS5fZ2VuZXJhdGVfYXVkaW8oCiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9c2VudGVuY2UsCiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWNlPWNob3Nlbl92b2ljZXNbY3VycmVudF9zcGVha2VyXSwKICAgICAgICAgICAgICAgICAgICApCgogICAgICAgICAgICAgICAgICAgIGlmIHNwZWFrZXJfcGVyX2NoYW5uZWw6CiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVuY2UgPSBucC56ZXJvc19saWtlKGF1ZGlvKQogICAgICAgICAgICAgICAgICAgICAgICBmb3Igc3BlYWtlciBpbiBhdWRpb19waWVjZXMua2V5cygpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3BlYWtlciA9PSBjdXJyZW50X3NwZWFrZXI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9fcGllY2VzW3NwZWFrZXJdICs9IFthdWRpbywgZ2FwX2JldHdlZW5fc3BlYWtlcnNdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvX3BpZWNlc1tzcGVha2VyXSArPSBbc2lsZW5jZSwgZ2FwX2JldHdlZW5fc3BlYWtlcnNdCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9fcGllY2VzWyJhbGwiXSArPSBbYXVkaW8sIGdhcF9iZXR3ZWVuX3NwZWFrZXJzXQogICAgICAgICAgICAjIENvbnN0cnVjdCBhIHNpbmdsZSBhdWRpbyBhcnJheSBmcm9tIGFsbCB0aGUgcGllY2VzIGFuZCBjaGFubmVsczoKCiAgICAgICAgICAgIGF1ZGlvID0gbnAudnN0YWNrKAogICAgICAgICAgICAgICAgW25wLmNvbmNhdGVuYXRlKGF1ZGlvX3BpZWNlc1tzcGVha2VyXSkgZm9yIHNwZWFrZXIgaW4gc3BlYWtlcnNdCiAgICAgICAgICAgICkuYXN0eXBlKGR0eXBlPW5wLmZsb2F0MzIpCiAgICAgICAgICAgICMgUmVzYW1wbGU6CiAgICAgICAgICAgIGF1ZGlvID0gdG9yY2guZnJvbV9udW1weShhdWRpbykKICAgICAgICAgICAgYXVkaW8gPSByZXNhbXBsZXIoYXVkaW8pCiAgICAgICAgICAgICMgU2F2ZSB0byBhdWRpbyBmaWxlOgogICAgICAgICAgICBhdWRpb19maWxlID0gb3V0cHV0X2RpcmVjdG9yeSAvIGYie3RleHRfZmlsZS5zdGVtfS57ZmlsZV9mb3JtYXR9IgoKICAgICAgICAgICAgdG9yY2hhdWRpby5zYXZlKAogICAgICAgICAgICAgICAgdXJpPXN0cihhdWRpb19maWxlKSwKICAgICAgICAgICAgICAgIHNyYz1hdWRpbywKICAgICAgICAgICAgICAgIHNhbXBsZV9yYXRlPXNhbXBsZV9yYXRlLAogICAgICAgICAgICAgICAgZm9ybWF0PWZpbGVfZm9ybWF0LAogICAgICAgICAgICAgICAgYml0c19wZXJfc2FtcGxlPWJpdHNfcGVyX3NhbXBsZSwKICAgICAgICAgICAgKQoKICAgICAgICAgICAgIyBDb2xsZWN0IHRvIHRoZSBzdWNjZXNzZXM6CiAgICAgICAgICAgIHN1Y2Nlc3Nlcy5hcHBlbmQoW3RleHRfZmlsZS5uYW1lLCBhdWRpb19maWxlLm5hbWVdKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXhjZXB0aW9uOgogICAgICAgICAgICAjIE5vdGUgdGhlIGV4Y2VwdGlvbiBhcyBlcnJvciBpbiB0aGUgZGljdGlvbmFyeToKICAgICAgICAgICAgaWYgdmVyYm9zZToKICAgICAgICAgICAgICAgIF9MT0dHRVIud2FybmluZyhmIkVycm9yIGluIGZpbGU6ICd7dGV4dF9maWxlLm5hbWV9JyIpCiAgICAgICAgICAgIHByaW50KGV4Y2VwdGlvbikKICAgICAgICAgICAgZXJyb3JzW3RleHRfZmlsZS5uYW1lXSA9IHN0cihleGNlcHRpb24pCgogICAgIyBDb25zdHJ1Y3QgdGhlIHRyYW5zbGF0aW9ucyBkYXRhZnJhbWU6CiAgICBzdWNjZXNzZXMgPSBwZC5EYXRhRnJhbWUoCiAgICAgICAgc3VjY2Vzc2VzLAogICAgICAgIGNvbHVtbnM9WyJ0ZXh0X2ZpbGUiLCAiYXVkaW9fZmlsZSJdLAogICAgKQoKICAgICMgUHJpbnQgdGhlIGhlYWQgb2YgdGhlIHByb2R1Y2VkIGRhdGFmcmFtZSBhbmQgcmV0dXJuOgogICAgaWYgdmVyYm9zZToKICAgICAgICBfTE9HR0VSLmluZm8oCiAgICAgICAgICAgIGYiRG9uZSAoe3N1Y2Nlc3Nlcy5zaGFwZVswXX0ve2xlbih0ZXh0X2ZpbGVzKX0pXG4iCiAgICAgICAgICAgIGYiVHJhbnNsYXRpb25zIHN1bW1hcnk6XG4iCiAgICAgICAgICAgIGYie3N1Y2Nlc3Nlcy5oZWFkKCl9IgogICAgICAgICkKICAgIHJldHVybiBzdHIob3V0cHV0X2RpcmVjdG9yeSksIHN1Y2Nlc3NlcywgZXJyb3JzCgoKY2xhc3MgU3BlZWNoRW5naW5lKEFCQyk6CiAgICBAYWJzdHJhY3RtZXRob2QKICAgIGRlZiBfZ2VuZXJhdGVfYXVkaW8oc2VsZiwgdGV4dDogc3RyLCB2b2ljZTogc3RyKSAtPiBucC5uZGFycmF5OgogICAgICAgIHBhc3MKCgpjbGFzcyBCYXJrRW5naW5lKFNwZWVjaEVuZ2luZSk6CiAgICBkZWYgX19pbml0X18oc2VsZiwgdXNlX2dwdTogYm9vbCA9IFRydWUsIHVzZV9zbWFsbF9tb2RlbHM6IGJvb2wgPSBGYWxzZSwgb2ZmbG9hZF9jcHU6IGJvb2wgPSBGYWxzZSk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLmJhcmsgPSBpbXBvcnRsaWIuaW1wb3J0X21vZHVsZSgiYmFyayIpCiAgICAgICAgZXhjZXB0IEltcG9ydEVycm9yOgogICAgICAgICAgICByYWlzZSBJbXBvcnRFcnJvcigKICAgICAgICAgICAgICAgICJUaGUgJ2JhcmsnIGxpYnJhcnkgaXMgcmVxdWlyZWQgZm9yIHRoZSBCYXJrRW5naW5lLiBQbGVhc2UgaW5zdGFsbCBpdCB1c2luZyAncGlwIGluc3RhbGwgYmFyay1haScuIgogICAgICAgICAgICApCgogICAgICAgIHNlbGYuYmFyay5wcmVsb2FkX21vZGVscygKICAgICAgICAgICAgdGV4dF91c2VfZ3B1PXVzZV9ncHUsCiAgICAgICAgICAgIHRleHRfdXNlX3NtYWxsPXVzZV9zbWFsbF9tb2RlbHMsCiAgICAgICAgICAgIGNvYXJzZV91c2VfZ3B1PXVzZV9ncHUsCiAgICAgICAgICAgIGNvYXJzZV91c2Vfc21hbGw9dXNlX3NtYWxsX21vZGVscywKICAgICAgICAgICAgZmluZV91c2VfZ3B1PXVzZV9ncHUsCiAgICAgICAgICAgIGZpbmVfdXNlX3NtYWxsPXVzZV9zbWFsbF9tb2RlbHMsCiAgICAgICAgICAgIGNvZGVjX3VzZV9ncHU9dXNlX2dwdSwKICAgICAgICAgICAgZm9yY2VfcmVsb2FkPW9mZmxvYWRfY3B1LAogICAgICAgICkKCiAgICBkZWYgX2dlbmVyYXRlX2F1ZGlvKHNlbGYsIHRleHQ6IHN0ciwgdm9pY2U6IHN0cikgLT4gbnAubmRhcnJheToKICAgICAgICAjIEdlbmVyYXRlIHdvcmRzIGF1ZGlvOgogICAgICAgIGF1ZGlvID0gc2VsZi5iYXJrLmdlbmVyYXRlX2F1ZGlvKAogICAgICAgICAgICB0ZXh0LAogICAgICAgICAgICBoaXN0b3J5X3Byb21wdD12b2ljZSwKICAgICAgICAgICAgc2lsZW50PVRydWUsCiAgICAgICAgKQogICAgICAgIHJldHVybiBhdWRpbwoKCmNsYXNzIE9wZW5BSUVuZ2luZShTcGVlY2hFbmdpbmUpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIG1vZGVsOiBzdHIgPSAidHRzLTEiLCBmaWxlX2Zvcm1hdDogc3RyID0gIndhdiIsIHNwZWVkOiBmbG9hdCA9IDEuMCk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLm9wZW5haSA9IGltcG9ydGxpYi5pbXBvcnRfbW9kdWxlKCJvcGVuYWkiKQogICAgICAgICAgICBzZWxmLnB5ZHViID0gaW1wb3J0bGliLmltcG9ydF9tb2R1bGUoInB5ZHViIikKICAgICAgICBleGNlcHQgSW1wb3J0RXJyb3I6CiAgICAgICAgICAgIHJhaXNlIEltcG9ydEVycm9yKAogICAgICAgICAgICAgICAgIlRoZSAnb3BlbmFpJyBhbmQgJ3B5ZHViJyBsaWJyYXJpZXMgYXJlIHJlcXVpcmVkIGZvciB0aGUgT3BlbkFJRW5naW5lLiBQbGVhc2UgaW5zdGFsbCB0aGVtIHVzaW5nICdwaXAgaW5zdGFsbCBvcGVuYWkgcHlkdWInLiIKICAgICAgICAgICAgKQoKICAgICAgICBhcGlfa2V5ID0gb3MuZ2V0ZW52KE9QRU5BSV9BUElfS0VZKQogICAgICAgIGJhc2VfdXJsID0gb3MuZ2V0ZW52KE9QRU5BSV9CQVNFX1VSTCkKICAgICAgICAjIENoZWNrIGlmIHRoZSBrZXkgaXMgYWxyZWFkeSBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzOgogICAgICAgIGlmIG5vdCBhcGlfa2V5IG9yIG5vdCBiYXNlX3VybDoKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgaW1wb3J0IG1scnVuCgogICAgICAgICAgICAgICAgY29udGV4dCA9IG1scnVuLmdldF9vcl9jcmVhdGVfY3R4KG5hbWU9ImNvbnRleHQiKQogICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGUga2V5IGlzIGluIHRoZSBzZWNyZXRzOgogICAgICAgICAgICAgICAgYXBpX2tleSA9IGNvbnRleHQuZ2V0X3NlY3JldChPUEVOQUlfQVBJX0tFWSkKICAgICAgICAgICAgICAgIGJhc2VfdXJsID0gY29udGV4dC5nZXRfc2VjcmV0KE9QRU5BSV9CQVNFX1VSTCkKICAgICAgICAgICAgZXhjZXB0IE1vZHVsZU5vdEZvdW5kRXJyb3I6CiAgICAgICAgICAgICAgICByYWlzZSBFbnZpcm9ubWVudEVycm9yKAogICAgICAgICAgICAgICAgICAgIGYiT25lIG9yIG1vcmUgb2YgdGhlIE9wZW5BSSByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgKCd7T1BFTkFJX0FQSV9LRVl9JywgJ3tPUEVOQUlfQkFTRV9VUkx9JykgYXJlIG1pc3NpbmcuIgogICAgICAgICAgICAgICAgICAgIGYiUGxlYXNlIHNldCB0aGVtIGFzIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBpbnN0YWxsIG1scnVuIChgcGlwIGluc3RhbGwgbWxydW5gKSIKICAgICAgICAgICAgICAgICAgICBmImFuZCBzZXQgdGhlbSBhcyBwcm9qZWN0IHNlY3JldHMgdXNpbmcgYHByb2plY3Quc2V0X3NlY3JldHNgLiIKICAgICAgICAgICAgICAgICkKCiAgICAgICAgc2VsZi5jbGllbnQgPSBzZWxmLm9wZW5haS5PcGVuQUkoYXBpX2tleT1hcGlfa2V5LCBiYXNlX3VybD1iYXNlX3VybCkKICAgICAgICBzZWxmLm1vZGVsID0gbW9kZWwKICAgICAgICBzZWxmLmZpbGVfZm9ybWF0ID0gZmlsZV9mb3JtYXQKICAgICAgICBzZWxmLnNwZWVkID0gc3BlZWQKCiAgICBkZWYgX2dlbmVyYXRlX2F1ZGlvKHNlbGYsIHRleHQ6IHN0ciwgdm9pY2U6IHN0cikgLT4gbnAubmRhcnJheToKICAgICAgICAjIEdlbmVyYXRlIHdvcmRzIGF1ZGlvOgogICAgICAgIGF1ZGlvID0gc2VsZi5jbGllbnQuYXVkaW8uc3BlZWNoLmNyZWF0ZSgKICAgICAgICAgICAgbW9kZWw9c2VsZi5tb2RlbCwKICAgICAgICAgICAgaW5wdXQ9dGV4dCwKICAgICAgICAgICAgdm9pY2U9dm9pY2UsCiAgICAgICAgICAgIHJlc3BvbnNlX2Zvcm1hdD1zZWxmLmZpbGVfZm9ybWF0LAogICAgICAgICAgICBzcGVlZD1zZWxmLnNwZWVkLAogICAgICAgICkKICAgICAgICBhdWRpbyA9IGF1ZGlvLmNvbnRlbnQKICAgICAgICBhdWRpbyA9IHNlbGYuX2J5dGVzX3RvX25wX2FycmF5KGF1ZGlvPWF1ZGlvKQogICAgICAgIHJldHVybiBhdWRpbwoKICAgIGRlZiBfYnl0ZXNfdG9fbnBfYXJyYXkoc2VsZiwgYXVkaW86IGJ5dGVzKToKICAgICAgICBpZiBzZWxmLmZpbGVfZm9ybWF0ID09ICJtcDMiOgogICAgICAgICAgICBhdWRpb19zZWdtZW50ID0gc2VsZi5weWR1Yi5BdWRpb1NlZ21lbnQuZnJvbV9tcDMoaW8uQnl0ZXNJTyhhdWRpbykpCgogICAgICAgICAgICAjIENvbnZlcnQgdG8gcmF3IFBDTSBhdWRpbyBkYXRhCiAgICAgICAgICAgIHNhbXBsZXMgPSBhdWRpb19zZWdtZW50LmdldF9hcnJheV9vZl9zYW1wbGVzKCkKCiAgICAgICAgICAgICMgQ29udmVydCB0byBudW1weSBhcnJheQogICAgICAgICAgICBhdWRpb19hcnJheSA9IG5wLmFycmF5KHNhbXBsZXMpCgogICAgICAgICAgICAjIE5vcm1hbGl6ZSB0byBmbG9hdCBiZXR3ZWVuIC0xIGFuZCAxCiAgICAgICAgICAgIHJldHVybiBhdWRpb19hcnJheS5hc3R5cGUobnAuZmxvYXQzMikgLyBucC5paW5mbyhzYW1wbGVzLnR5cGVjb2RlKS5tYXgKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gbnAuZnJvbWJ1ZmZlcihhdWRpbywgZHR5cGU9bnAuaW50MTYpIC8gMzI3NjguMAoKCmRlZiBfZ2V0X2VuZ2luZShlbmdpbmU6IHN0ciwgZmlsZV9mb3JtYXQ6IHN0ciwgKiprd2FyZ3MpIC0+IFNwZWVjaEVuZ2luZToKICAgICMgZWxpbWluYXRlIHRoZSBOb25lIHZhbHVlczoKICAgIGt3YXJncyA9IHtrZXk6IHZhbHVlIGZvciBrZXksIHZhbHVlIGluIGt3YXJncy5pdGVtcygpIGlmIHZhbHVlIGlzIG5vdCBOb25lfQoKICAgIGlmIGVuZ2luZSA9PSAiYmFyayI6CiAgICAgICAgcmV0dXJuIEJhcmtFbmdpbmUoKiprd2FyZ3MpCiAgICBlbGlmIGVuZ2luZSA9PSAib3BlbmFpIjoKICAgICAgICByZXR1cm4gT3BlbkFJRW5naW5lKGZpbGVfZm9ybWF0PWZpbGVfZm9ybWF0LCAqKmt3YXJncykKICAgIGVsc2U6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgZiJVbnJlY29nbml6ZWQgZW5naW5lLiBUaGUgcGFyYW1ldGVyIGBlbmdpbmVgIG11c3QgYmUgZWl0aGVyICdiYXJrJyBvciAnb3BlbmFpJy4gR2l2ZW46IHtlbmdpbmV9IgogICAgICAgICkKCmRlZiBfZ2V0X3RleHRfZmlsZXMoCiAgICBkYXRhX3BhdGg6IHBhdGhsaWIuUGF0aCwKKSAtPiBMaXN0W3BhdGhsaWIuUGF0aF06CiAgICAjIENoZWNrIGlmIHRoZSBwYXRoIGlzIG9mIGEgZGlyZWN0b3J5IG9yIGEgZmlsZToKICAgIGlmIGRhdGFfcGF0aC5pc19kaXIoKToKICAgICAgICAjIEdldCBhbGwgZmlsZXMgaW5zaWRlIHRoZSBkaXJlY3Rvcnk6CiAgICAgICAgdGV4dF9maWxlcyA9IGxpc3QoZGF0YV9wYXRoLmdsb2IoIiouKiIpKQogICAgZWxpZiBkYXRhX3BhdGguaXNfZmlsZSgpOgogICAgICAgIHRleHRfZmlsZXMgPSBbZGF0YV9wYXRoXQogICAgZWxzZToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKAogICAgICAgICAgICBmIlVucmVjb2duaXplZCBkYXRhIHBhdGguIFRoZSBwYXJhbWV0ZXIgYGRhdGFfcGF0aGAgbXVzdCBiZSBlaXRoZXIgYSBkaXJlY3RvcnkgcGF0aCBvciBhIGZpbGUgcGF0aC4gIgogICAgICAgICAgICBmIkdpdmVuOiB7c3RyKGRhdGFfcGF0aCl9ICIKICAgICAgICApCgogICAgcmV0dXJuIHRleHRfZmlsZXMKCgpkZWYgX3NwbGl0X2xpbmUobGluZTogc3RyLCBtYXhfbGVuZ3RoOiBpbnQgPSAyNTApIC0+IExpc3Rbc3RyXToKICAgIGlmIGxlbihsaW5lKSA8IG1heF9sZW5ndGg6CiAgICAgICAgcmV0dXJuIFtsaW5lXQoKICAgIHNlbnRlbmNlcyA9IFsKICAgICAgICBmIntzZW50ZW5jZS5zdHJpcCgpfS4iIGZvciBzZW50ZW5jZSBpbiBsaW5lLnNwbGl0KCIuIikgaWYgc2VudGVuY2Uuc3RyaXAoKQogICAgXQoKICAgIHNwbGl0cyA9IFtdCiAgICBjdXJyZW50X2xlbmd0aCA9IGxlbihzZW50ZW5jZXNbMF0pCiAgICBzcGxpdCA9IHNlbnRlbmNlc1swXQogICAgZm9yIHNlbnRlbmNlIGluIHNlbnRlbmNlc1sxOl06CiAgICAgICAgaWYgY3VycmVudF9sZW5ndGggKyBsZW4oc2VudGVuY2UpID4gbWF4X2xlbmd0aDoKICAgICAgICAgICAgc3BsaXRzLmFwcGVuZChzcGxpdCkKICAgICAgICAgICAgc3BsaXQgPSBzZW50ZW5jZQogICAgICAgICAgICBjdXJyZW50X2xlbmd0aCA9IGxlbihzZW50ZW5jZSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBjdXJyZW50X2xlbmd0aCArPSBsZW4oc2VudGVuY2UpCiAgICAgICAgICAgIHNwbGl0ICs9ICIgIiArIHNlbnRlbmNlCiAgICBpZiBzcGxpdDoKICAgICAgICBzcGxpdHMuYXBwZW5kKHNwbGl0KQoKICAgIHJldHVybiBzcGxpdHMKCgpkZWYgX2dldF9sb2dnZXIoKToKICAgIGdsb2JhbCBfTE9HR0VSCiAgICB0cnk6CiAgICAgICAgaW1wb3J0IG1scnVuCgogICAgICAgICMgQ2hlY2sgaWYgTUxSdW4gaXMgYXZhaWxhYmxlOgogICAgICAgIGNvbnRleHQgPSBtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eChuYW1lPSJtbHJ1biIpCiAgICAgICAgcmV0dXJuIGNvbnRleHQubG9nZ2VyCiAgICBleGNlcHQgTW9kdWxlTm90Rm91bmRFcnJvcjoKICAgICAgICByZXR1cm4gX0xPR0dFUgo=
    requirements:
    - bark
    - torchaudio
    - openai
    - pydub
kind: job
metadata:
  name: text-to-audio-generator
  tag: ''
  categories:
  - data-preparation
  - machine-learning
  - pytorch
verbose: false
