metadata:
  tag: ''
  name: onnx-utils
  categories:
  - utils
  - deep-learning
verbose: false
kind: job
spec:
  image: ''
  disable_auto_mount: false
  build:
    origin_filename: ''
    with_mlrun: false
    functionSourceCode: IyBDb3B5cmlnaHQgMjAxOSBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiMKIyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKIyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KIyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiMgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiMKZnJvbSB0eXBpbmcgaW1wb3J0IEFueQoKaW1wb3J0IG1scnVuCgoKY2xhc3MgX1RvT05OWENvbnZlcnNpb25zOgogICAgIiIiCiAgICBBbiBPTk5YIGNvbnZlcnNpb24gZnVuY3Rpb25zIGxpYnJhcnkgY2xhc3MuCiAgICAiIiIKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgdGZfa2VyYXNfdG9fb25ueCgKICAgICAgICBtb2RlbF9oYW5kbGVyLAogICAgICAgIG9ubnhfbW9kZWxfbmFtZTogc3RyID0gTm9uZSwKICAgICAgICBvcHRpbWl6ZV9tb2RlbDogYm9vbCA9IFRydWUsCiAgICAgICAgaW5wdXRfc2lnbmF0dXJlOiBsaXN0W3R1cGxlW3R1cGxlW2ludF0sIHN0cl1dID0gTm9uZSwKICAgICk6CiAgICAgICAgIiIiCiAgICAgICAgQ29udmVydCBhIFRGLktlcmFzIG1vZGVsIHRvIGFuIE9OTlggbW9kZWwgYW5kIGxvZyBpdCBiYWNrIHRvIE1MUnVuIGFzIGEgbmV3IG1vZGVsIG9iamVjdC4KCiAgICAgICAgOnBhcmFtIG1vZGVsX2hhbmRsZXI6ICAgQW4gaW5pdGlhbGl6ZWQgVEZLZXJhc01vZGVsSGFuZGxlciB3aXRoIGEgbG9hZGVkIG1vZGVsIHRvIGNvbnZlcnQgdG8gT05OWC4KICAgICAgICA6cGFyYW0gb25ueF9tb2RlbF9uYW1lOiBUaGUgbmFtZSB0byB1c2UgdG8gbG9nIHRoZSBjb252ZXJ0ZWQgT05OWCBtb2RlbC4gSWYgbm90IGdpdmVuLCB0aGUgZ2l2ZW4gYG1vZGVsX25hbWVgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSB1c2VkIHdpdGggYW4gYWRkaXRpb25hbCBzdWZmaXggYF9vbm54YC4gRGVmYXVsdGVkIHRvIE5vbmUuCiAgICAgICAgOnBhcmFtIG9wdGltaXplX21vZGVsOiAgV2hldGhlciBvciBub3QgdG8gb3B0aW1pemUgdGhlIE9OTlggbW9kZWwgdXNpbmcgJ29ubnhvcHRpbWl6ZXInIGJlZm9yZSBzYXZpbmcgdGhlIG1vZGVsLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRlZCB0byBUcnVlLgogICAgICAgIDpwYXJhbSBpbnB1dF9zaWduYXR1cmU6IEEgbGlzdCBvZiB0aGUgaW5wdXQgbGF5ZXJzIHNoYXBlIGFuZCBkYXRhIHR5cGUgcHJvcGVydGllcy4gRXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIGxpc3QKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYW4gaW5wdXQgbGF5ZXIgdHVwbGUuIEFuIGlucHV0IGxheWVyIHR1cGxlIGlzIGEgdHVwbGUgb2Y6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzBdID0gTGF5ZXIncyBzaGFwZSwgYSB0dXBsZSBvZiBpbnRlZ2Vycy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMV0gPSBMYXllcidzIGRhdGEgdHlwZSwgYSBtbHJ1bi5kYXRhX3R5cGVzLlZhbHVlVHlwZSBzdHJpbmcuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgTm9uZSwgdGhlIGlucHV0IHNpZ25hdHVyZSB3aWxsIGJlIHRyaWVkIHRvIGJlIHJlYWQgZnJvbSB0aGUgbW9kZWwgYXJ0aWZhY3QuIERlZmF1bHRlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIE5vbmUuCiAgICAgICAgIiIiCiAgICAgICAgIyBJbXBvcnQgdGhlIGZyYW1ld29yayBhbmQgaGFuZGxlcjoKICAgICAgICBpbXBvcnQgdGVuc29yZmxvdyBhcyB0ZgogICAgICAgIGZyb20gbWxydW4uZnJhbWV3b3Jrcy50Zl9rZXJhcyBpbXBvcnQgVEZLZXJhc1V0aWxzCgogICAgICAgICMgQ2hlY2sgdGhlIGdpdmVuICdpbnB1dF9zaWduYXR1cmUnIHBhcmFtZXRlcjoKICAgICAgICBpZiBpbnB1dF9zaWduYXR1cmUgaXMgTm9uZToKICAgICAgICAgICAgIyBSZWFkIHRoZSBpbnB1dHMgZnJvbSB0aGUgbW9kZWw6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIG1vZGVsX2hhbmRsZXIucmVhZF9pbnB1dHNfZnJvbV9tb2RlbCgpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXJyb3I6CiAgICAgICAgICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5SdW50aW1lRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgZiJQbGVhc2UgcHJvdmlkZSB0aGUgJ2lucHV0X3NpZ25hdHVyZScgcGFyYW1ldGVyLiBUaGUgZnVuY3Rpb24gdHJpZWQgcmVhZGluZyB0aGUgaW5wdXQgbGF5ZXJzICIKICAgICAgICAgICAgICAgICAgICBmImluZm9ybWF0aW9uIGF1dG9tYXRpY2FsbHkgYnV0IGZhaWxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3I6IHtlcnJvcn0iCiAgICAgICAgICAgICAgICApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyBQYXJzZSB0aGUgJ2lucHV0X3NpZ25hdHVyZScgcGFyYW1ldGVyOgogICAgICAgICAgICBpbnB1dF9zaWduYXR1cmUgPSBbCiAgICAgICAgICAgICAgICB0Zi5UZW5zb3JTcGVjKAogICAgICAgICAgICAgICAgICAgIHNoYXBlPXNoYXBlLAogICAgICAgICAgICAgICAgICAgIGR0eXBlPVRGS2VyYXNVdGlscy5jb252ZXJ0X3ZhbHVlX3R5cGVfdG9fdGZfZHR5cGUoCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX3R5cGU9dmFsdWVfdHlwZQogICAgICAgICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBmb3IgKHNoYXBlLCB2YWx1ZV90eXBlKSBpbiBpbnB1dF9zaWduYXR1cmUKICAgICAgICAgICAgXQoKICAgICAgICAjIENvbnZlcnQgdG8gT05OWDoKICAgICAgICBtb2RlbF9oYW5kbGVyLnRvX29ubngoCiAgICAgICAgICAgIG1vZGVsX25hbWU9b25ueF9tb2RlbF9uYW1lLAogICAgICAgICAgICBpbnB1dF9zaWduYXR1cmU9aW5wdXRfc2lnbmF0dXJlLAogICAgICAgICAgICBvcHRpbWl6ZT1vcHRpbWl6ZV9tb2RlbCwKICAgICAgICApCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIHB5dG9yY2hfdG9fb25ueCgKICAgICAgICBtb2RlbF9oYW5kbGVyLAogICAgICAgIG9ubnhfbW9kZWxfbmFtZTogc3RyID0gTm9uZSwKICAgICAgICBvcHRpbWl6ZV9tb2RlbDogYm9vbCA9IFRydWUsCiAgICAgICAgaW5wdXRfc2lnbmF0dXJlOiBsaXN0W3R1cGxlW3R1cGxlW2ludCwgLi4uXSwgc3RyXV0gPSBOb25lLAogICAgICAgIGlucHV0X2xheWVyc19uYW1lczogbGlzdFtzdHJdID0gTm9uZSwKICAgICAgICBvdXRwdXRfbGF5ZXJzX25hbWVzOiBsaXN0W3N0cl0gPSBOb25lLAogICAgICAgIGR5bmFtaWNfYXhlczogZGljdFtzdHIsIGRpY3RbaW50LCBzdHJdXSA9IE5vbmUsCiAgICAgICAgaXNfYmF0Y2hlZDogYm9vbCA9IFRydWUsCiAgICApOgogICAgICAgICIiIgogICAgICAgIENvbnZlcnQgYSBQeVRvcmNoIG1vZGVsIHRvIGFuIE9OTlggbW9kZWwgYW5kIGxvZyBpdCBiYWNrIHRvIE1MUnVuIGFzIGEgbmV3IG1vZGVsIG9iamVjdC4KCiAgICAgICAgOnBhcmFtIG1vZGVsX2hhbmRsZXI6ICAgICAgIEFuIGluaXRpYWxpemVkIFB5VG9yY2hNb2RlbEhhbmRsZXIgd2l0aCBhIGxvYWRlZCBtb2RlbCB0byBjb252ZXJ0IHRvIE9OTlguCiAgICAgICAgOnBhcmFtIG9ubnhfbW9kZWxfbmFtZTogICAgIFRoZSBuYW1lIHRvIHVzZSB0byBsb2cgdGhlIGNvbnZlcnRlZCBPTk5YIG1vZGVsLiBJZiBub3QgZ2l2ZW4sIHRoZSBnaXZlbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgbW9kZWxfbmFtZWAgd2lsbCBiZSB1c2VkIHdpdGggYW4gYWRkaXRpb25hbCBzdWZmaXggYF9vbm54YC4gRGVmYXVsdGVkIHRvIE5vbmUuCiAgICAgICAgOnBhcmFtIG9wdGltaXplX21vZGVsOiAgICAgIFdoZXRoZXIgb3Igbm90IHRvIG9wdGltaXplIHRoZSBPTk5YIG1vZGVsIHVzaW5nICdvbm54b3B0aW1pemVyJyBiZWZvcmUgc2F2aW5nIHRoZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC4gRGVmYXVsdGVkIHRvIFRydWUuCiAgICAgICAgOnBhcmFtIGlucHV0X3NpZ25hdHVyZTogICAgIEEgbGlzdCBvZiB0aGUgaW5wdXQgbGF5ZXJzIHNoYXBlIGFuZCBkYXRhIHR5cGUgcHJvcGVydGllcy4gRXhwZWN0ZWQgdG8gcmVjZWl2ZSBhCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGFuIGlucHV0IGxheWVyIHR1cGxlLiBBbiBpbnB1dCBsYXllciB0dXBsZSBpcyBhIHR1cGxlIG9mOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMF0gPSBMYXllcidzIHNoYXBlLCBhIHR1cGxlIG9mIGludGVnZXJzLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMV0gPSBMYXllcidzIGRhdGEgdHlwZSwgYSBtbHJ1bi5kYXRhX3R5cGVzLlZhbHVlVHlwZSBzdHJpbmcuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIE5vbmUsIHRoZSBpbnB1dCBzaWduYXR1cmUgd2lsbCBiZSB0cmllZCB0byBiZSByZWFkIGZyb20gdGhlIG1vZGVsIGFydGlmYWN0LgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0ZWQgdG8gTm9uZS4KICAgICAgICA6cGFyYW0gaW5wdXRfbGF5ZXJzX25hbWVzOiAgTGlzdCBvZiBuYW1lcyB0byBhc3NpZ24gdG8gdGhlIGlucHV0IG5vZGVzIG9mIHRoZSBncmFwaCBpbiBvcmRlci4gQWxsIG9mIHRoZSBvdGhlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzIChpbm5lciBsYXllcnMpIGNhbiBiZSBzZXQgYXMgd2VsbCBieSBwYXNzaW5nIGFkZGl0aW9uYWwgbmFtZXMgaW4gdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuIFRoZSBvcmRlciBpcyBieSB0aGUgb3JkZXIgb2YgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIG1vZGVsLiBJZiBOb25lLCB0aGUgaW5wdXRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBoYW5kbGVyJ3MgaW5wdXRzLiBJZiBpdHMgYWxzbyBOb25lLCBpdCBpcyBkZWZhdWx0ZWQgdG86CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnB1dF8wIiwgImlucHV0XzEiLCAuLi4KICAgICAgICA6cGFyYW0gb3V0cHV0X2xheWVyc19uYW1lczogTGlzdCBvZiBuYW1lcyB0byBhc3NpZ24gdG8gdGhlIG91dHB1dCBub2RlcyBvZiB0aGUgZ3JhcGggaW4gb3JkZXIuIElmIE5vbmUsIHRoZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBoYW5kbGVyJ3Mgb3V0cHV0cy4gSWYgaXRzIGFsc28gTm9uZSwgaXQgaXMgZGVmYXVsdGVkCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAib3V0cHV0XzAiIChmb3IgbXVsdGlwbGUgb3V0cHV0cywgdGhpcyBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCkuCiAgICAgICAgOnBhcmFtIGR5bmFtaWNfYXhlczogICAgICAgIElmIHBhcnQgb2YgdGhlIGlucHV0IC8gb3V0cHV0IHNoYXBlIGlzIGR5bmFtaWMsIGxpa2UgKGJhdGNoX3NpemUsIDMsIDMyLCAzMikgeW91IGNhbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZ5IGl0IGJ5IGdpdmluZyBhIGR5bmFtaWMgYXhpcyB0byB0aGUgaW5wdXQgLyBvdXRwdXQgbGF5ZXIgYnkgaXRzIG5hbWUgYXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9sbG93czogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlucHV0IGxheWVyIG5hbWUiOiB7MDogImJhdGNoX3NpemUifSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvdXRwdXQgbGF5ZXIgbmFtZSI6IHswOiAiYmF0Y2hfc2l6ZSJ9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHByb3ZpZGVkLCB0aGUgJ2lzX2JhdGNoZWQnIGZsYWcgd2lsbCBiZSBpZ25vcmVkLiBEZWZhdWx0ZWQgdG8gTm9uZS4KICAgICAgICA6cGFyYW0gaXNfYmF0Y2hlZDogICAgICAgICAgV2hldGhlciB0byBpbmNsdWRlIGEgYmF0Y2ggc2l6ZSBhcyB0aGUgZmlyc3QgYXhpcyBpbiBldmVyeSBpbnB1dCBhbmQgb3V0cHV0IGxheWVyLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0ZWQgdG8gVHJ1ZS4gV2lsbCBiZSBpZ25vcmVkIGlmICdkeW5hbWljX2F4ZXMnIGlzIHByb3ZpZGVkLgogICAgICAgICIiIgogICAgICAgICMgSW1wb3J0IHRoZSBmcmFtZXdvcmsgYW5kIGhhbmRsZXI6CiAgICAgICAgaW1wb3J0IHRvcmNoCiAgICAgICAgZnJvbSBtbHJ1bi5mcmFtZXdvcmtzLnB5dG9yY2ggaW1wb3J0IFB5VG9yY2hVdGlscwoKICAgICAgICAjIFBhcnNlIHRoZSAnaW5wdXRfc2lnbmF0dXJlJyBwYXJhbWV0ZXI6CiAgICAgICAgaWYgaW5wdXRfc2lnbmF0dXJlIGlzIG5vdCBOb25lOgogICAgICAgICAgICBpbnB1dF9zaWduYXR1cmUgPSB0dXBsZSgKICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICB0b3JjaC56ZXJvcygKICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1zaGFwZSwKICAgICAgICAgICAgICAgICAgICAgICAgZHR5cGU9UHlUb3JjaFV0aWxzLmNvbnZlcnRfdmFsdWVfdHlwZV90b190b3JjaF9kdHlwZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX3R5cGU9dmFsdWVfdHlwZQogICAgICAgICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBmb3IgKHNoYXBlLCB2YWx1ZV90eXBlKSBpbiBpbnB1dF9zaWduYXR1cmUKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgKQoKICAgICAgICAjIENvbnZlcnQgdG8gT05OWDoKICAgICAgICBtb2RlbF9oYW5kbGVyLnRvX29ubngoCiAgICAgICAgICAgIG1vZGVsX25hbWU9b25ueF9tb2RlbF9uYW1lLAogICAgICAgICAgICBpbnB1dF9zYW1wbGU9aW5wdXRfc2lnbmF0dXJlLAogICAgICAgICAgICBvcHRpbWl6ZT1vcHRpbWl6ZV9tb2RlbCwKICAgICAgICAgICAgaW5wdXRfbGF5ZXJzX25hbWVzPWlucHV0X2xheWVyc19uYW1lcywKICAgICAgICAgICAgb3V0cHV0X2xheWVyc19uYW1lcz1vdXRwdXRfbGF5ZXJzX25hbWVzLAogICAgICAgICAgICBkeW5hbWljX2F4ZXM9ZHluYW1pY19heGVzLAogICAgICAgICAgICBpc19iYXRjaGVkPWlzX2JhdGNoZWQsCiAgICAgICAgKQoKCiMgTWFwIGZvciBnZXR0aW5nIHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgZnJhbWV3b3JrOgpfQ09OVkVSU0lPTl9NQVAgPSB7CiAgICAidGVuc29yZmxvdy5rZXJhcyI6IF9Ub09OTlhDb252ZXJzaW9ucy50Zl9rZXJhc190b19vbm54LAogICAgInRvcmNoIjogX1RvT05OWENvbnZlcnNpb25zLnB5dG9yY2hfdG9fb25ueCwKfSAgIyB0eXBlOiBEaWN0W3N0ciwgQ2FsbGFibGVdCgoKZGVmIHRvX29ubngoCiAgICBjb250ZXh0OiBtbHJ1bi5NTENsaWVudEN0eCwKICAgIG1vZGVsX3BhdGg6IHN0ciwKICAgIGxvYWRfbW9kZWxfa3dhcmdzOiBkaWN0ID0gTm9uZSwKICAgIG9ubnhfbW9kZWxfbmFtZTogc3RyID0gTm9uZSwKICAgIG9wdGltaXplX21vZGVsOiBib29sID0gVHJ1ZSwKICAgIGZyYW1ld29ya19rd2FyZ3M6IGRpY3Rbc3RyLCBBbnldID0gTm9uZSwKKToKICAgICIiIgogICAgQ29udmVydCB0aGUgZ2l2ZW4gbW9kZWwgdG8gYW4gT05OWCBtb2RlbC4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgIFRoZSBNTFJ1biBmdW5jdGlvbiBleGVjdXRpb24gY29udGV4dAogICAgOnBhcmFtIG1vZGVsX3BhdGg6ICAgICAgICBUaGUgbW9kZWwgcGF0aCBzdG9yZSBvYmplY3QuCiAgICA6cGFyYW0gbG9hZF9tb2RlbF9rd2FyZ3M6IEtleXdvcmQgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGBBdXRvTUxSdW4ubG9hZF9tb2RlbGAgbWV0aG9kLgogICAgOnBhcmFtIG9ubnhfbW9kZWxfbmFtZTogICBUaGUgbmFtZSB0byB1c2UgdG8gbG9nIHRoZSBjb252ZXJ0ZWQgT05OWCBtb2RlbC4gSWYgbm90IGdpdmVuLCB0aGUgZ2l2ZW4gYG1vZGVsX25hbWVgIHdpbGwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgdXNlZCB3aXRoIGFuIGFkZGl0aW9uYWwgc3VmZml4IGBfb25ueGAuIERlZmF1bHRlZCB0byBOb25lLgogICAgOnBhcmFtIG9wdGltaXplX21vZGVsOiAgICBXaGV0aGVyIHRvIG9wdGltaXplIHRoZSBPTk5YIG1vZGVsIHVzaW5nICdvbm54b3B0aW1pemVyJyBiZWZvcmUgc2F2aW5nIHRoZSBtb2RlbC4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdGVkIHRvIFRydWUuCiAgICA6cGFyYW0gZnJhbWV3b3JrX2t3YXJnczogIEFkZGl0aW9uYWwgYXJndW1lbnRzIGVhY2ggZnJhbWV3b3JrIG1heSByZXF1aXJlIHRvIGNvbnZlcnQgdG8gT05OWC4gVG8gZ2V0IHRoZSBkb2Mgc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBkZXNpcmVkIGZyYW1ld29yayBvbm54IGNvbnZlcnNpb24gZnVuY3Rpb24sIHBhc3MgImhlbHAiLgogICAgIiIiCiAgICBmcm9tIG1scnVuLmZyYW1ld29ya3MuYXV0b19tbHJ1bi5hdXRvX21scnVuIGltcG9ydCBBdXRvTUxSdW4KCiAgICAjIEdldCBhIG1vZGVsIGhhbmRsZXIgb2YgdGhlIHJlcXVpcmVkIGZyYW1ld29yazoKICAgIGxvYWRfbW9kZWxfa3dhcmdzID0gbG9hZF9tb2RlbF9rd2FyZ3Mgb3Ige30KICAgIG1vZGVsX2hhbmRsZXIgPSBBdXRvTUxSdW4ubG9hZF9tb2RlbCgKICAgICAgICBtb2RlbF9wYXRoPW1vZGVsX3BhdGgsIGNvbnRleHQ9Y29udGV4dCwgKipsb2FkX21vZGVsX2t3YXJncwogICAgKQoKICAgICMgR2V0IHRoZSBtb2RlbCdzIGZyYW1ld29yazoKICAgIGZyYW1ld29yayA9IG1vZGVsX2hhbmRsZXIuRlJBTUVXT1JLX05BTUUKCiAgICAjIFVzZSB0aGUgY29udmVyc2lvbiBtYXAgdG8gZ2V0IHRoZSBzcGVjaWZpYyBmcmFtZXdvcmsgdG8gb25ueCBjb252ZXJzaW9uOgogICAgaWYgZnJhbWV3b3JrIG5vdCBpbiBfQ09OVkVSU0lPTl9NQVA6CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3IoCiAgICAgICAgICAgIGYiVGhlIGZvbGxvd2luZyBmcmFtZXdvcms6ICd7ZnJhbWV3b3JrfScsIGhhcyBubyBPTk5YIGNvbnZlcnNpb24uIgogICAgICAgICkKICAgIGNvbnZlcnNpb25fZnVuY3Rpb24gPSBfQ09OVkVSU0lPTl9NQVBbZnJhbWV3b3JrXQoKICAgICMgQ2hlY2sgaWYgbmVlZGVkIHRvIHByaW50IHRoZSBmdW5jdGlvbidzIGRvYyBzdHJpbmcgKCJoZWxwIiBpcyBwYXNzZWQpOgogICAgaWYgZnJhbWV3b3JrX2t3YXJncyA9PSAiaGVscCI6CiAgICAgICAgcHJpbnQoY29udmVyc2lvbl9mdW5jdGlvbi5fX2RvY19fKQogICAgICAgIHJldHVybgoKICAgICMgU2V0IHRoZSBkZWZhdWx0IGVtcHR5IGZyYW1ld29yayBrd2FyZ3MgaWYgbmVlZGVkOgogICAgaWYgZnJhbWV3b3JrX2t3YXJncyBpcyBOb25lOgogICAgICAgIGZyYW1ld29ya19rd2FyZ3MgPSB7fQoKICAgICMgUnVuIHRoZSBjb252ZXJzaW9uOgogICAgdHJ5OgogICAgICAgIGNvbnZlcnNpb25fZnVuY3Rpb24oCiAgICAgICAgICAgIG1vZGVsX2hhbmRsZXI9bW9kZWxfaGFuZGxlciwKICAgICAgICAgICAgb25ueF9tb2RlbF9uYW1lPW9ubnhfbW9kZWxfbmFtZSwKICAgICAgICAgICAgb3B0aW1pemVfbW9kZWw9b3B0aW1pemVfbW9kZWwsCiAgICAgICAgICAgICoqZnJhbWV3b3JrX2t3YXJncywKICAgICAgICApCiAgICBleGNlcHQgVHlwZUVycm9yIGFzIGV4Y2VwdGlvbjoKICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5JbnZhbGlkQXJndW1lbnRFcnJvcigKICAgICAgICAgICAgZiJFUlJPUjogQSBUeXBlRXJyb3IgZXhjZXB0aW9uIHdhcyByYWlzZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uOlxue2V4Y2VwdGlvbn0uICIKICAgICAgICAgICAgZiJQbGVhc2UgcmVhZCB0aGUge2ZyYW1ld29ya30gZnJhbWV3b3JrIGNvbnZlcnNpb24gZnVuY3Rpb24gZG9jIHN0cmluZyBieSBwYXNzaW5nICdoZWxwJyBpbiB0aGUgIgogICAgICAgICAgICBmIidmcmFtZXdvcmtfa3dhcmdzJyBkaWN0aW9uYXJ5IHBhcmFtZXRlci4iCiAgICAgICAgKQoKCmRlZiBvcHRpbWl6ZSgKICAgIGNvbnRleHQ6IG1scnVuLk1MQ2xpZW50Q3R4LAogICAgbW9kZWxfcGF0aDogc3RyLAogICAgaGFuZGxlcl9pbml0X2t3YXJnczogZGljdCA9IE5vbmUsCiAgICBvcHRpbWl6YXRpb25zOiBsaXN0W3N0cl0gPSBOb25lLAogICAgZml4ZWRfcG9pbnQ6IGJvb2wgPSBGYWxzZSwKICAgIG9wdGltaXplZF9tb2RlbF9uYW1lOiBzdHIgPSBOb25lLAopOgogICAgIiIiCiAgICBPcHRpbWl6ZSB0aGUgZ2l2ZW4gT05OWCBtb2RlbC4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICAgIFRoZSBNTFJ1biBmdW5jdGlvbiBleGVjdXRpb24gY29udGV4dC4KICAgIDpwYXJhbSBtb2RlbF9wYXRoOiAgICAgICAgICAgUGF0aCB0byB0aGUgT05OWCBtb2RlbCBvYmplY3QuCiAgICA6cGFyYW0gaGFuZGxlcl9pbml0X2t3YXJnczogIEtleXdvcmQgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGBPTk5YTW9kZWxIYW5kbGVyYCBpbml0IG1ldGhvZCBwcmVsb2FkaW5nLgogICAgOnBhcmFtIG9wdGltaXphdGlvbnM6ICAgICAgICBMaXN0IG9mIHBvc3NpYmxlIG9wdGltaXphdGlvbnMuIFRvIHNlZSB3aGF0IG9wdGltaXphdGlvbnMgYXJlIGF2YWlsYWJsZSwgcGFzcyAiaGVscCIuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIE5vbmUsIGFsbCB0aGUgb3B0aW1pemF0aW9ucyB3aWxsIGJlIHVzZWQuIERlZmF1bHRlZCB0byBOb25lLgogICAgOnBhcmFtIGZpeGVkX3BvaW50OiAgICAgICAgICBPcHRpbWl6ZSB0aGUgd2VpZ2h0cyB1c2luZyBmaXhlZCBwb2ludC4gRGVmYXVsdGVkIHRvIEZhbHNlLgogICAgOnBhcmFtIG9wdGltaXplZF9tb2RlbF9uYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3B0aW1pemVkIG1vZGVsLiBJZiBOb25lLCB0aGUgb3JpZ2luYWwgbW9kZWwgd2lsbCBiZSBvdmVycmlkZGVuLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0ZWQgdG8gTm9uZS4KICAgICIiIgogICAgIyBJbXBvcnQgdGhlIG1vZGVsIGhhbmRsZXI6CiAgICBpbXBvcnQgb25ueG9wdGltaXplcgogICAgZnJvbSBtbHJ1bi5mcmFtZXdvcmtzLm9ubnggaW1wb3J0IE9OTlhNb2RlbEhhbmRsZXIKCiAgICAjIENoZWNrIGlmIG5lZWRlZCB0byBwcmludCB0aGUgYXZhaWxhYmxlIG9wdGltaXphdGlvbnMgKCJoZWxwIiBpcyBwYXNzZWQpOgogICAgaWYgb3B0aW1pemF0aW9ucyA9PSAiaGVscCI6CiAgICAgICAgYXZhaWxhYmxlX3Bhc3NlcyA9ICJcbiogIi5qb2luKG9ubnhvcHRpbWl6ZXIuZ2V0X2F2YWlsYWJsZV9wYXNzZXMoKSkKICAgICAgICBwcmludChmIlRoZSBhdmFpbGFibGUgb3B0aW1pemF0aW9ucyBhcmU6XG4qIHthdmFpbGFibGVfcGFzc2VzfSIpCiAgICAgICAgcmV0dXJuCgogICAgIyBDcmVhdGUgdGhlIG1vZGVsIGhhbmRsZXI6CiAgICBoYW5kbGVyX2luaXRfa3dhcmdzID0gaGFuZGxlcl9pbml0X2t3YXJncyBvciB7fQogICAgbW9kZWxfaGFuZGxlciA9IE9OTlhNb2RlbEhhbmRsZXIoCiAgICAgICAgbW9kZWxfcGF0aD1tb2RlbF9wYXRoLCBjb250ZXh0PWNvbnRleHQsICoqaGFuZGxlcl9pbml0X2t3YXJncwogICAgKQoKICAgICMgTG9hZCB0aGUgT05OWCBtb2RlbDoKICAgIG1vZGVsX2hhbmRsZXIubG9hZCgpCgogICAgIyBPcHRpbWl6ZSB0aGUgbW9kZWwgdXNpbmcgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25zOgogICAgbW9kZWxfaGFuZGxlci5vcHRpbWl6ZShvcHRpbWl6YXRpb25zPW9wdGltaXphdGlvbnMsIGZpeGVkX3BvaW50PWZpeGVkX3BvaW50KQoKICAgICMgUmVuYW1lIGlmIG5lZWRlZDoKICAgIGlmIG9wdGltaXplZF9tb2RlbF9uYW1lIGlzIG5vdCBOb25lOgogICAgICAgIG1vZGVsX2hhbmRsZXIuc2V0X21vZGVsX25hbWUobW9kZWxfbmFtZT1vcHRpbWl6ZWRfbW9kZWxfbmFtZSkKCiAgICAjIExvZyB0aGUgb3B0aW1pemVkIG1vZGVsOgogICAgbW9kZWxfaGFuZGxlci5sb2coKQo=
    requirements:
    - tqdm~=4.67.1
    - tensorflow~=2.19.0
    - tf_keras~=2.19.0
    - torch~=2.6.0
    - torchvision~=0.21.0
    - onnx~=1.17.0
    - onnxruntime~=1.19.2
    - onnxoptimizer~=0.3.13
    - onnxmltools~=1.13.0
    - tf2onnx~=1.16.1
    - plotly~=5.23
    code_origin: ''
    auto_build: true
    base_image: mlrun/mlrun
  allow_empty_resources: true
  filename: onnx_utils.py
  entry_points:
    tf_keras_to_onnx:
      parameters:
      - name: model_handler
        doc: An initialized TFKerasModelHandler with a loaded model to convert to
          ONNX.
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether or not to optimize the ONNX model using 'onnxoptimizer' before
          saving the model. Defaulted to True.
        default: true
      - name: input_signature
        type: list[tuple[tuple[int], str]]
        doc: 'A list of the input layers shape and data type properties. Expected
          to receive a list where each element is an input layer tuple. An input layer
          tuple is a tuple of: [0] = Layer''s shape, a tuple of integers. [1] = Layer''s
          data type, a mlrun.data_types.ValueType string. If None, the input signature
          will be tried to be read from the model artifact. Defaulted to None.'
        default: null
      name: tf_keras_to_onnx
      doc: Convert a TF.Keras model to an ONNX model and log it back to MLRun as a
        new model object.
      has_kwargs: false
      has_varargs: false
      lineno: 26
    pytorch_to_onnx:
      parameters:
      - name: model_handler
        doc: An initialized PyTorchModelHandler with a loaded model to convert to
          ONNX.
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether or not to optimize the ONNX model using 'onnxoptimizer' before
          saving the model. Defaulted to True.
        default: true
      - name: input_signature
        type: list[tuple[tuple[int, ], str]]
        doc: 'A list of the input layers shape and data type properties. Expected
          to receive a list where each element is an input layer tuple. An input layer
          tuple is a tuple of: [0] = Layer''s shape, a tuple of integers. [1] = Layer''s
          data type, a mlrun.data_types.ValueType string. If None, the input signature
          will be tried to be read from the model artifact. Defaulted to None.'
        default: null
      - name: input_layers_names
        type: list[str]
        doc: 'List of names to assign to the input nodes of the graph in order. All
          of the other parameters (inner layers) can be set as well by passing additional
          names in the list. The order is by the order of the parameters in the model.
          If None, the inputs will be read from the handler''s inputs. If its also
          None, it is defaulted to: "input_0", "input_1", ...'
        default: null
      - name: output_layers_names
        type: list[str]
        doc: 'List of names to assign to the output nodes of the graph in order. If
          None, the outputs will be read from the handler''s outputs. If its also
          None, it is defaulted to: "output_0" (for multiple outputs, this parameter
          must be provided).'
        default: null
      - name: dynamic_axes
        type: dict[str, dict[int, str]]
        doc: 'If part of the input / output shape is dynamic, like (batch_size, 3,
          32, 32) you can specify it by giving a dynamic axis to the input / output
          layer by its name as follows: { "input layer name": {0: "batch_size"}, "output
          layer name": {0: "batch_size"}, } If provided, the ''is_batched'' flag will
          be ignored. Defaulted to None.'
        default: null
      - name: is_batched
        type: bool
        doc: Whether to include a batch size as the first axis in every input and
          output layer. Defaulted to True. Will be ignored if 'dynamic_axes' is provided.
        default: true
      name: pytorch_to_onnx
      doc: Convert a PyTorch model to an ONNX model and log it back to MLRun as a
        new model object.
      has_kwargs: false
      has_varargs: false
      lineno: 81
    to_onnx:
      parameters:
      - name: context
        type: MLClientCtx
        doc: The MLRun function execution context
      - name: model_path
        type: str
        doc: The model path store object.
      - name: load_model_kwargs
        type: dict
        doc: Keyword arguments to pass to the `AutoMLRun.load_model` method.
        default: null
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether to optimize the ONNX model using 'onnxoptimizer' before saving
          the model. Defaulted to True.
        default: true
      - name: framework_kwargs
        type: dict[str, Any]
        doc: Additional arguments each framework may require to convert to ONNX. To
          get the doc string of the desired framework onnx conversion function, pass
          "help".
        default: null
      name: to_onnx
      doc: Convert the given model to an ONNX model.
      has_kwargs: false
      has_varargs: false
      lineno: 160
    optimize:
      parameters:
      - name: context
        type: MLClientCtx
        doc: The MLRun function execution context.
      - name: model_path
        type: str
        doc: Path to the ONNX model object.
      - name: handler_init_kwargs
        type: dict
        doc: Keyword arguments to pass to the `ONNXModelHandler` init method preloading.
        default: null
      - name: optimizations
        type: list[str]
        doc: List of possible optimizations. To see what optimizations are available,
          pass "help". If None, all the optimizations will be used. Defaulted to None.
        default: null
      - name: fixed_point
        type: bool
        doc: Optimize the weights using fixed point. Defaulted to False.
        default: false
      - name: optimized_model_name
        type: str
        doc: The name of the optimized model. If None, the original model will be
          overridden. Defaulted to None.
        default: null
      name: optimize
      doc: Optimize the given ONNX model.
      has_kwargs: false
      has_varargs: false
      lineno: 224
  command: ''
  description: ONNX intigration in MLRun, some utils functions for the ONNX framework,
    optimizing and converting models from different framework to ONNX using MLRun.
  default_handler: to_onnx
