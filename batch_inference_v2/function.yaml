spec:
  image: mlrun/mlrun
  default_handler: infer
  command: ''
  allow_empty_resources: true
  description: Batch inference (also knows as prediction) for the common ML frameworks
    (SciKit-Learn, XGBoost and LightGBM) while performing data drift analysis.
  disable_auto_mount: false
  build:
    with_mlrun: false
    functionSourceCode: IyBDb3B5cmlnaHQgMjAyMyBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiMKIyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKIyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KIyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiMgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgpmcm9tIGluc3BlY3QgaW1wb3J0IHNpZ25hdHVyZQpmcm9tIHR5cGluZyBpbXBvcnQgQW55LCBEaWN0LCBMaXN0LCBVbmlvbiwgT3B0aW9uYWwKaW1wb3J0IG1scnVuCgp0cnk6CiAgICBpbXBvcnQgbWxydW4ubW9kZWxfbW9uaXRvcmluZy5hcGkKZXhjZXB0IE1vZHVsZU5vdEZvdW5kRXJyb3I6CiAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5Ob3RGb3VuZEVycm9yKAogICAgICAgIGYiUGxlYXNlIHVwZGF0ZSB5b3VyIGBtbHJ1bmAgdmVyc2lvbiB0byA+PTEuNS4wIG9yIHVzZSBhbiAiCiAgICAgICAgZiJvbGRlciB2ZXJzaW9uIG9mIHRoZSBiYXRjaCBpbmZlcmVuY2UgZnVuY3Rpb24uIgogICAgKQoKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCBwYW5kYXMgYXMgcGQKZnJvbSBtbHJ1bi5mcmFtZXdvcmtzLmF1dG9fbWxydW4gaW1wb3J0IEF1dG9NTFJ1bgoKCmRlZiBfcHJlcGFyZV9yZXN1bHRfc2V0KHg6IHBkLkRhdGFGcmFtZSwgbGFiZWxfY29sdW1uczogTGlzdFtzdHJdLCB5X3ByZWQ6IG5wLm5kYXJyYXkpIC0+IHBkLkRhdGFGcmFtZToKICAgICIiIgogICAgU2V0IGRlZmF1bHQgbGFiZWwgY29sdW1uIG5hbWVzIGFuZCB2YWxpZGF0ZSBnaXZlbiBuYW1lcyB0byBwcmVwYXJlIHRoZSByZXN1bHQgc2V0IC0gYSBjb25jYXRlbmF0aW9uIG9mIHRoZSBpbnB1dHMKICAgICh4KSBhbmQgdGhlIG1vZGVsIHByZWRpY3Rpb25zICh5X3ByZWQpLgoKICAgIDpwYXJhbSB4OiAgICAgICAgICAgICBUaGUgaW5wdXRzLgogICAgOnBhcmFtIGxhYmVsX2NvbHVtbnM6IEEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgdGFyZ2V0IGNvbHVtbiBuYW1lcyB0byBhZGQgdG8gdGhlIHByZWRpY3Rpb25zLiBEZWZhdWx0IG5hbWUKICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHVzZWQgaW4gY2FzZSB0aGUgbGlzdCBpcyBlbXB0eSAocHJlZGljdGVkX2xhYmVsX3tpfSkuCiAgICA6cGFyYW0geV9wcmVkOiAgICAgICAgVGhlIG1vZGVsIHByZWRpY3Rpb25zIG9uIHRoZSBpbnB1dHMuCgogICAgOnJldHVybnM6IFRoZSByZXN1bHQgc2V0LgoKICAgIHJhaXNlcyBNTFJ1bkludmFsaWRBcmd1bWVudEVycm9yOiBJZiB0aGUgbGFiZWxzIGNvbHVtbnMgYW1vdW50IGRvIG5vdCBtYXRjaCB0aGUgb3V0cHV0cyBvciBpZiBvbmUgb2YgdGhlIGxhYmVsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZGF0YXNldC4KICAgICIiIgogICAgIyBQcmVwYXJlIGRlZmF1bHQgdGFyZ2V0IGNvbHVtbnMgbmFtZXMgaWYgbm90IHByb3ZpZGVkOgogICAgcHJlZGljdGlvbl9jb2x1bW5zX2Ftb3VudCA9IDEgaWYgbGVuKHlfcHJlZC5zaGFwZSkgPT0gMSBlbHNlIHlfcHJlZC5zaGFwZVsxXQogICAgaWYgbGVuKGxhYmVsX2NvbHVtbnMpID09IDA6CiAgICAgICAgIyBBZGQgZGVmYXVsdCBsYWJlbCBjb2x1bW4gbmFtZXM6CiAgICAgICAgaWYgcHJlZGljdGlvbl9jb2x1bW5zX2Ftb3VudCA9PSAxOgogICAgICAgICAgICBsYWJlbF9jb2x1bW5zID0gWyJwcmVkaWN0ZWRfbGFiZWwiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGxhYmVsX2NvbHVtbnMgPSBbCiAgICAgICAgICAgICAgICBmInByZWRpY3RlZF9sYWJlbF97aX0iIGZvciBpIGluIHJhbmdlKHByZWRpY3Rpb25fY29sdW1uc19hbW91bnQpCiAgICAgICAgICAgIF0KCiAgICAjIFZhbGlkYXRlIHRoZSBsYWJlbCBjb2x1bW5zOgogICAgaWYgcHJlZGljdGlvbl9jb2x1bW5zX2Ftb3VudCAhPSBsZW4obGFiZWxfY29sdW1ucyk6CiAgICAgICAgIyBObyBlcXVhbGl0eSBiZXR3ZWVuIHByb3ZpZGVkIGxhYmVsIGNvbHVtbiBuYW1lcyBhbmQgb3V0cHV0cyBhbW91bnQ6CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3IoCiAgICAgICAgICAgIGYiVGhlIG51bWJlciBvZiBwcmVkaWN0ZWQgbGFiZWxzOiB7cHJlZGljdGlvbl9jb2x1bW5zX2Ftb3VudH0gIgogICAgICAgICAgICBmImlzIG5vdCBlcXVhbCB0byB0aGUgZ2l2ZW4gbGFiZWwgY29sdW1uczoge2xlbihsYWJlbF9jb2x1bW5zKX0iCiAgICAgICAgKQogICAgY29tbW9uX2xhYmVscyA9IHNldChsYWJlbF9jb2x1bW5zKSAmIHNldCh4LmNvbHVtbnMudG9saXN0KCkpCiAgICBpZiBjb21tb25fbGFiZWxzOgogICAgICAgICMgTGFiZWwgY29sdW1uIGV4aXN0IGluIHRoZSBvcmlnaW5hbCBpbnB1dHM6CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3IoCiAgICAgICAgICAgIGYiVGhlIGxhYmVsczoge2NvbW1vbl9sYWJlbHN9IGFyZSBhbHJlYWR5IGV4aXN0ZWQgaW4gdGhlIGdpdmVuIGRhdGFzZXQuIgogICAgICAgICkKCiAgICByZXR1cm4gcGQuY29uY2F0KAogICAgICAgIFt4LCBwZC5EYXRhRnJhbWUoeV9wcmVkLCBjb2x1bW5zPWxhYmVsX2NvbHVtbnMsIGluZGV4PXguaW5kZXgpXSwgYXhpcz0xCiAgICApCgoKZGVmIF9nZXRfc2FtcGxlX3NldF9zdGF0aXN0aWNzX3BhcmFtZXRlcnMoY29udGV4dDogbWxydW4uTUxDbGllbnRDdHgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsX2VuZHBvaW50X3NhbXBsZV9zZXQ6IFVuaW9uWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxydW4uRGF0YUl0ZW0sIGxpc3QsIGRpY3QsIHBkLkRhdGFGcmFtZSwgcGQuU2VyaWVzLCBucC5uZGFycmF5XSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxfYXJ0aWZhY3RfZmVhdHVyZV9zdGF0czogZGljdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZV9jb2x1bW5zOiBPcHRpb25hbFtMaXN0XSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9jb2x1bW5zOiBPcHRpb25hbFtMaXN0XSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxfY29sdW1uczogT3B0aW9uYWxbTGlzdF0pIC0+IERpY3Rbc3RyLCBBbnldOgogICAgc3RhdGljc19pbnB1dF9mdWxsX2RpY3QgPSBkaWN0KHNhbXBsZV9zZXQ9bW9kZWxfZW5kcG9pbnRfc2FtcGxlX3NldCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbF9hcnRpZmFjdF9mZWF0dXJlX3N0YXRzPW1vZGVsX2FydGlmYWN0X2ZlYXR1cmVfc3RhdHMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlX3NldF9jb2x1bW5zPWZlYXR1cmVfY29sdW1ucywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVfc2V0X2Ryb3BfY29sdW1ucz1kcm9wX2NvbHVtbnMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlX3NldF9sYWJlbF9jb2x1bW5zPWxhYmVsX2NvbHVtbnMpCiAgICBnZXRfc2FtcGxlX3N0YXRpY3NfZnVuY3Rpb24gPSBtbHJ1bi5tb2RlbF9tb25pdG9yaW5nLmFwaS5nZXRfc2FtcGxlX3NldF9zdGF0aXN0aWNzCiAgICBzdGF0aWNzX2Z1bmN0aW9uX2lucHV0X2RpY3QgPSBzaWduYXR1cmUoZ2V0X3NhbXBsZV9zdGF0aWNzX2Z1bmN0aW9uKS5wYXJhbWV0ZXJzCiAgICAjICBBcyBhIHJlc3VsdCBvZiBjaGFuZ2VzIHRvIGlucHV0IHBhcmFtZXRlcnMgaW4gdGhlIG1scnVuLWdldF9zYW1wbGVfc2V0X3N0YXRpc3RpY3MgZnVuY3Rpb24sCiAgICAjICB3ZSB3aWxsIG5vdyBzZW5kIG9ubHkgdGhlIHBhcmFtZXRlcnMgaXQgZXhwZWN0cy4KICAgIHN0YXRpc3RpY3NfaW5wdXRfZmlsdGVyZWQgPSB7a2V5OiBzdGF0aWNzX2lucHV0X2Z1bGxfZGljdFtrZXldIGZvciBrZXkgaW4gc3RhdGljc19mdW5jdGlvbl9pbnB1dF9kaWN0fQogICAgaWYgbGVuKHN0YXRpc3RpY3NfaW5wdXRfZmlsdGVyZWQpICE9IGxlbihzdGF0aWNzX2Z1bmN0aW9uX2lucHV0X2RpY3QpOgogICAgICAgIGNvbnRleHQubG9nZ2VyLndhcm5pbmcoZiJnZXRfc2FtcGxlX3NldF9zdGF0aXN0aWNzIGlzIGluIGFuIG9sZGVyIHZlcnNpb247ICIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb21lIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgc2VudCB0byB0aGUgZnVuY3Rpb24uIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiIgRXhwZWN0ZWQgaW5wdXQ6IHtsaXN0KHN0YXRpY3NfZnVuY3Rpb25faW5wdXRfZGljdC5rZXlzKCkpfSwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIiBhY3R1YWwgaW5wdXQ6IHtsaXN0KHN0YXRpc3RpY3NfaW5wdXRfZmlsdGVyZWQua2V5cygpKX0iKQogICAgcmV0dXJuIHN0YXRpc3RpY3NfaW5wdXRfZmlsdGVyZWQKCgpkZWYgaW5mZXIoCiAgICAgICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHgsCiAgICAgICAgZGF0YXNldDogVW5pb25bbWxydW4uRGF0YUl0ZW0sIGxpc3QsIGRpY3QsIHBkLkRhdGFGcmFtZSwgcGQuU2VyaWVzLCBucC5uZGFycmF5XSwKICAgICAgICBtb2RlbF9wYXRoOiBVbmlvbltzdHIsIG1scnVuLkRhdGFJdGVtXSwKICAgICAgICBkcm9wX2NvbHVtbnM6IFVuaW9uW3N0ciwgTGlzdFtzdHJdLCBpbnQsIExpc3RbaW50XV0gPSBOb25lLAogICAgICAgIGxhYmVsX2NvbHVtbnM6IFVuaW9uW3N0ciwgTGlzdFtzdHJdXSA9IE5vbmUsCiAgICAgICAgZmVhdHVyZV9jb2x1bW5zOiBVbmlvbltzdHIsIExpc3Rbc3RyXV0gPSBOb25lLAogICAgICAgIGxvZ19yZXN1bHRfc2V0OiBib29sID0gVHJ1ZSwKICAgICAgICByZXN1bHRfc2V0X25hbWU6IHN0ciA9ICJwcmVkaWN0aW9uIiwKICAgICAgICBiYXRjaF9pZDogc3RyID0gTm9uZSwKICAgICAgICBhcnRpZmFjdHNfdGFnOiBzdHIgPSAiIiwKICAgICAgICAjIERyaWZ0IGFuYWx5c2lzIHBhcmFtZXRlcnMKICAgICAgICBwZXJmb3JtX2RyaWZ0X2FuYWx5c2lzOiBib29sID0gTm9uZSwKICAgICAgICBlbmRwb2ludF9pZDogc3RyID0gIiIsCiAgICAgICAgIyBUaGUgZm9sbG93aW5nIG1vZGVsIGVuZHBvaW50IHBhcmFtZXRlcnMgYXJlIHJlbGV2YW50IG9ubHkgaWY6CiAgICAgICAgIyBwZXJmb3JtIGRyaWZ0IGFuYWx5c2lzIGlzIG5vdCBkaXNhYmxlZAogICAgICAgICMgYSBuZXcgbW9kZWwgZW5kcG9pbnQgcmVjb3JkIGlzIGdvaW5nIHRvIGJlIGdlbmVyYXRlZAogICAgICAgIG1vZGVsX2VuZHBvaW50X25hbWU6IHN0ciA9ICJiYXRjaC1pbmZlciIsCiAgICAgICAgbW9kZWxfZW5kcG9pbnRfc2FtcGxlX3NldDogVW5pb25bCiAgICAgICAgICAgIG1scnVuLkRhdGFJdGVtLCBsaXN0LCBkaWN0LCBwZC5EYXRhRnJhbWUsIHBkLlNlcmllcywgbnAubmRhcnJheQogICAgICAgIF0gPSBOb25lLAoKICAgICAgICAjIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHZlcnNpb25pbmcgbWVjaGFuaXNtIGlzIGltcGxlbWVudGVkCiAgICAgICAgIyBUT0RPOiBSZW1vdmUgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIG9uY2UgRkhVQi0xMyBpcyByZXNvbHZlZAogICAgICAgIHRyaWdnZXJfbW9uaXRvcmluZ19qb2I6IE9wdGlvbmFsW2Jvb2xdID0gTm9uZSwKICAgICAgICBiYXRjaF9pbWFnZV9qb2I6IE9wdGlvbmFsW3N0cl0gPSBOb25lLAogICAgICAgIG1vZGVsX2VuZHBvaW50X2RyaWZ0X3RocmVzaG9sZDogT3B0aW9uYWxbZmxvYXRdID0gTm9uZSwKICAgICAgICBtb2RlbF9lbmRwb2ludF9wb3NzaWJsZV9kcmlmdF90aHJlc2hvbGQ6IE9wdGlvbmFsW2Zsb2F0XSA9IE5vbmUsCgogICAgICAgICMgcHJlZGljdGlvbiBrd2FyZ3MgdG8gcGFzcyB0byB0aGUgbW9kZWwgcHJlZGljdCBmdW5jdGlvbgogICAgICAgICoqcHJlZGljdF9rd2FyZ3M6IERpY3Rbc3RyLCBBbnldLAoKKToKICAgICIiIgogICAgUGVyZm9ybSBhIHByZWRpY3Rpb24gb24gdGhlIHByb3ZpZGVkIGRhdGFzZXQgdXNpbmcgdGhlIHNwZWNpZmllZCBtb2RlbC4KICAgIEVuc3VyZSB0aGF0IHRoZSBtb2RlbCBoYXMgYWxyZWFkeSBiZWVuIGxvZ2dlZCB1bmRlciB0aGUgY3VycmVudCBwcm9qZWN0LgoKICAgIElmIHlvdSB3aXNoIHRvIGFwcGx5IG1vbml0b3JpbmcgdG9vbHMgKGUuZy4sIGRyaWZ0IGFuYWx5c2lzKSwgc2V0IHRoZSBwZXJmb3JtX2RyaWZ0X2FuYWx5c2lzIHBhcmFtZXRlciB0byBUcnVlLgogICAgVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyBtb2RlbCBlbmRwb2ludCByZWNvcmQgdW5kZXIgdGhlIHNwZWNpZmllZCBtb2RlbF9lbmRwb2ludF9uYW1lLgogICAgQWRkaXRpb25hbGx5LCBlbnN1cmUgdGhhdCBtb2RlbCBtb25pdG9yaW5nIGlzIGVuYWJsZWQgYXQgdGhlIHByb2plY3QgbGV2ZWwgYnkgY2FsbGluZyB0aGUKICAgIHByb2plY3QuZW5hYmxlX21vZGVsX21vbml0b3JpbmcoKSBmdW5jdGlvbi4gWW91IGNhbiBhbHNvIGFwcGx5IG1vbml0b3JpbmcgdG8gYW4gZXhpc3RpbmcgbW9kZWwgYnkgcHJvdmlkaW5nIGl0cwogICAgZW5kcG9pbnQgaWQgb3IgbmFtZSwgYW5kIHRoZSBtb25pdG9yaW5nIHRvb2xzIHdpbGwgYmUgYXBwbGllZCB0byB0aGF0IGVuZHBvaW50LgoKICAgIEF0IHRoZSBtb21lbnQsIHRoaXMgZnVuY3Rpb24gaXMgc3VwcG9ydGVkIGZvciBgbWxydW4+PTEuNS4wYCB2ZXJzaW9ucy4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNTFJ1biBjb250ZXh0LgogICAgOnBhcmFtIGRhdGFzZXQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGFzZXQgdG8gaW5mZXIgdGhyb3VnaCB0aGUgbW9kZWwuIFByb3ZpZGVkIGFzIGFuIGlucHV0IChEYXRhSXRlbSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgcmVwcmVzZW50cyBEYXRhc2V0IGFydGlmYWN0IC8gRmVhdHVyZSB2ZWN0b3IgVVJJLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdXNpbmcgTUxSdW4gU0RLLCBgZGF0YXNldGAgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBsaXN0LCBkaWN0aW9uYXJ5IG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1weSBhcnJheS4KICAgIDpwYXJhbSBtb2RlbF9wYXRoOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGVsIHN0b3JlIHVyaSAoc2hvdWxkIHN0YXJ0IHdpdGggc3RvcmU6Ly8pLiBQcm92aWRlZCBhcyBhbiBpbnB1dCAoRGF0YUl0ZW0pLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdXNpbmcgTUxSdW4gU0RLLCBgbW9kZWxfcGF0aGAgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBwYXJhbWV0ZXIgKHN0cmluZykuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUbyBnZW5lcmF0ZSBhIHZhbGlkIG1vZGVsIHN0b3JlIFVSSSwgcGxlYXNlIGxvZyB0aGUgbW9kZWwgYmVmb3JlIHJ1bm5pbmcgdGhpcyBmdW5jdGlvbi4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGBlbmRwb2ludF9pZGAgb2YgZXhpc3RpbmcgbW9kZWwgZW5kcG9pbnQgaXMgcHJvdmlkZWQsIG1ha2Ugc3VyZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBpdCBoYXMgYSBzaW1pbGFyIG1vZGVsIHN0b3JlIHBhdGgsIG90aGVyd2lzZSB0aGUgZHJpZnQgYW5hbHlzaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvbid0IGJlIHRyaWdnZXJlZC4KICAgIDpwYXJhbSBkcm9wX2NvbHVtbnM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nIC8gaW50ZWdlciBvciBhIGxpc3Qgb2Ygc3RyaW5ncyAvIGludGVnZXJzIHRoYXQgcmVwcmVzZW50IHRoZSBjb2x1bW4gbmFtZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gaW5kaWNlcyB0byBkcm9wLiBXaGVuIHRoZSBkYXRhc2V0IGlzIGEgbGlzdCBvciBhIG51bXB5IGFycmF5IHRoaXMgcGFyYW1ldGVyIG11c3QKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHJlcHJlc2VudGVkIGJ5IGludGVnZXJzLgogICAgOnBhcmFtIGxhYmVsX2NvbHVtbnM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHRhcmdldCBsYWJlbChzKSBvZiB0aGUgY29sdW1uKHMpIGluIHRoZSBkYXRhc2V0IGZvciBSZWdyZXNzaW9uIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzc2lmaWNhdGlvbiB0YXNrcy4gVGhlIGxhYmVsIGNvbHVtbiBjYW4gYmUgYWNjZXNzZWQgZnJvbSB0aGUgbW9kZWwgb2JqZWN0LCBvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZlYXR1cmUgdmVjdG9yIHByb3ZpZGVkIGlmIGF2YWlsYWJsZS4KICAgIDpwYXJhbSBmZWF0dXJlX2NvbHVtbnM6ICAgICAgICAgICAgICAgICAgICAgICAgIExpc3Qgb2YgZmVhdHVyZSBjb2x1bW5zIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBkYXRhZnJhbWUgd2hlbiBkYXRhc2V0IGlzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHR5cGUgbGlzdCBvciBudW1weSBhcnJheS4KICAgIDpwYXJhbSBsb2dfcmVzdWx0X3NldDogICAgICAgICAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdG8gbG9nIHRoZSByZXN1bHQgc2V0IC0gYSBEYXRhRnJhbWUgb2YgdGhlIGdpdmVuIGlucHV0cyBjb25jYXRlbmF0ZWQgd2l0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByZWRpY3Rpb25zLiBEZWZhdWx0ZWQgdG8gVHJ1ZS4KICAgIDpwYXJhbSByZXN1bHRfc2V0X25hbWU6ICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkYiBrZXkgdG8gc2V0IG5hbWUgb2YgdGhlIHByZWRpY3Rpb24gcmVzdWx0IGFuZCB0aGUgZmlsZW5hbWUuIERlZmF1bHRlZCB0bwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByZWRpY3Rpb24nLgogICAgOnBhcmFtIGJhdGNoX2lkOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIElEIG9mIHRoZSBnaXZlbiBiYXRjaCAoaW5mZXJlbmNlIGRhdGFzZXQpLiBJZiBgTm9uZWAsIGl0IHdpbGwgYmUgZ2VuZXJhdGVkLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2lsbCBiZSBsb2dnZWQgYXMgYSByZXN1bHQgb2YgdGhlIHJ1bi4KICAgIDpwYXJhbSBhcnRpZmFjdHNfdGFnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIFRhZyB0byB1c2UgZm9yIHByZWRpY3Rpb24gc2V0IHJlc3VsdCBhcnRpZmFjdC4KICAgIDpwYXJhbSBwZXJmb3JtX2RyaWZ0X2FuYWx5c2lzOiAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdG8gcGVyZm9ybSBkcmlmdCBhbmFseXNpcyBiZXR3ZWVuIHRoZSBzYW1wbGUgc2V0IG9mIHRoZSBtb2RlbCBvYmplY3QgdG8gdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0IGdpdmVuLiBCeSBkZWZhdWx0LCBOb25lLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcmZvcm0gZHJpZnQgYW5hbHlzaXMgaWYgdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCBhbHJlYWR5IGhhcyBmZWF0dXJlIHN0YXRzIHRoYXQgYXJlIGNvbnNpZGVyZWQgYXMgYSByZWZlcmVuY2Ugc2FtcGxlIHNldC4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBlcmZvcm1pbmcgZHJpZnQgYW5hbHlzaXMgb24gYSBuZXcgZW5kcG9pbnQgaWQgd2lsbCBnZW5lcmF0ZSBhIG5ldyBtb2RlbCBlbmRwb2ludAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLgogICAgOnBhcmFtIGVuZHBvaW50X2lkOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kZWwgZW5kcG9pbnQgdW5pcXVlIElELiBJZiBgcGVyZm9ybV9kcmlmdF9hbmFseXNpc2Agd2FzIHNldCwgdGhlIGVuZHBvaW50X2lkCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHVzZWQgZWl0aGVyIHRvIHBlcmZvcm0gdGhlIGFuYWx5c2lzIG9uIGV4aXN0aW5nIG1vZGVsIGVuZHBvaW50IG9yIHRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZSBhIG5ldyBtb2RlbCBlbmRwb2ludCByZWNvcmQuCiAgICA6cGFyYW0gbW9kZWxfZW5kcG9pbnRfbmFtZTogICAgICAgICAgICAgICAgICAgICBJZiBhIG5ldyBtb2RlbCBlbmRwb2ludCBpcyBnZW5lcmF0ZWQsIHRoZSBtb2RlbCBuYW1lIHdpbGwgYmUgcHJlc2VudGVkIHVuZGVyIHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50LgogICAgOnBhcmFtIG1vZGVsX2VuZHBvaW50X3NhbXBsZV9zZXQ6ICAgICAgICAgICAgICAgQSBzYW1wbGUgZGF0YXNldCB0byBnaXZlIHRvIGNvbXBhcmUgdGhlIGlucHV0cyBpbiB0aGUgZHJpZnQgYW5hbHlzaXMuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgcHJvdmlkZWQgYXMgYW4gaW5wdXQgKERhdGFJdGVtKSBvciBhcyBhIHBhcmFtZXRlciAoZS5nLiBzdHJpbmcsIGxpc3QsIERhdGFGcmFtZSkuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBjaG9zZW4gc2FtcGxlIHNldCB3aWxsIGFsd2F5cyBiZSB0aGUgb25lIHdobyBpcyBzZXQgaW4gdGhlIG1vZGVsIGFydGlmYWN0IGl0c2VsZi4KICAgIDpwYXJhbSB0cmlnZ2VyX21vbml0b3Jpbmdfam9iOiAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdG8gdHJpZ2dlciB0aGUgYmF0Y2ggZHJpZnQgYW5hbHlzaXMgYWZ0ZXIgdGhlIGluZmVyIGpvYi4KICAgIDpwYXJhbSBiYXRjaF9pbWFnZV9qb2I6ICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBpbWFnZSB0aGF0IHdpbGwgYmUgdXNlZCB0byByZWdpc3RlciB0aGUgbW9uaXRvcmluZyBiYXRjaCBqb2IgaWYgbm90IGV4aXN0LgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQnkgZGVmYXVsdCwgdGhlIGltYWdlIGlzIG1scnVuL21scnVuLgogICAgOnBhcmFtIG1vZGVsX2VuZHBvaW50X2RyaWZ0X3RocmVzaG9sZDogICAgICAgICAgVGhlIHRocmVzaG9sZCBvZiB3aGljaCB0byBtYXJrIGRyaWZ0cy4gRGVmYXVsdGVkIHRvIDAuNy4KICAgIDpwYXJhbSBtb2RlbF9lbmRwb2ludF9wb3NzaWJsZV9kcmlmdF90aHJlc2hvbGQ6IFRoZSB0aHJlc2hvbGQgb2Ygd2hpY2ggdG8gbWFyayBwb3NzaWJsZSBkcmlmdHMuIERlZmF1bHRlZCB0byAwLjUuCgogICAgcmFpc2VzIE1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3I6IGlmIGJvdGggYG1vZGVsX3BhdGhgIGFuZCBgZW5kcG9pbnRfaWRgIGFyZSBub3QgcHJvdmlkZWQKICAgICIiIgoKCiAgICBpZiB0cmlnZ2VyX21vbml0b3Jpbmdfam9iOgogICAgICAgIGNvbnRleHQubG9nZ2VyLndhcm5pbmcoIlRoZSBgdHJpZ2dlcl9tb25pdG9yaW5nX2pvYmAgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSB2ZXJzaW9uaW5nIG1lY2hhbmlzbSBpcyBpbXBsZW1lbnRlZC4gIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlmIHlvdSBhcmUgdXNpbmcgbWxydW48MS43LjAsIHBsZWFzZSBpbXBvcnQgdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgZm9yIGV4YW1wbGUgIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIidodWI6Ly9iYXRjaF9pbmZlcmVuY2VfdjI6Mi41LjAnLiIpCiAgICBpZiBiYXRjaF9pbWFnZV9qb2I6CiAgICAgICAgY29udGV4dC5sb2dnZXIud2FybmluZygiVGhlIGBiYXRjaF9pbWFnZV9qb2JgIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgb25jZSB0aGUgdmVyc2lvbmluZyBtZWNoYW5pc20gaXMgaW1wbGVtZW50ZWQuICIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZiB5b3UgYXJlIHVzaW5nIG1scnVuPDEuNy4wLCBwbGVhc2UgaW1wb3J0IHRoZSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIGZvciBleGFtcGxlICIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICInaHViOi8vYmF0Y2hfaW5mZXJlbmNlX3YyOjIuNS4wJy4iKQogICAgaWYgbW9kZWxfZW5kcG9pbnRfZHJpZnRfdGhyZXNob2xkOgogICAgICAgIGNvbnRleHQubG9nZ2VyLndhcm5pbmcoIlRoZSBgbW9kZWxfZW5kcG9pbnRfZHJpZnRfdGhyZXNob2xkYCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHZlcnNpb25pbmcgbWVjaGFuaXNtIGlzIGltcGxlbWVudGVkLiAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWYgeW91IGFyZSB1c2luZyBtbHJ1bjwxLjcuMCwgcGxlYXNlIGltcG9ydCB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uLCBmb3IgZXhhbXBsZSAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiJ2h1YjovL2JhdGNoX2luZmVyZW5jZV92MjoyLjUuMCcuIikKICAgIGlmIG1vZGVsX2VuZHBvaW50X3Bvc3NpYmxlX2RyaWZ0X3RocmVzaG9sZDoKICAgICAgICBjb250ZXh0LmxvZ2dlci53YXJuaW5nKCJUaGUgYG1vZGVsX2VuZHBvaW50X3Bvc3NpYmxlX2RyaWZ0X3RocmVzaG9sZGAgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSB2ZXJzaW9uaW5nIG1lY2hhbmlzbSBpcyBpbXBsZW1lbnRlZC4gIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlmIHlvdSBhcmUgdXNpbmcgbWxydW48MS43LjAsIHBsZWFzZSBpbXBvcnQgdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgZm9yIGV4YW1wbGUgIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIidodWI6Ly9iYXRjaF9pbmZlcmVuY2VfdjI6Mi41LjAnLiIpCgogICAgIyBMb2FkaW5nIHRoZSBtb2RlbDoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oZiJMb2FkaW5nIG1vZGVsLi4uIikKICAgIGlmIGlzaW5zdGFuY2UobW9kZWxfcGF0aCwgbWxydW4uRGF0YUl0ZW0pOgogICAgICAgIG1vZGVsX3BhdGggPSBtb2RlbF9wYXRoLmFydGlmYWN0X3VybAogICAgaWYgbm90IG1scnVuLmRhdGFzdG9yZS5pc19zdG9yZV91cmkobW9kZWxfcGF0aCk6CiAgICAgICAgcmFpc2UgbWxydW4uZXJyb3JzLk1MUnVuSW52YWxpZEFyZ3VtZW50RXJyb3IoCiAgICAgICAgICAgIGYiVGhlIHByb3ZpZGVkIG1vZGVsIHBhdGggKHttb2RlbF9wYXRofSkgaXMgaW52YWxpZCAtIHNob3VsZCBzdGFydCB3aXRoIGBzdG9yZTovL2AuICIKICAgICAgICAgICAgZiJQbGVhc2UgbWFrZSBzdXJlIHRoYXQgeW91IGhhdmUgbG9nZ2VkIHRoZSBtb2RlbCB1c2luZyBgcHJvamVjdC5sb2dfbW9kZWwoKWAgIgogICAgICAgICAgICBmIndoaWNoIGdlbmVyYXRlcyBhIHVuaXF1ZSBzdG9yZSB1cmkgZm9yIHRoZSBsb2dnZWQgbW9kZWwuIgogICAgICAgICkKICAgIG1vZGVsX2hhbmRsZXIgPSBBdXRvTUxSdW4ubG9hZF9tb2RlbChtb2RlbF9wYXRoPW1vZGVsX3BhdGgsIGNvbnRleHQ9Y29udGV4dCkKCiAgICBpZiBsYWJlbF9jb2x1bW5zIGlzIE5vbmU6CiAgICAgICAgbGFiZWxfY29sdW1ucyA9IFsKICAgICAgICAgICAgb3V0cHV0Lm5hbWUgZm9yIG91dHB1dCBpbiBtb2RlbF9oYW5kbGVyLl9tb2RlbF9hcnRpZmFjdC5zcGVjLm91dHB1dHMKICAgICAgICBdCgogICAgaWYgZmVhdHVyZV9jb2x1bW5zIGlzIE5vbmU6CiAgICAgICAgZmVhdHVyZV9jb2x1bW5zID0gWwogICAgICAgICAgICBpbnB1dC5uYW1lIGZvciBpbnB1dCBpbiBtb2RlbF9oYW5kbGVyLl9tb2RlbF9hcnRpZmFjdC5zcGVjLmlucHV0cwogICAgICAgIF0KCiAgICAjIEdldCBkYXRhc2V0IGJ5IG9iamVjdCwgVVJMIG9yIGJ5IEZlYXR1cmVWZWN0b3I6CiAgICBjb250ZXh0LmxvZ2dlci5pbmZvKGYiTG9hZGluZyBkYXRhLi4uIikKICAgIHgsIGxhYmVsX2NvbHVtbnMgPSBtbHJ1bi5tb2RlbF9tb25pdG9yaW5nLmFwaS5yZWFkX2RhdGFzZXRfYXNfZGF0YWZyYW1lKAogICAgICAgIGRhdGFzZXQ9ZGF0YXNldCwKICAgICAgICBmZWF0dXJlX2NvbHVtbnM9ZmVhdHVyZV9jb2x1bW5zLAogICAgICAgIGxhYmVsX2NvbHVtbnM9bGFiZWxfY29sdW1ucywKICAgICAgICBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zLAogICAgKQoKICAgICMgUHJlZGljdDoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oZiJDYWxjdWxhdGluZyBwcmVkaWN0aW9uLi4uIikKICAgIHlfcHJlZCA9IG1vZGVsX2hhbmRsZXIubW9kZWwucHJlZGljdCh4LCAqKnByZWRpY3Rfa3dhcmdzKQoKICAgICMgUHJlcGFyZSB0aGUgcmVzdWx0IHNldDoKICAgIHJlc3VsdF9zZXQgPSBfcHJlcGFyZV9yZXN1bHRfc2V0KHg9eCwgbGFiZWxfY29sdW1ucz1sYWJlbF9jb2x1bW5zLCB5X3ByZWQ9eV9wcmVkKQoKICAgICMgQ2hlY2sgZm9yIGxvZ2dpbmcgdGhlIHJlc3VsdCBzZXQ6CiAgICBpZiBsb2dfcmVzdWx0X3NldDoKICAgICAgICBtbHJ1bi5tb2RlbF9tb25pdG9yaW5nLmFwaS5sb2dfcmVzdWx0KAogICAgICAgICAgICBjb250ZXh0PWNvbnRleHQsCiAgICAgICAgICAgIHJlc3VsdF9zZXRfbmFtZT1yZXN1bHRfc2V0X25hbWUsCiAgICAgICAgICAgIHJlc3VsdF9zZXQ9cmVzdWx0X3NldCwKICAgICAgICAgICAgYXJ0aWZhY3RzX3RhZz1hcnRpZmFjdHNfdGFnLAogICAgICAgICAgICBiYXRjaF9pZD1iYXRjaF9pZCwKICAgICAgICApCgogICAgIyBDaGVjayBmb3IgcGVyZm9ybWluZyBkcmlmdCBhbmFseXNpcwogICAgaWYgKAogICAgICAgICAgICBwZXJmb3JtX2RyaWZ0X2FuYWx5c2lzIGlzIE5vbmUKICAgICAgICAgICAgYW5kIG1vZGVsX2hhbmRsZXIuX21vZGVsX2FydGlmYWN0LnNwZWMuZmVhdHVyZV9zdGF0cyBpcyBub3QgTm9uZQogICAgKToKICAgICAgICBwZXJmb3JtX2RyaWZ0X2FuYWx5c2lzID0gVHJ1ZQogICAgaWYgcGVyZm9ybV9kcmlmdF9hbmFseXNpczoKICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKCJQZXJmb3JtaW5nIGRyaWZ0IGFuYWx5c2lzLi4uIikKICAgICAgICAjIEdldCB0aGUgc2FtcGxlIHNldCBzdGF0aXN0aWNzIChlaXRoZXIgZnJvbSB0aGUgc2FtcGxlIHNldCBvciBmcm9tIHRoZSBzdGF0aXN0aWNzIGxvZ2dlZCB3aXRoIHRoZSBtb2RlbCkKICAgICAgICBzdGF0aXN0aWNzX2lucHV0X2ZpbHRlcmVkID0gX2dldF9zYW1wbGVfc2V0X3N0YXRpc3RpY3NfcGFyYW1ldGVycygKICAgICAgICAgICAgY29udGV4dD1jb250ZXh0LAogICAgICAgICAgICBtb2RlbF9lbmRwb2ludF9zYW1wbGVfc2V0PW1vZGVsX2VuZHBvaW50X3NhbXBsZV9zZXQsCiAgICAgICAgICAgIG1vZGVsX2FydGlmYWN0X2ZlYXR1cmVfc3RhdHM9bW9kZWxfaGFuZGxlci5fbW9kZWxfYXJ0aWZhY3Quc3BlYy5mZWF0dXJlX3N0YXRzLAogICAgICAgICAgICBmZWF0dXJlX2NvbHVtbnM9ZmVhdHVyZV9jb2x1bW5zLAogICAgICAgICAgICBkcm9wX2NvbHVtbnM9ZHJvcF9jb2x1bW5zLAogICAgICAgICAgICBsYWJlbF9jb2x1bW5zPWxhYmVsX2NvbHVtbnMpCiAgICAgICAgc2FtcGxlX3NldF9zdGF0aXN0aWNzID0gbWxydW4ubW9kZWxfbW9uaXRvcmluZy5hcGkuZ2V0X3NhbXBsZV9zZXRfc3RhdGlzdGljcygqKnN0YXRpc3RpY3NfaW5wdXRfZmlsdGVyZWQpCiAgICAgICAgbWxydW4ubW9kZWxfbW9uaXRvcmluZy5hcGkucmVjb3JkX3Jlc3VsdHMoCiAgICAgICAgICAgIHByb2plY3Q9Y29udGV4dC5wcm9qZWN0LAogICAgICAgICAgICBjb250ZXh0PWNvbnRleHQsCiAgICAgICAgICAgIGVuZHBvaW50X2lkPWVuZHBvaW50X2lkLAogICAgICAgICAgICBtb2RlbF9wYXRoPW1vZGVsX3BhdGgsCiAgICAgICAgICAgIG1vZGVsX2VuZHBvaW50X25hbWU9bW9kZWxfZW5kcG9pbnRfbmFtZSwKICAgICAgICAgICAgaW5mZXJfcmVzdWx0c19kZj1yZXN1bHRfc2V0LmNvcHkoKSwKICAgICAgICAgICAgc2FtcGxlX3NldF9zdGF0aXN0aWNzPXNhbXBsZV9zZXRfc3RhdGlzdGljcywKICAgICAgICAp
    code_origin: ''
    auto_build: false
    origin_filename: ''
  entry_points:
    infer:
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context.
      - name: dataset
        type: Union[DataItem, list, dict, DataFrame, Series, ndarray]
        doc: The dataset to infer through the model. Provided as an input (DataItem)
          that represents Dataset artifact / Feature vector URI. If using MLRun SDK,
          `dataset` can also be provided as a list, dictionary or numpy array.
      - name: model_path
        type: Union[str, DataItem]
        doc: Model store uri (should start with store://). Provided as an input (DataItem).
          If using MLRun SDK, `model_path` can also be provided as a parameter (string).
          To generate a valid model store URI, please log the model before running
          this function. If `endpoint_id` of existing model endpoint is provided,
          make sure that it has a similar model store path, otherwise the drift analysis
          won't be triggered.
      - name: drop_columns
        type: Union[str, List[str], int, List[int]]
        doc: A string / integer or a list of strings / integers that represent the
          column names / indices to drop. When the dataset is a list or a numpy array
          this parameter must be represented by integers.
        default: null
      - name: label_columns
        type: Union[str, List[str]]
        doc: The target label(s) of the column(s) in the dataset for Regression or
          Classification tasks. The label column can be accessed from the model object,
          or the feature vector provided if available.
        default: null
      - name: feature_columns
        type: Union[str, List[str]]
        doc: List of feature columns that will be used to build the dataframe when
          dataset is from type list or numpy array.
        default: null
      - name: log_result_set
        type: bool
        doc: Whether to log the result set - a DataFrame of the given inputs concatenated
          with the predictions. Defaulted to True.
        default: true
      - name: result_set_name
        type: str
        doc: The db key to set name of the prediction result and the filename. Defaulted
          to 'prediction'.
        default: prediction
      - name: batch_id
        type: str
        doc: The ID of the given batch (inference dataset). If `None`, it will be
          generated. Will be logged as a result of the run.
        default: null
      - name: artifacts_tag
        type: str
        doc: Tag to use for prediction set result artifact.
        default: ''
      - name: perform_drift_analysis
        type: bool
        doc: Whether to perform drift analysis between the sample set of the model
          object to the dataset given. By default, None, which means it will perform
          drift analysis if the model already has feature stats that are considered
          as a reference sample set. Performing drift analysis on a new endpoint id
          will generate a new model endpoint record.
        default: null
      - name: endpoint_id
        type: str
        doc: Model endpoint unique ID. If `perform_drift_analysis` was set, the endpoint_id
          will be used either to perform the analysis on existing model endpoint or
          to generate a new model endpoint record.
        default: ''
      - name: model_endpoint_name
        type: str
        doc: If a new model endpoint is generated, the model name will be presented
          under this endpoint.
        default: batch-infer
      - name: model_endpoint_sample_set
        type: Union[DataItem, list, dict, DataFrame, Series, ndarray]
        doc: A sample dataset to give to compare the inputs in the drift analysis.
          Can be provided as an input (DataItem) or as a parameter (e.g. string, list,
          DataFrame). The default chosen sample set will always be the one who is
          set in the model artifact itself.
        default: null
      - name: trigger_monitoring_job
        type: Optional[bool]
        doc: Whether to trigger the batch drift analysis after the infer job.
        default: null
      - name: batch_image_job
        type: Optional[str]
        doc: The image that will be used to register the monitoring batch job if not
          exist. By default, the image is mlrun/mlrun.
        default: null
      - name: model_endpoint_drift_threshold
        type: Optional[float]
        doc: The threshold of which to mark drifts. Defaulted to 0.7.
        default: null
      - name: model_endpoint_possible_drift_threshold
        type: Optional[float]
        doc: The threshold of which to mark possible drifts. Defaulted to 0.5.
        default: null
      has_kwargs: true
      lineno: 102
      name: infer
      doc: 'Perform a prediction on the provided dataset using the specified model.

        Ensure that the model has already been logged under the current project.


        If you wish to apply monitoring tools (e.g., drift analysis), set the perform_drift_analysis
        parameter to True.

        This will create a new model endpoint record under the specified model_endpoint_name.

        Additionally, ensure that model monitoring is enabled at the project level
        by calling the

        project.enable_model_monitoring() function. You can also apply monitoring
        to an existing model by providing its

        endpoint id or name, and the monitoring tools will be applied to that endpoint.


        At the moment, this function is supported for `mlrun>=1.5.0` versions.'
      has_varargs: false
verbose: false
metadata:
  name: batch-inference-v2
  tag: ''
  categories:
  - utils
  - data-analysis
  - monitoring
kind: job
