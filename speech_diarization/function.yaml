kind: job
metadata:
  name: speech-diarization
  tag: ''
  hash: 2486500a2579a422fb586752aadc02a58427f60f
  project: ''
  labels:
    author: guyl
  categories:
  - Utilities
  - Machine Learning
spec:
  command: ''
  args: []
  image: mlrun/mlrun
  build:
    functionSourceCode: IyBDb3B5cmlnaHQgMjAyMyBJZ3VhemlvCiMKIyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKIyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiMgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiMKIyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAojCiMgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQojIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiMgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiMgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAojIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoKaW1wb3J0IGhlYXBxCmltcG9ydCBsb2dnaW5nCmltcG9ydCBvcGVyYXRvcgppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKZnJvbSBmdW5jdG9vbHMgaW1wb3J0IHJlZHVjZSwgd3JhcHMKZnJvbSB0eXBpbmcgaW1wb3J0IEFueSwgRGljdCwgTGlzdCwgVHVwbGUsIFVuaW9uCgppbXBvcnQgcGFuZGFzIGFzIHBkCmltcG9ydCBweWFubm90ZS5hdWRpbwppbXBvcnQgcHlhbm5vdGUuY29yZQppbXBvcnQgdG9yY2gKaW1wb3J0IHRvcmNoYXVkaW8KZnJvbSB0cWRtIGltcG9ydCB0cWRtCgojIEdldCB0aGUgZ2xvYmFsIGxvZ2dlcjoKX0xPR0dFUiA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCkKCgpkZWYgX2NoZWNrX21scnVuX2FuZF9vcGVuX21waSgpIC0+IFR1cGxlWyJtbHJ1bi5NTENsaWVudEN0eCIsICJtcGk0cHkuTVBJLkludHJhY29tbSJdOgogICAgaXNfbXBpID0gRmFsc2UKICAgIHRyeToKICAgICAgICBpbXBvcnQgbWxydW4KCiAgICAgICAgY29udGV4dCA9IG1scnVuLmdldF9vcl9jcmVhdGVfY3R4KG5hbWU9Im1scnVuIikKICAgICAgICBpc19tcGkgPSBjb250ZXh0LmxhYmVscy5nZXQoImtpbmQiLCAiam9iIikgPT0gIm1waWpvYiIKCiAgICAgICAgaWYgaXNfbXBpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBmcm9tIG1waTRweSBpbXBvcnQgTVBJCgogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQsIE1QSS5DT01NX1dPUkxECiAgICAgICAgICAgIGV4Y2VwdCBNb2R1bGVOb3RGb3VuZEVycm9yIGFzIG1waTRweV9ub3RfZm91bmQ6CiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5lcnJvcigKICAgICAgICAgICAgICAgICAgICAiVG8gZGlzdHJpYnV0ZSB0aGUgZnVuY3Rpb24gdXNpbmcgTUxSdW4ncyAnbXBpam9iJyB5b3UgbmVlZCB0byBoYXZlIGBtcGk0cHlgIHBhY2thZ2UgaW4geW91ciAiCiAgICAgICAgICAgICAgICAgICAgImludGVycHJldGVyLiBQbGVhc2UgcnVuIGBwaXAgaW5zdGFsbCBtcGk0cHlgIGFuZCBtYWtlIHN1cmUgeW91IGhhdmUgb3Blbi1tcGkuIgogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgcmFpc2UgbXBpNHB5X25vdF9mb3VuZAogICAgZXhjZXB0IE1vZHVsZU5vdEZvdW5kRXJyb3IgYXMgbW9kdWxlX25vdF9mb3VuZDoKICAgICAgICBpZiBpc19tcGk6CiAgICAgICAgICAgIHJhaXNlIG1vZHVsZV9ub3RfZm91bmQKICAgIHJldHVybiBOb25lLCBOb25lCgoKZGVmIG9wZW5fbXBpX2hhbmRsZXIoCiAgICB3b3JrZXJfaW5wdXRzOiBMaXN0W3N0cl0sIHJvb3Rfd29ya2VyX2lucHV0czogRGljdFtzdHIsIEFueV0gPSBOb25lCik6CiAgICBnbG9iYWwgX0xPR0dFUgoKICAgICMgQ2hlY2sgZm9yIE1MUnVuIGFuZCBPcGVuTVBJIGF2YWlsYWJpbGl0eToKICAgIGNvbnRleHQsIGNvbW0gPSBfY2hlY2tfbWxydW5fYW5kX29wZW5fbXBpKCkKCiAgICAjIENoZWNrIGlmIE1MUnVuIGlzIGF2YWlsYWJsZSwgc2V0IHRoZSBnbG9iYWwgbG9nZ2VyIHRvIE1MUnVuJ3M6CiAgICBpZiBjb250ZXh0OgogICAgICAgIF9MT0dHRVIgPSBjb250ZXh0LmxvZ2dlcgoKICAgIGRlZiBkZWNvcmF0b3IoaGFuZGxlcik6CiAgICAgICAgaWYgY29tbSBpcyBOb25lIG9yIGNvbW0uR2V0X3NpemUoKSA9PSAxOgogICAgICAgICAgICByZXR1cm4gaGFuZGxlcgoKICAgICAgICBAd3JhcHMoaGFuZGxlcikKICAgICAgICBkZWYgd3JhcHBlcigqKmt3YXJncyk6CiAgICAgICAgICAgICMgR2V0IHRoZSBvcGVuIG1waSBlbnZpcm9ubWVudCBwcm9wZXJ0aWVzOgogICAgICAgICAgICBzaXplID0gY29tbS5HZXRfc2l6ZSgpCiAgICAgICAgICAgIHJhbmsgPSBjb21tLkdldF9yYW5rKCkKCiAgICAgICAgICAgICMgR2l2ZSB0aGUgY29ycmVjdCBjaHVuayBvZiB0aGUgd29ya2VycyBpbnB1dHM6CiAgICAgICAgICAgIGZvciB3b3JrZXJfaW5wdXQgaW4gd29ya2VyX2lucHV0czoKICAgICAgICAgICAgICAgIGlucHV0X2FyZ3VtZW50ID0ga3dhcmdzW3dvcmtlcl9pbnB1dF0KICAgICAgICAgICAgICAgIGlmIGlucHV0X2FyZ3VtZW50IGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoaW5wdXRfYXJndW1lbnQsIHN0cik6CiAgICAgICAgICAgICAgICAgICAgaW5wdXRfYXJndW1lbnQgPSBfZ2V0X2F1ZGlvX2ZpbGVzKAogICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3BhdGg9cGF0aGxpYi5QYXRoKGlucHV0X2FyZ3VtZW50KS5hYnNvbHV0ZSgpCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgaWYgbGVuKGlucHV0X2FyZ3VtZW50KSA8IHNpemU6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgICAgICAgICAgICAgZiJDYW5ub3Qgc3BsaXQgdGhlIGlucHV0ICd7d29ya2VyX2lucHV0fScgb2YgbGVuZ3RoIHtsZW4oaW5wdXRfYXJndW1lbnQpfSB0byB7c2l6ZX0gd29ya2Vycy4gIgogICAgICAgICAgICAgICAgICAgICAgICBmIlBsZWFzZSByZWR1Y2UgdGhlIGFtb3VudCBvZiB3b3JrZXJzIGZvciB0aGlzIGlucHV0LiIKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBldmVuX2NodW5rX3NpemUgPSBsZW4oaW5wdXRfYXJndW1lbnQpIC8vIHNpemUKICAgICAgICAgICAgICAgIGNodW5rX3N0YXJ0ID0gcmFuayAqIGV2ZW5fY2h1bmtfc2l6ZQogICAgICAgICAgICAgICAgY2h1bmtfZW5kID0gKAogICAgICAgICAgICAgICAgICAgIChyYW5rICsgMSkgKiBldmVuX2NodW5rX3NpemUKICAgICAgICAgICAgICAgICAgICBpZiByYW5rICsgMSA8IHNpemUKICAgICAgICAgICAgICAgICAgICBlbHNlIGxlbihpbnB1dF9hcmd1bWVudCkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8oCiAgICAgICAgICAgICAgICAgICAgZiJSYW5rICN7cmFua306IFByb2Nlc3NpbmcgaW5wdXQgY2h1bmsgb2YgJ3t3b3JrZXJfaW5wdXR9JyAiCiAgICAgICAgICAgICAgICAgICAgZiJmcm9tIGluZGV4IHtjaHVua19zdGFydH0gdG8ge2NodW5rX2VuZH0uIgogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShpbnB1dF9hcmd1bWVudCwgbGlzdCk6CiAgICAgICAgICAgICAgICAgICAgaW5wdXRfYXJndW1lbnQgPSBpbnB1dF9hcmd1bWVudFtjaHVua19zdGFydDpjaHVua19lbmRdCiAgICAgICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UoaW5wdXRfYXJndW1lbnQsIHBkLkRhdGFGcmFtZSk6CiAgICAgICAgICAgICAgICAgICAgaW5wdXRfYXJndW1lbnQgPSBpbnB1dF9hcmd1bWVudC5pbG9jW2NodW5rX3N0YXJ0OmNodW5rX2VuZDosIDpdCiAgICAgICAgICAgICAgICBrd2FyZ3Nbd29ya2VyX2lucHV0XSA9IGlucHV0X2FyZ3VtZW50CgogICAgICAgICAgICAjIFNldCB0aGUgcm9vdCB3b3JrZXIgb25seSBhcmd1bWVudHM6CiAgICAgICAgICAgIGlmIHJhbmsgPT0gMCBhbmQgcm9vdF93b3JrZXJfaW5wdXRzOgogICAgICAgICAgICAgICAga3dhcmdzLnVwZGF0ZShyb290X3dvcmtlcl9pbnB1dHMpCgogICAgICAgICAgICAjIFJ1biB0aGUgd29ya2VyOgogICAgICAgICAgICBvdXRwdXQgPSBoYW5kbGVyKCoqa3dhcmdzKQoKICAgICAgICAgICAgIyBTZW5kIHRoZSBvdXRwdXQgdG8gdGhlIHJvb3QgcmFuayAocmFuayAjMCk6CiAgICAgICAgICAgIG91dHB1dCA9IGNvbW0uZ2F0aGVyKG91dHB1dCwgcm9vdD0wKQogICAgICAgICAgICBpZiByYW5rID09IDA6CiAgICAgICAgICAgICAgICAjIEpvaW4gdGhlIG91dHB1dHM6CiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKCJDb2xsZWN0aW5nIGRhdGEgZnJvbSB3b3JrZXJzIHRvIHJvb3Qgd29ya2VyLiIpCiAgICAgICAgICAgICAgICBkaWFyaXphdGlvbl9kaWN0aW9uYXJ5ID0gcmVkdWNlKAogICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmlvciwgW2RpYSBmb3IgZGlhLCBfIGluIG91dHB1dF0sIHt9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBlcnJvcnNfZGljdGlvbmFyeSA9IHJlZHVjZShvcGVyYXRvci5pb3IsIFtlcnIgZm9yIF8sIGVyciBpbiBvdXRwdXRdLCB7fSkKICAgICAgICAgICAgICAgIHJldHVybiBkaWFyaXphdGlvbl9kaWN0aW9uYXJ5LCBlcnJvcnNfZGljdGlvbmFyeQogICAgICAgICAgICByZXR1cm4gTm9uZQoKICAgICAgICByZXR1cm4gd3JhcHBlcgoKICAgIHJldHVybiBkZWNvcmF0b3IKCgpAb3Blbl9tcGlfaGFuZGxlcih3b3JrZXJfaW5wdXRzPVsiZGF0YV9wYXRoIl0sIHJvb3Rfd29ya2VyX2lucHV0cz17InZlcmJvc2UiOiBUcnVlfSkKZGVmIGRpYXJpemUoCiAgICBkYXRhX3BhdGg6IFVuaW9uW3N0ciwgTGlzdFtzdHJdXSwKICAgIG1vZGVsX25hbWU6IHN0ciA9ICJweWFubm90ZS9zcGVha2VyLWRpYXJpemF0aW9uLTMuMCIsCiAgICBhY2Nlc3NfdG9rZW46IHN0ciA9IE5vbmUsCiAgICBkZXZpY2U6IHN0ciA9IE5vbmUsCiAgICBzcGVha2Vyc19sYWJlbHM6IExpc3Rbc3RyXSA9IE5vbmUsCiAgICBzcGVha2VyX3ByZWZpeDogc3RyID0gInNwZWFrZXJfIiwKICAgIHNlcGFyYXRlX2J5X2NoYW5uZWxzOiBib29sID0gRmFsc2UsCiAgICBtaW5pbXVtX3NwZWFrZXJzOiBpbnQgPSBOb25lLAogICAgbWF4aW11bV9zcGVha2VyczogaW50ID0gTm9uZSwKICAgIHZlcmJvc2U6IGJvb2wgPSBGYWxzZSwKKSAtPiBUdXBsZVtEaWN0W3N0ciwgTGlzdFtUdXBsZVtmbG9hdCwgZmxvYXQsIHN0cl1dXSwgRGljdFtzdHIsIHN0cl1dOgogICAgIiIiCiAgICBQZXJmb3JtIHNwZWVjaCBkaWFyaXphdGlvbiBvbiBnaXZlbiBhdWRpbyBmaWxlcyB1c2luZyBweWFubm90ZS1hdWRpbyAoaHR0cHM6Ly9naXRodWIuY29tL3B5YW5ub3RlL3B5YW5ub3RlLWF1ZGlvKS4KICAgIFRoZSBlbmQgcmVzdWx0IGlzIGEgZGljdGlvbmFyeSB3aXRoIHRoZSBmaWxlIG5hbWVzIGFzIGtleXMgYW5kIHRoZWlyIGRpYXJpemF0aW9uIGFzIHZhbHVlLiBBIGRpYXJpemF0aW9uIGlzIGEgbGlzdAogICAgb2YgdHVwbGVzOiAoc3RhcnQsIGVuZCwgc3BlYWtlcl9sYWJlbCkuCgogICAgVG8gdXNlIHRoZSBgcHlhbm5vdGUuYXVkaW9gIG1vZGVscyB5b3UgbXVzdCBwYXNzIGEgSHVnZ2luZ2ZhY2UgdG9rZW4gYW5kIGdldCBhY2Nlc3MgdG8gdGhlIHJlcXVpcmVkIG1vZGVscy4gVGhlCiAgICB0b2tlbiBjYW4gYmUgcGFzc2VkIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIG9wdGlvbnM6CgogICAgKiBVc2UgdGhlIHBhcmFtZXRlciBgYWNjZXNzX3Rva2VuYC4KICAgICogU2V0IGFuIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWVkICJIVUdHSU5HX0ZBQ0VfSFVCX1RPS0VOIi4KICAgICogSWYgdXNpbmcgTUxSdW4sIHlvdSBjYW4gcGFzcyBpdCBhcyBhIHNlY3JldCBuYW1lZCAiSFVHR0lOR19GQUNFX0hVQl9UT0tFTiIuCgogICAgVG8gZ2V0IGFjY2VzcyB0byB0aGUgbW9kZWxzIG9uIEh1Z2dpbmdmYWNlLCB2aXNpdCB0aGVpciBwYWdlLiBGb3IgZXhhbXBsZSwgdG8gdXNlIHRoZSBkZWZhdWx0IGRpYXJpemF0aW9uIG1vZGVsIHNldAogICAgaW4gdGhpcyBmdW5jdGlvbiAoInB5YW5ub3RlL3NwZWFrZXItZGlhcml6YXRpb24tMy4wIiksIHlvdSBuZWVkIGFjY2VzcyBmb3IgdGhlc2UgdHdvIG1vZGVsczoKCiAgICAqIGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vcHlhbm5vdGUvc2VnbWVudGF0aW9uLTMuMAogICAgKiBodHRwczovL2h1Z2dpbmdmYWNlLmNvL3B5YW5ub3RlL3NwZWFrZXItZGlhcml6YXRpb24tMy4wCgogICAgTm90ZTogVG8gY29udHJvbCB0aGUgcmVjb2duaXplZCBzcGVha2VycyBpbiB0aGUgZGlhcml6YXRpb24gb3V0cHV0IHlvdSBjYW4gY2hvb3NlIG9uZSBvZiB0aGUgZm9sbG93aW5nIG1ldGhvZHM6CgogICAgKiBGb3IgYSBrbm93biBzcGVha2VycyBhbW91bnQsIHlvdSBtYXkgc2V0IHNwZWFrZXIgbGFiZWxzIHZpYSB0aGUgYHNwZWFrZXJzX2xhYmVsc2AgcGFyYW1ldGVyIHRoYXQgd2lsbCBiZSB1c2VkIGluCiAgICAgIHRoZSBvcmRlciBvZiBzcGVha2luZyBpbiB0aGUgYXVkaW8gKGZpcnN0IHBlcnNvbiBzcGVha2luZyBiZSB0aGUgZmlyc3QgbGFiZWwgaW4gdGhlIGxpc3QpLiBJbiBhZGRpdGlvbiwgeW91IGNhbiBkbwogICAgICBkaWFyaXphdGlvbiBwZXIgY2hhbm5lbCAoc2V0dGluZyB0aGUgcGFyYW1ldGVyIGBzZXBhcmF0ZV9ieV9jaGFubmVsc2AgdG8gVHJ1ZSkuIEVhY2ggbGFiZWwgd2lsbCBiZSBhc3NpZ25lZCB0byBhCiAgICAgIHNwZWNpZmljIGNoYW5uZWwgYnkgb3JkZXIgKGZpcnN0IGxhYmVsIHRvIGNoYW5uZWwgMCwgc2Vjb25kIGxhYmVsIHRvIGNoYW5uZWwgMSBhbmQgc28gb24pLiBOb3RpY2UsIHRoaXMgd2lsbAogICAgICBpbmNyZWFzZSBydW50aW1lLgogICAgKiBGb3IgdW5rbm93biBzcGVha2VycyBhbW91bnQsIHlvdSBjYW4gc2V0IHRoZSBgc3BlYWtlcl9wcmVmaXhgIHBhcmFtZXRlciB0byBhZGQgYSBwcmVmaXggZm9yIGVhY2ggc3BlYWtlciBudW1iZXIuCiAgICAgIFlvdSBjYW4gYWxzbyBoZWxwIHRoZSBkaWFyaXphdGlvbiBieSBzZXR0aW5nIHRoZSBzcGVha2VycyByYW5nZSB2aWEgdGhlIGBzcGVha2Vyc19hbW91bnRfcmFuZ2VgIHBhcmFtZXRlci4KCiAgICA6cGFyYW0gZGF0YV9wYXRoOiAgICAgICAgICAgIEEgZGlyZWN0b3J5IG9mIHRoZSBhdWRpbyBmaWxlcywgYSBzaW5nbGUgZmlsZSBvciBhIGxpc3Qgb2YgZmlsZXMgdG8gdHJhbnNjcmliZS4KICAgIDpwYXJhbSBtb2RlbF9uYW1lOiAgICAgICAgICAgT25lIG9mIHRoZSBvZmZpY2lhbCBkaWFyaXphdGlvbiBtb2RlbCBuYW1lcyAocmVmZXJyZWQgYXMgZGlhcml6YXRpb24gcGlwZWxpbmVzKSBvZgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHlhbm5vdGUuYXVkaW9gIEh1Z2dpbmdmYWNlIHBhZ2UuIERlZmF1bHQ6ICJweWFubm90ZS9zcGVha2VyLWRpYXJpemF0aW9uLTMuMCIuCiAgICA6cGFyYW0gYWNjZXNzX3Rva2VuOiAgICAgICAgIEFuIGFjY2VzcyB0b2tlbiB0byBwYXNzIGZvciB1c2luZyB0aGUgYHB5YW5ub3RlLmF1ZGlvYCBtb2RlbHMuIElmIG5vdCBwcm92aWRlZCwgaXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBsb29raW5nIGZvciB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgIkhVR0dJTkdfRkFDRV9IVUJfVE9LRU4iLiBJZiBNTFJ1biBpcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUsIGl0IHdpbGwgbG9vayBmb3IgYSBzZWNyZXQgIkhVR0dJTkdfRkFDRV9IVUJfVE9LRU4iLgogICAgOnBhcmFtIGRldmljZTogICAgICAgICAgICAgICBEZXZpY2UgdG8gbG9hZCB0aGUgbW9kZWwuIENhbiBiZSBvbmUgb2YgeyJjdWRhIiwgImNwdSJ9LiBEZWZhdWx0IHdpbGwgcHJlZmVyICJjdWRhIiBpZgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuCiAgICA6cGFyYW0gc3BlYWtlcnNfbGFiZWxzOiAgICAgIExhYmVscyB0byB1c2UgZm9yIHRoZSByZWNvZ25pemVkIHNwZWFrZXJzLiBEZWZhdWx0OiBudW1lcmljIGxhYmVscyAoMCwgMSwgLi4uKS4KICAgIDpwYXJhbSBzZXBhcmF0ZV9ieV9jaGFubmVsczogSWYgZWFjaCBzcGVha2VyIGlzIHNwZWFraW5nIGluIGEgc2VwYXJhdGUgY2hhbm5lbCwgeW91IGNhbiBkaWFyaXplIGVhY2ggY2hhbm5lbCBhbmQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZSB0aGUgcmVzdWx0IGludG8gYSBzaW5nbGUgZGlhcml6YXRpb24uIEVhY2ggbGFiZWwgc2V0IGluIHRoZSBgc3BlYWtlcnNfbGFiZWxzYAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgd2lsbCBiZSBhc3NpZ25lZCB0byBhIHNwZWNpZmljIGNoYW5uZWwgYnkgb3JkZXIuCiAgICA6cGFyYW0gc3BlYWtlcl9wcmVmaXg6ICAgICAgIEEgcHJlZml4IHRvIGFkZCBmb3IgdGhlIHNwZWFrZXJzIGxhYmVscy4gVGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZCBpZgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc3BlYWtlcnNfbGFiZWxzYCBpcyBub3QgTm9uZS4gRGVmYXVsdDogInNwZWFrZXIiLgogICAgOnBhcmFtIG1pbmltdW1fc3BlYWtlcnM6ICAgICBTZXQgdGhlIG1pbmltdW0gZXhwZWN0ZWQgYW1vdW50IG9mIHNwZWFrZXJzIHRvIGJlIGluIHRoZSBhdWRpbyBmaWxlcy4gVGhpcyBwYXJhbWV0ZXIgaXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZCBpZiBgc3BlYWtlcnNfbGFiZWxzYCBpcyBub3QgTm9uZS4KICAgIDpwYXJhbSBtYXhpbXVtX3NwZWFrZXJzOiAgICAgU2V0IHRoZSBtYXhpbXVtIGV4cGVjdGVkIGFtb3VudCBvZiBzcGVha2VycyB0byBiZSBpbiB0aGUgYXVkaW8gZmlsZXMuIFRoaXMgcGFyYW1ldGVyIGlzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgaWYgYHNwZWFrZXJzX2xhYmVsc2AgaXMgbm90IE5vbmUuCiAgICA6cGFyYW0gdmVyYm9zZTogICAgICAgICAgICAgIFdoZXRoZXIgdG8gcHJlc2VudCBsb2dzIG9mIGEgcHJvZ3Jlc3MgYmFyIGFuZCBlcnJvcnMuIERlZmF1bHQ6IFRydWUuCgogICAgOnJldHVybnM6IEEgdHVwbGUgb2Y6CgogICAgICAgICAgICAgICogU3BlZWNoIGRpYXJpemF0aW9uIGRpY3Rpb25hcnkuCiAgICAgICAgICAgICAgKiBBIGRpY3Rpb25hcnkgb2YgZXJyb3JlZCBmaWxlcyB0aGF0IHdlcmUgbm90IHRyYW5zY3JpYmVkLgogICAgIiIiCiAgICBnbG9iYWwgX0xPR0dFUgoKICAgICMgR2V0IHRoZSBpbnB1dCBhdWRpbyBmaWxlcyB0byBkaWFyaXplOgogICAgaWYgaXNpbnN0YW5jZShkYXRhX3BhdGgsIHN0cik6CiAgICAgICAgZGF0YV9wYXRoID0gcGF0aGxpYi5QYXRoKGRhdGFfcGF0aCkuYWJzb2x1dGUoKQogICAgICAgIGF1ZGlvX2ZpbGVzID0gX2dldF9hdWRpb19maWxlcyhkYXRhX3BhdGg9ZGF0YV9wYXRoKQogICAgZWxzZTogICMgU2hvdWxkIGJlIGEgbGlzdCBvZiBmaWxlcy4KICAgICAgICBhdWRpb19maWxlcyA9IGRhdGFfcGF0aAoKICAgICMgR2V0IHRoZSBIdWdnaW5nZmFjZSBhY2Nlc3MgdG9rZW46CiAgICBhY2Nlc3NfdG9rZW4gPSBfZ2V0X2FjY2Vzc190b2tlbihwYXJhbWV0ZXI9YWNjZXNzX3Rva2VuKQogICAgaWYgYWNjZXNzX3Rva2VuIGlzIE5vbmU6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgIkEgSHVnZ2luZ2ZhY2UgYWNjZXNzIHRva2VuIG11c3QgYmUgcHJvdmlkZWQgdG8gdXNlIGBweWFubm90ZS5hdWRpb2AgbW9kZWxzLiBBY2Nlc3MgdG9rZW4gY2FuIGJlIHBhc3NlZCAiCiAgICAgICAgICAgICJ2aWEgb25lIG9mIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiIKICAgICAgICAgICAgIiogVXNlIHRoZSBwYXJhbWV0ZXIgYGFjY2Vzc190b2tlbmAuXG4iCiAgICAgICAgICAgICIqIFNldCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lZCAnSFVHR0lOR19GQUNFX0hVQl9UT0tFTicuXG4iCiAgICAgICAgICAgICIqIElmIHVzaW5nIE1MUnVuLCB5b3UgY2FuIHBhc3MgaXQgYXMgYSBzZWNyZXQgbmFtZWQgJ0hVR0dJTkdfRkFDRV9IVUJfVE9LRU4nLiIKICAgICAgICApCgogICAgIyBMb2FkIHRoZSBkaWFyaXphdGlvbiBwaXBlbGluZToKICAgIHBpcGVsaW5lID0gcHlhbm5vdGUuYXVkaW8uUGlwZWxpbmUuZnJvbV9wcmV0cmFpbmVkKAogICAgICAgIGNoZWNrcG9pbnRfcGF0aD1tb2RlbF9uYW1lLCB1c2VfYXV0aF90b2tlbj1hY2Nlc3NfdG9rZW4KICAgICkKCiAgICAjIFNldCB0aGUgZGV2aWNlOgogICAgZGV2aWNlID0gZGV2aWNlIG9yICgiY3VkYSIgaWYgdG9yY2guY3VkYS5pc19hdmFpbGFibGUoKSBlbHNlICJjcHUiKQogICAgaWYgZGV2aWNlICE9ICJjcHUiOgogICAgICAgIHBpcGVsaW5lLnRvKHRvcmNoLmRldmljZShkZXZpY2UpKQoKICAgICMgUHJlcGFyZSB0aGUgc3VjY2Vzc2VzIGRhdGFmcmFtZSBhbmQgZXJyb3JzIGRpY3Rpb25hcnkgdG8gYmUgcmV0dXJuZWQ6CiAgICBkaWFyaXphdGlvbnMgPSB7fQogICAgZXJyb3JzID0ge30KCiAgICAjIFByZXBhcmUgdGhlIGRpYXJpemF0aW9uIGtleXdvcmQgYXJndW1lbnRzOgogICAgZGlhcml6ZV9rd2FyZ3MgPSB7fQogICAgaWYgc3BlYWtlcnNfbGFiZWxzOgogICAgICAgIGRpYXJpemVfa3dhcmdzWyJudW1fc3BlYWtlcnMiXSA9IGxlbihzcGVha2Vyc19sYWJlbHMpCiAgICBlbHNlOgogICAgICAgIGlmIG1pbmltdW1fc3BlYWtlcnM6CiAgICAgICAgICAgIGRpYXJpemVfa3dhcmdzWyJtaW5fc3BlYWtlcnMiXSA9IG1pbmltdW1fc3BlYWtlcnMKICAgICAgICBpZiBtYXhpbXVtX3NwZWFrZXJzOgogICAgICAgICAgICBkaWFyaXplX2t3YXJnc1sibWF4X3NwZWFrZXJzIl0gPSBtYXhpbXVtX3NwZWFrZXJzCgogICAgIyBHbyBvdmVyIHRoZSBhdWRpbyBmaWxlcyBhbmQgZGlhcml6ZToKICAgIGZvciBhdWRpb19maWxlIGluIHRxZG0oCiAgICAgICAgYXVkaW9fZmlsZXMsIGRlc2M9IkRpYXJpemluZyIsIHVuaXQ9ImZpbGUiLCBkaXNhYmxlPW5vdCB2ZXJib3NlCiAgICApOgogICAgICAgIHRyeToKICAgICAgICAgICAgIyBMb2FkIGF1ZGlvIGZpbGU6CiAgICAgICAgICAgIGF1ZGlvLCBzYW1wbGVfcmF0ZSA9IHRvcmNoYXVkaW8ubG9hZCh1cmk9YXVkaW9fZmlsZSwgY2hhbm5lbHNfZmlyc3Q9VHJ1ZSkKICAgICAgICAgICAgIyBHZXQgdGhlIGRpYXJpemF0aW9uIChpZiBwcm92aWRlZCk6CiAgICAgICAgICAgIGRpYXJpemF0aW9uc1thdWRpb19maWxlLm5hbWVdID0gX2RpYXJpemUoCiAgICAgICAgICAgICAgICBhdWRpbz1hdWRpbywKICAgICAgICAgICAgICAgIHNhbXBsZV9yYXRlPXNhbXBsZV9yYXRlLAogICAgICAgICAgICAgICAgcGlwZWxpbmU9cGlwZWxpbmUsCiAgICAgICAgICAgICAgICBzcGVha2Vyc19sYWJlbHM9c3BlYWtlcnNfbGFiZWxzLAogICAgICAgICAgICAgICAgc2VwYXJhdGVfYnlfY2hhbm5lbHM9c2VwYXJhdGVfYnlfY2hhbm5lbHMsCiAgICAgICAgICAgICAgICBzcGVha2VyX3ByZWZpeD1zcGVha2VyX3ByZWZpeCwKICAgICAgICAgICAgICAgIGRpYXJpemVfa3dhcmdzPWRpYXJpemVfa3dhcmdzLAogICAgICAgICAgICApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBleGNlcHRpb246CiAgICAgICAgICAgICMgTm90ZSB0aGUgZXhjZXB0aW9uIGFzIGVycm9yIGluIHRoZSBkaWN0aW9uYXJ5OgogICAgICAgICAgICBpZiB2ZXJib3NlOgogICAgICAgICAgICAgICAgX0xPR0dFUi53YXJuaW5nKGYiRXJyb3IgaW4gZmlsZTogJ3thdWRpb19maWxlLm5hbWV9JyIpCiAgICAgICAgICAgIGVycm9yc1tzdHIoYXVkaW9fZmlsZS5uYW1lKV0gPSBzdHIoZXhjZXB0aW9uKQogICAgICAgICAgICBjb250aW51ZQoKICAgICMgUHJpbnQgdGhlIGhlYWQgb2YgdGhlIHByb2R1Y2VkIGRhdGFmcmFtZSBhbmQgcmV0dXJuOgogICAgaWYgdmVyYm9zZToKICAgICAgICBfTE9HR0VSLmluZm8oZiJEb25lICh7bGVuKGRpYXJpemF0aW9ucyl9L3tsZW4oYXVkaW9fZmlsZXMpfSlcbiIpCiAgICByZXR1cm4gZGlhcml6YXRpb25zLCBlcnJvcnMKCgpkZWYgX2dldF9hdWRpb19maWxlcygKICAgIGRhdGFfcGF0aDogcGF0aGxpYi5QYXRoLAopIC0+IExpc3RbcGF0aGxpYi5QYXRoXToKICAgICMgQ2hlY2sgaWYgdGhlIHBhdGggaXMgb2YgYSBkaXJlY3Rvcnkgb3IgYSBmaWxlOgogICAgaWYgZGF0YV9wYXRoLmlzX2RpcigpOgogICAgICAgICMgR2V0IGFsbCBmaWxlcyBpbnNpZGUgdGhlIGRpcmVjdG9yeToKICAgICAgICBhdWRpb19maWxlcyA9IGxpc3QoZGF0YV9wYXRoLmdsb2IoIiouKiIpKQogICAgZWxpZiBkYXRhX3BhdGguaXNfZmlsZSgpOgogICAgICAgIGF1ZGlvX2ZpbGVzID0gW2RhdGFfcGF0aF0KICAgIGVsc2U6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgZiJVbnJlY29nbml6ZWQgZGF0YSBwYXRoLiBUaGUgcGFyYW1ldGVyIGBkYXRhX3BhdGhgIG11c3QgYmUgZWl0aGVyIGEgZGlyZWN0b3J5IHBhdGggb3IgYSBmaWxlIHBhdGguICIKICAgICAgICAgICAgZiJHaXZlbjoge3N0cihkYXRhX3BhdGgpfSAiCiAgICAgICAgKQoKICAgIHJldHVybiBhdWRpb19maWxlcwoKCmRlZiBfZ2V0X2FjY2Vzc190b2tlbihwYXJhbWV0ZXI6IHN0cikgLT4gc3RyOgogICAgIyBJZiBnaXZlbiBhcyBhIHBhcmFtZXRlciwgcmV0dXJuIGl0OgogICAgaWYgcGFyYW1ldGVyOgogICAgICAgIHJldHVybiBwYXJhbWV0ZXIKCiAgICAjIE90aGVyd2lzZSwgbG9vayBhdCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGU6CiAgICBlbnZpcm9ubWVudF92YXJpYWJsZSA9IG9zLmVudmlyb24uZ2V0KCJIVUdHSU5HX0ZBQ0VfSFVCX1RPS0VOIikKICAgIGlmIGVudmlyb25tZW50X3ZhcmlhYmxlOgogICAgICAgIHJldHVybiBlbnZpcm9ubWVudF92YXJpYWJsZQoKICAgICMgTGFzdGx5LCB0cnkgbG9vayBpbiB0aGUgc2V0IHNlY3JldHMgaW4gTUxSdW46CiAgICBzZWNyZXQgPSBOb25lCiAgICB0cnk6CiAgICAgICAgaW1wb3J0IG1scnVuCgogICAgICAgIGNvbnRleHQgPSBtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eChuYW1lPSJtbHJ1biIpCiAgICAgICAgc2VjcmV0ID0gY29udGV4dC5nZXRfc2VjcmV0KGtleT0iSFVHR0lOR19GQUNFX0hVQl9UT0tFTiIpCiAgICBleGNlcHQgTW9kdWxlTm90Rm91bmRFcnJvcjoKICAgICAgICBwYXNzCgogICAgcmV0dXJuIHNlY3JldAoKCmRlZiBfZGlhcml6ZSgKICAgIGF1ZGlvOiB0b3JjaC5UZW5zb3IsCiAgICBzYW1wbGVfcmF0ZTogaW50LAogICAgcGlwZWxpbmU6IHB5YW5ub3RlLmF1ZGlvLlBpcGVsaW5lLAogICAgc3BlYWtlcnNfbGFiZWxzOiBMaXN0W3N0cl0sCiAgICBzZXBhcmF0ZV9ieV9jaGFubmVsczogYm9vbCwKICAgIHNwZWFrZXJfcHJlZml4OiBzdHIsCiAgICBkaWFyaXplX2t3YXJnczogZGljdCwKKSAtPiBMaXN0W1R1cGxlW2Zsb2F0LCBmbG9hdCwgc3RyXV06CiAgICAjIElmIHRoZXJlIGlzIG5vIG5lZWQgZm9yIHNlcGFyYXRpb24gYnkgY2hhbm5lbHMsIHdlIGRpYXJpemUgYW5kIHJldHVybjoKICAgIGlmIG5vdCBzZXBhcmF0ZV9ieV9jaGFubmVsczoKICAgICAgICAjIERpYXJpemU6CiAgICAgICAgZGlhcml6YXRpb246IHB5YW5ub3RlLmNvcmUuQW5ub3RhdGlvbiA9IHBpcGVsaW5lKAogICAgICAgICAgICBmaWxlPXsid2F2ZWZvcm0iOiBhdWRpbywgInNhbXBsZV9yYXRlIjogc2FtcGxlX3JhdGV9LCAqKmRpYXJpemVfa3dhcmdzCiAgICAgICAgKQogICAgICAgICMgVmVyaWZ5IHNwZWFrZXJzIGxhYmVscyAoc2hvdWxkIG5vdCBmYWlsIGhlcmUgYXMgd2Ugc2V0IGBudW1fc3BlYWtlcnM9bGVuKHNwZWFrZXJzX2xhYmVscylgIHdoZW4gaW5mZXJyaW5nCiAgICAgICAgIyB0aHJvdWdoIHRoZSBwaXBlbGluZSk6CiAgICAgICAgaWYgc3BlYWtlcnNfbGFiZWxzOgogICAgICAgICAgICBnaXZlbl9zcGVha2VycyA9IGxlbihzcGVha2Vyc19sYWJlbHMpCiAgICAgICAgICAgIGZvdW5kX3NwZWFrZXJzID0gbGVuKHNldChkaWFyaXphdGlvbi5sYWJlbHMoKSkpCiAgICAgICAgICAgIGlmIGdpdmVuX3NwZWFrZXJzIDwgZm91bmRfc3BlYWtlcnM6CiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKAogICAgICAgICAgICAgICAgICAgIGYiTm90IGVub3VnaCBgc3BlYWtlcnNfbGFiZWxzYCB3ZXJlIGdpdmVuLiBHb3Qge2dpdmVuX3NwZWFrZXJzfSBsYWJlbHMgYnV0IHRoZSBkaWFyaXphdGlvbiAiCiAgICAgICAgICAgICAgICAgICAgZiJyZWNvZ25pemVkIHtmb3VuZF9zcGVha2Vyc30gc3BlYWtlcnMuIgogICAgICAgICAgICAgICAgKQogICAgICAgICMgUmV0dXJuIGFzIGEgZGlhcml6YXRpb24gbGlzdCAtIGEgc29ydGVkIGxpc3Qgb2YgdHVwbGVzIG9mIHN0YXJ0IHRpbWUsIGVuZCB0aW1lIGFuZCBhIGxhYmVsICh0aGUgZGVmYXVsdCBsYWJlbAogICAgICAgICMgcmV0dXJuZWQgaXMgIlNQRUFLRVJfaSIgc28gd2UgdGFrZSBvbmx5IHRoZSBpbmRleCBvdXQgb2YgaXQpOgogICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICgKICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhcnQsCiAgICAgICAgICAgICAgICBzZWdtZW50LmVuZCwKICAgICAgICAgICAgICAgIHNwZWFrZXJzX2xhYmVsc1tpbnQobGFiZWwuc3BsaXQoIl8iKVsxXSldCiAgICAgICAgICAgICAgICBpZiBzcGVha2Vyc19sYWJlbHMKICAgICAgICAgICAgICAgIGVsc2UgZiJ7c3BlYWtlcl9wcmVmaXh9e2ludChsYWJlbC5zcGxpdCgnXycpWzFdKX0iLAogICAgICAgICAgICApCiAgICAgICAgICAgIGZvciBzZWdtZW50LCB0cmFjaywgbGFiZWwgaW4gZGlhcml6YXRpb24uaXRlcnRyYWNrcyh5aWVsZF9sYWJlbD1UcnVlKQogICAgICAgIF0KCiAgICAjIFNlcGFyYXRlIHRvIGNoYW5uZWxzIGFuZCBkaWFyaXplICh3ZSBleHBlY3Qgb25seSBvbmUgc3BlYWtlciBwZXIgY2hhbm5lbCk6CiAgICBjaGFubmVsX2RpYXJpemF0aW9ucyA9IFsKICAgICAgICBfZGlhcml6ZSgKICAgICAgICAgICAgYXVkaW89YXVkaW9bY2hhbm5lbF0udW5zcXVlZXplKAogICAgICAgICAgICAgICAgMAogICAgICAgICAgICApLCAgIyBUYWtlIGNoYW5uZWwgYW5kIGFkZCBhIGNoYW5uZWwgZGltZW5zaW9uIHRvIGl0LgogICAgICAgICAgICBzYW1wbGVfcmF0ZT1zYW1wbGVfcmF0ZSwKICAgICAgICAgICAgcGlwZWxpbmU9cGlwZWxpbmUsCiAgICAgICAgICAgIHNwZWFrZXJzX2xhYmVscz1bCiAgICAgICAgICAgICAgICBzcGVha2Vyc19sYWJlbHNbY2hhbm5lbF0KICAgICAgICAgICAgXSwgICMgVGFrZSB0aGUgY2hhbm5lbCdzIGxhYmVsIG9ubHkuCiAgICAgICAgICAgIHNlcGFyYXRlX2J5X2NoYW5uZWxzPUZhbHNlLAogICAgICAgICAgICBzcGVha2VyX3ByZWZpeD1zcGVha2VyX3ByZWZpeCwKICAgICAgICAgICAgZGlhcml6ZV9rd2FyZ3M9eyJudW1fc3BlYWtlcnMiOiAxfSwgICMgU2V0IHRvIG9uZSBzcGVha2VyLgogICAgICAgICkKICAgICAgICBmb3IgY2hhbm5lbCBpbiByYW5nZShhdWRpby5zaGFwZVswXSkKICAgIF0KCiAgICAjIE1lcmdlIHRoZSBjaGFubmVsIGRpYXJpemF0aW9ucyBpbnRvIGEgc2luZ2xlIHNvcnRlZCBsaXN0OgogICAgcmV0dXJuIGxpc3QoaGVhcHEubWVyZ2UoKmNoYW5uZWxfZGlhcml6YXRpb25zKSkK
    commands: []
    code_origin: ''
    origin_filename: ''
    requirements: []
  entry_points:
    open_mpi_handler:
      name: open_mpi_handler
      doc: ''
      parameters:
      - name: worker_inputs
        type: List[str]
        default: ''
      - name: root_worker_inputs
        type: Dict[str, Any]
        default: null
      outputs:
      - default: ''
      lineno: 59
    decorator:
      name: decorator
      doc: ''
      parameters:
      - name: handler
        default: ''
      outputs:
      - default: ''
      lineno: 71
    wrapper:
      name: wrapper
      doc: ''
      parameters: []
      outputs:
      - default: ''
      lineno: 76
    diarize:
      name: diarize
      doc: "Perform speech diarization on given audio files using pyannote-audio (https://github.com/pyannote/pyannote-audio).\n\
        The end result is a dictionary with the file names as keys and their diarization\
        \ as value. A diarization is a list\nof tuples: (start, end, speaker_label).\n\
        \nTo use the `pyannote.audio` models you must pass a Huggingface token and\
        \ get access to the required models. The\ntoken can be passed in one of the\
        \ following options:\n\n* Use the parameter `access_token`.\n* Set an environment\
        \ variable named \"HUGGING_FACE_HUB_TOKEN\".\n* If using MLRun, you can pass\
        \ it as a secret named \"HUGGING_FACE_HUB_TOKEN\".\n\nTo get access to the\
        \ models on Huggingface, visit their page. For example, to use the default\
        \ diarization model set\nin this function (\"pyannote/speaker-diarization-3.0\"\
        ), you need access for these two models:\n\n* https://huggingface.co/pyannote/segmentation-3.0\n\
        * https://huggingface.co/pyannote/speaker-diarization-3.0\n\nNote: To control\
        \ the recognized speakers in the diarization output you can choose one of\
        \ the following methods:\n\n* For a known speakers amount, you may set speaker\
        \ labels via the `speakers_labels` parameter that will be used in\n  the order\
        \ of speaking in the audio (first person speaking be the first label in the\
        \ list). In addition, you can do\n  diarization per channel (setting the parameter\
        \ `separate_by_channels` to True). Each label will be assigned to a\n  specific\
        \ channel by order (first label to channel 0, second label to channel 1 and\
        \ so on). Notice, this will\n  increase runtime.\n* For unknown speakers amount,\
        \ you can set the `speaker_prefix` parameter to add a prefix for each speaker\
        \ number.\n  You can also help the diarization by setting the speakers range\
        \ via the `speakers_amount_range` parameter."
      parameters:
      - name: data_path
        type: Union[str, List[str]]
        doc: A directory of the audio files, a single file or a list of files to transcribe.
        default: ''
      - name: model_name
        type: str
        doc: 'One of the official diarization model names (referred as diarization
          pipelines) of `pyannote.audio` Huggingface page. Default: "pyannote/speaker-diarization-3.0".'
        default: pyannote/speaker-diarization-3.0
      - name: access_token
        type: str
        doc: An access token to pass for using the `pyannote.audio` models. If not
          provided, it will be looking for the environment variable "HUGGING_FACE_HUB_TOKEN".
          If MLRun is available, it will look for a secret "HUGGING_FACE_HUB_TOKEN".
        default: null
      - name: device
        type: str
        doc: Device to load the model. Can be one of {"cuda", "cpu"}. Default will
          prefer "cuda" if available.
        default: null
      - name: speakers_labels
        type: List[str]
        doc: 'Labels to use for the recognized speakers. Default: numeric labels (0,
          1, ...).'
        default: null
      - name: speaker_prefix
        type: str
        doc: 'A prefix to add for the speakers labels. This parameter is ignored if
          `speakers_labels` is not None. Default: "speaker".'
        default: speaker_
      - name: separate_by_channels
        type: bool
        doc: If each speaker is speaking in a separate channel, you can diarize each
          channel and combine the result into a single diarization. Each label set
          in the `speakers_labels` parameter will be assigned to a specific channel
          by order.
        default: false
      - name: minimum_speakers
        type: int
        doc: Set the minimum expected amount of speakers to be in the audio files.
          This parameter is ignored if `speakers_labels` is not None.
        default: null
      - name: maximum_speakers
        type: int
        doc: Set the maximum expected amount of speakers to be in the audio files.
          This parameter is ignored if `speakers_labels` is not None.
        default: null
      - name: verbose
        type: bool
        doc: 'Whether to present logs of a progress bar and errors. Default: True.'
        default: false
      outputs:
      - default: ''
        doc: 'A tuple of:'
      lineno: 137
  description: speech diarization of audio files
  default_handler: diarize
  disable_auto_mount: false
  clone_target_dir: ''
  env: []
  priority_class_name: ''
  preemption_mode: prevent
  affinity: null
  tolerations: null
  security_context: {}
verbose: false
