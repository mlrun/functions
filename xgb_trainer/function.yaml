kind: job
metadata:
  name: xgb-trainer
  tag: latest
  hash: 6893cf05b62f91b565df146779aec0c8bb71f116
  project: ''
  labels:
    author: yjb
  categories:
  - models
  - classifier
spec:
  command: ''
  args: []
  image: mlrun/ml-models:0.4.6
  env: []
  default_handler: train_model
  entry_points:
    gen_xgb_model:
      name: gen_xgb_model
      doc: 'generate an xgboost model


        Multiple model types that can be estimated using

        the XGBoost Scikit-Learn API'
      parameters:
      - name: model_type
        type: str
        doc: one of "classifier", "regressor", "ranker", "rf_classifier", or "rf_regressor"
      - name: xgb_params
        type: dict
        doc: parameters passed through the  function execution context
      outputs: []
      lineno: 6
    get_sample:
      name: get_sample
      doc: "generate data sample to be split (candidate for mlrun)\n \nReturns features\
        \ matrix and header (x), and labels (y)"
      parameters:
      - name: src
        type: str
        doc: full path and filename of data artifact
      - name: sample
        type: int
        doc: sample size from data source, use negative  integers to sample randomly,
          positive to sample consecutively from the first row
      - name: label
        type: str
        doc: label column title
      - name: reader
        doc: pandas type reader (read_csv, read_parquet, ...) returning a pandas dataframe,
          and with a `dropna` attribute
      outputs: []
      lineno: 44
    get_splits:
      name: get_splits
      doc: 'generate train and test sets (candidate for mlrun)


        cross validation:

        1. cut out a test set

        2a. use the training set in a cross validation scheme, or

        2b. make another split to generate a validation set


        2 parts (n_ways=2): train and test set only

        3 parts (n_ways=3): train, validation and test set

        4 parts (n_ways=4): n_ways=3 + a held-out probability calibration set'
      parameters:
      - name: raw
        doc: dataframe or numpy array of raw features
      - name: labels
        doc: dataframe or numpy array of raw labels
      - name: n_ways
        type: int
        doc: (3) split data into 2, 3, or 4 parts
        default: 3
      - name: test_size
        type: float
        doc: proportion of raw data to set asid as test data
        default: 0.15
      - name: valid_size
        type: float
        doc: proportion of remaining data to be set as validation
        default: 0.3
      - name: label_names
        type: list
        doc: label names
        default:
        - labels
      - name: random_state
        type: int
        doc: (1) random number seed
        default: 1
      outputs: []
      lineno: 77
    save_test_set:
      name: save_test_set
      doc: log a held out test set
      parameters:
      - name: context
        doc: the function execution context
      - name: xtest
        doc: test features, as np.ndarray output from `get_splits`
      - name: ytest
        doc: test labels, as np.ndarray output from `get_splits`
      - name: header
        type: list
        doc: ([])features header if required
      - name: label
        type: str
        doc: ("labels") name of label column
        default: labels
      - name: file_ext
        type: str
        doc: format of test set file
        default: parquet
      - name: index
        type: bool
        doc: preserve index column
      - name: debug
        type: bool
        doc: (False)
      outputs: []
      lineno: 135
    dump_xgb_model:
      name: dump_xgb_model
      doc: 'serialize/log model


        XGBoost model can be save in 3 different ways:

        1. pickle the internal _booster object, inside the model

        2. using model.save_model("fn.bin") using a legacy binary xgb format

        2. using model.save_model("fn.json") using a portable json format'
      parameters:
      - name: context
        doc: the function"s execution context
      - name: model
        doc: the fitted xgboost model
      - name: dump_type
        type: str
        doc: '"pickle" legacy", or "json", '
      - name: dest_folder
        type: str
        doc: 'path for serialized model '
      - name: dest_name
        type: str
        doc: name for serialized model file
      outputs: []
      lineno: 169
    plot_confusion_matrix:
      name: plot_confusion_matrix
      doc: prints and plots the confusion matrix.
      parameters:
      - name: labels
      - name: predictions
      - name: classes
      - name: normalize
        default: all
      - name: title
        default: Confusion matrix
      - name: cmap
      outputs: []
      lineno: 204
    plot_roc:
      name: plot_roc
      doc: "plot roc curves\n\nTODO:  add averaging method (as string) that was used\
        \ to create probs, \ndisplay in legend"
      parameters:
      - name: context
        doc: the function context
      - name: y_labels
        doc: 'ground truth labels, hot encoded for multiclass  '
      - name: y_probs
        doc: model prediction probabilities
      - name: fpr_label
        type: str
        doc: ("false positive rate") x-axis labels
        default: false positive rate
      - name: tpr_label
        type: str
        doc: ("true positive rate") y-axis labels
        default: true positive rate
      - name: title
        type: str
        doc: ("roc curve") title of plot
        default: roc curve
      - name: legend_loc
        type: str
        doc: ("best") location of plot legend
        default: best
      outputs: []
      lineno: 242
    gen_proba:
      name: gen_proba
      doc: generate predictions and validation stats
      parameters:
      - name: context
        doc: the function execution context
      - name: feats
        doc: 'validation features array '
      - name: labels
        doc: validation ground-truth labels
      - name: model
        doc: estimated model
      - name: score_method
      - name: plots_dest
        doc: destination folder for plot artifacts
      - name: ntree_limit
        doc: (None) limit no. trees used in prediction
      - name: validate_features
        doc: (True) ensure consistent feature names  between model and input data
        default: true
      - name: base_margin
        doc: (None) undefined
      outputs: []
      lineno: 296
    proba_calibration:
      name: proba_calibration
      doc: 'calibrate output probabilities


        adapted from https://scikit-learn.org/stable/auto_examples/calibration/plot_calibration_curve.html#sphx-glr-auto-examples-calibration-plot-calibration-curve-py'
      parameters:
      - name: model
      - name: xcal
      - name: ycal
      outputs: []
      lineno: 348
    plot_calibration_curve:
      name: plot_calibration_curve
      doc: Plot calibration curve for est w/o and with calibration.
      parameters:
      - name: name
      - name: fig_index
      outputs: []
      lineno: 359
    train_model:
      name: train_model
      doc: train an xgboost model.
      parameters:
      - name: context
        doc: the function context
      - name: model_type
        type: str
        doc: the model type to train, 'classifier', 'regressor'...
      - name: dataset
        doc: ("data") name of raw data file
      - name: label_column
        type: str
        doc: ground-truth (y) labels
        default: labels
      - name: sample
        type: int
        doc: Selects the first n rows, or select a sample starting from the first.
          If negative <-1, select a random sample
        default: <_ast.USub object at 0x7f83e7e66cc0>
      - name: test_size
        type: float
        doc: (0.05) test set size
        default: 0.05
      - name: valid_size
        type: float
        doc: (0.75) Once the test set has been removed the training set gets this
          proportion.
        default: 0.75
      - name: random_state
        type: int
        doc: (1) sklearn rng seed
        default: 1
      - name: model_filename
        type: str
        doc: model file filename, points to a directory
        default: model
      - name: models_dest
        type: str
        doc: models subfolder on artifact path
      - name: plots_dest
        type: str
        doc: plot subfolder on artifact path
      - name: score_method
        type: str
        doc: for multiclass classification
        default: micro
      - name: file_ext
        type: str
        doc: format for test_set_key hold out data
        default: parquet
      - name: model_pkg_file
        type: str
        doc: json model config file
      outputs: []
      lineno: 414
  description: train any classifier using scikit-learn's API
  build:
    functionSourceCode: IyBHZW5lcmF0ZWQgYnkgbnVjbGlvLmV4cG9ydC5OdWNsaW9FeHBvcnRlciBvbiAyMDIwLTA0LTI4IDAwOjA3CgppbXBvcnQgd2FybmluZ3MKd2FybmluZ3Muc2ltcGxlZmlsdGVyKGFjdGlvbj0iaWdub3JlIiwgY2F0ZWdvcnk9RnV0dXJlV2FybmluZykKCmRlZiBnZW5feGdiX21vZGVsKG1vZGVsX3R5cGU6IHN0ciwgeGdiX3BhcmFtczogZGljdCk6CiAgICAiIiJnZW5lcmF0ZSBhbiB4Z2Jvb3N0IG1vZGVsCiAgICAKICAgIE11bHRpcGxlIG1vZGVsIHR5cGVzIHRoYXQgY2FuIGJlIGVzdGltYXRlZCB1c2luZwogICAgdGhlIFhHQm9vc3QgU2Npa2l0LUxlYXJuIEFQSQogICAgCiAgICA6cGFyYW0gbW9kZWxfdHlwZTogb25lIG9mICJjbGFzc2lmaWVyIiwgInJlZ3Jlc3NvciIsCiAgICAgICAgICAgICAgICAgICAgICAgInJhbmtlciIsICJyZl9jbGFzc2lmaWVyIiwgb3IKICAgICAgICAgICAgICAgICAgICAgICJyZl9yZWdyZXNzb3IiCiAgICA6cGFyYW0geGdiX3BhcmFtczogcGFyYW1ldGVycyBwYXNzZWQgdGhyb3VnaCB0aGUgCiAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgICIiIgogICAgZnJvbSBqc29uIGltcG9ydCBsb2FkCiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdldF9jbGFzc19maXQsIGNyZWF0ZV9jbGFzcwoKICAgIG10eXBlcyA9IHsKICAgICAgICAiY2xhc3NpZmllciIgICA6ICJ4Z2Jvb3N0LlhHQkNsYXNzaWZpZXIiLAogICAgICAgICJyZWdyZXNzb3IiICAgIDogInhnYm9vc3QuWEdCUmVncmVzc29yIiwKICAgICAgICAicmFua2VyIiAgICAgICA6ICJ4Z2Jvb3N0LlhHQkNsYXNzaWZpZXIiLAogICAgICAgICJyZl9jbGFzc2lmaWVyIjogInhnYm9vc3QuWEdCUkZDbGFzc2lmaWVyIiwKICAgICAgICAicmZfcmVncmVzc29yIiA6ICJ4Z2Jvb3N0LlhHQlJGUmVncmVzc29yIgogICAgfQogICAgaWYgbW9kZWxfdHlwZSBub3QgaW4gbXR5cGVzLmtleXMoKToKICAgICAgICByYWlzZSBFeGNlcHRpb24oInVucmVjb2duaXplZCBtb2RlbCB0eXBlcywgc2VlIGhlbHAgZG9jdW1lbnRhdGlvbiIpCiAgICAKICAgIG1vZGVsX2NvbmZpZyA9IGdldF9jbGFzc19maXQobXR5cGVzW21vZGVsX3R5cGVdKQoKICAgIGZvciBrLCB2IGluIHhnYl9wYXJhbXM6CiAgICAgICAgaWYgay5zdGFydHN3aXRoKCJDTEFTU18iKToKICAgICAgICAgICAgbW9kZWxfY29uZmlnWyJDTEFTUyJdW2tbNjpdXSA9IHYKICAgICAgICBpZiBrLnN0YXJ0c3dpdGgoIkZJVF8iKToKICAgICAgICAgICAgbW9kZWxfY29uZmlnWyJGSVQiXVtrWzQ6XV0gPSB2CgogICAgQ2xhc3NpZmllckNsYXNzID0gY3JlYXRlX2NsYXNzKG1vZGVsX2NvbmZpZ1siTUVUQSJdWyJjbGFzcyJdKQogICAgbW9kZWwgPSBDbGFzc2lmaWVyQ2xhc3MoKiptb2RlbF9jb25maWdbIkNMQVNTIl0pCgogICAgcmV0dXJuIG1vZGVsLCBtb2RlbF9jb25maWcKCmRlZiBnZXRfc2FtcGxlKHNyYzpzdHIsIHNhbXBsZTogaW50LCBsYWJlbDogc3RyLCByZWFkZXI9Tm9uZSk6CiAgICAiIiJnZW5lcmF0ZSBkYXRhIHNhbXBsZSB0byBiZSBzcGxpdCAoY2FuZGlkYXRlIGZvciBtbHJ1bikKICAgICAKICAgIFJldHVybnMgZmVhdHVyZXMgbWF0cml4IGFuZCBoZWFkZXIgKHgpLCBhbmQgbGFiZWxzICh5KQogICAgOnBhcmFtIHNyYzogICAgZnVsbCBwYXRoIGFuZCBmaWxlbmFtZSBvZiBkYXRhIGFydGlmYWN0CiAgICA6cGFyYW0gc2FtcGxlOiBzYW1wbGUgc2l6ZSBmcm9tIGRhdGEgc291cmNlLCB1c2UgbmVnYXRpdmUgCiAgICAgICAgICAgICAgICAgICBpbnRlZ2VycyB0byBzYW1wbGUgcmFuZG9tbHksIHBvc2l0aXZlIHRvCiAgICAgICAgICAgICAgICAgICBzYW1wbGUgY29uc2VjdXRpdmVseSBmcm9tIHRoZSBmaXJzdCByb3cKICAgIDpwYXJhbSBsYWJlbDogIGxhYmVsIGNvbHVtbiB0aXRsZQogICAgOnBhcmFtIHJlYWRlcjogcGFuZGFzIHR5cGUgcmVhZGVyIChyZWFkX2NzdiwgcmVhZF9wYXJxdWV0LCAuLi4pIHJldHVybmluZwogICAgICAgICAgICAgICAgICAgYSBwYW5kYXMgZGF0YWZyYW1lLCBhbmQgd2l0aCBhIGBkcm9wbmFgIGF0dHJpYnV0ZQogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICAKICAgIGlmIG5vdCByZWFkZXI6CiAgICAgICAgaWYgc3JjLmVuZHN3aXRoKCJjc3YiKToKICAgICAgICAgICAgcmVhZGVyID0gcGQucmVhZF9jc3YKICAgICAgICBlbGlmIHNyYy5lbmRzd2l0aCgicGFycXVldCIpIG9yIHNyYy5lbmRzd2l0aCgicHEiKToKICAgICAgICAgICAgcmVhZGVyID0gcGQucmVhZF9wYXJxdWV0CiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmFpc2UgRXhjZXB0aW9uKGYiZmlsZSB0eXBlIHVuaGFuZGxlZCB7c3JjfSIpCgogICAgaWYgKHNhbXBsZSA9PSAtMSkgb3IgKHNhbXBsZSA+PSAxKToKICAgICAgICByYXcgPSByZWFkZXIoc3JjKS5kcm9wbmEoKQogICAgICAgIGxhYmVscyA9IHJhdy5wb3AobGFiZWwpCiAgICAgICAgcmF3ID0gcmF3Lmlsb2NbOnNhbXBsZSwgOl0KICAgICAgICBsYWJlbHMgPSBsYWJlbHMuaWxvY1s6c2FtcGxlXQogICAgZWxzZToKICAgICAgICByYXcgPSByZWFkZXIoc3JjKS5kcm9wbmEoKS5zYW1wbGUoc2FtcGxlICogLTEpCiAgICAgICAgbGFiZWxzID0gcmF3LnBvcChsYWJlbCkKCiAgICByZXR1cm4gcmF3LCBsYWJlbHMsIHJhdy5jb2x1bW5zLnZhbHVlcwoKZGVmIGdldF9zcGxpdHMoCiAgICByYXcsIAogICAgbGFiZWxzLCAKICAgIG5fd2F5czogaW50ID0gMywKICAgIHRlc3Rfc2l6ZTogZmxvYXQgPSAwLjE1LAogICAgdmFsaWRfc2l6ZTogZmxvYXQgPSAwLjMwLAogICAgbGFiZWxfbmFtZXM6IGxpc3QgPSBbImxhYmVscyJdLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSAxCik6CiAgICAiIiJnZW5lcmF0ZSB0cmFpbiBhbmQgdGVzdCBzZXRzIChjYW5kaWRhdGUgZm9yIG1scnVuKQoKICAgIGNyb3NzIHZhbGlkYXRpb246CiAgICAxLiBjdXQgb3V0IGEgdGVzdCBzZXQKICAgIDJhLiB1c2UgdGhlIHRyYWluaW5nIHNldCBpbiBhIGNyb3NzIHZhbGlkYXRpb24gc2NoZW1lLCBvcgogICAgMmIuIG1ha2UgYW5vdGhlciBzcGxpdCB0byBnZW5lcmF0ZSBhIHZhbGlkYXRpb24gc2V0CiAgICAKICAgIDIgcGFydHMgKG5fd2F5cz0yKTogdHJhaW4gYW5kIHRlc3Qgc2V0IG9ubHkKICAgIDMgcGFydHMgKG5fd2F5cz0zKTogdHJhaW4sIHZhbGlkYXRpb24gYW5kIHRlc3Qgc2V0CiAgICA0IHBhcnRzIChuX3dheXM9NCk6IG5fd2F5cz0zICsgYSBoZWxkLW91dCBwcm9iYWJpbGl0eSBjYWxpYnJhdGlvbiBzZXQKICAgIAogICAgOnBhcmFtIHJhdzogICAgICAgICAgICBkYXRhZnJhbWUgb3IgbnVtcHkgYXJyYXkgb2YgcmF3IGZlYXR1cmVzCiAgICA6cGFyYW0gbGFiZWxzOiAgICAgICAgIGRhdGFmcmFtZSBvciBudW1weSBhcnJheSBvZiByYXcgbGFiZWxzCiAgICA6cGFyYW0gbl93YXlzOiAgICAgICAgICgzKSBzcGxpdCBkYXRhIGludG8gMiwgMywgb3IgNCBwYXJ0cwogICAgOnBhcmFtIHRlc3Rfc2l6ZTogICAgICBwcm9wb3J0aW9uIG9mIHJhdyBkYXRhIHRvIHNldCBhc2lkIGFzIHRlc3QgZGF0YQogICAgOnBhcmFtIHZhbGlkX3NpemU6ICAgICBwcm9wb3J0aW9uIG9mIHJlbWFpbmluZyBkYXRhIHRvIGJlIHNldCBhcyB2YWxpZGF0aW9uCiAgICA6cGFyYW0gbGFiZWxfbmFtZXM6ICAgICAgICAgbGFiZWwgbmFtZXMKICAgIDpwYXJhbSByYW5kb21fc3RhdGU6ICAgKDEpIHJhbmRvbSBudW1iZXIgc2VlZAogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICBpbXBvcnQgbnVtcHkgYXMgbnAKICAgIGZyb20gc2tsZWFybi5tb2RlbF9zZWxlY3Rpb24gaW1wb3J0IHRyYWluX3Rlc3Rfc3BsaXQKICAgIAogICAgaWYgaXNpbnN0YW5jZShyYXcsIG5wLm5kYXJyYXkpOgogICAgICAgIGlmIGxhYmVscy5uZGltPT0xOgogICAgICAgICAgICBsYWJlbHM9bGFiZWxzLnJlc2hhcGUoLTEsMSkKICAgICAgICB4eSA9IG5wLmNvbmNhdGVuYXRlKFtyYXcsIGxhYmVsc10sIGF4aXM9MSkKICAgIGVsc2U6CiAgICAgICAgaWYgaXNpbnN0YW5jZShsYWJlbHMsIHBkLlNlcmllcyk6CiAgICAgICAgICAgIGxhYmVscyA9IHBkLkRhdGFGcmFtZShkYXRhPWxhYmVscywgY29sdW1ucz1sYWJlbF9uYW1lcykKICAgICAgICB4eSA9IHBkLmNvbmNhdChbcmF3LCBsYWJlbHNdLCBheGlzPTEpCiAgICAgICAgCiAgICB4LCB4dGUsIHksIHl0ZSA9IHRyYWluX3Rlc3Rfc3BsaXQoeHksIGxhYmVscywgdGVzdF9zaXplPXRlc3Rfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgaWYgbl93YXlzPT0yOgogICAgICAgIHJldHVybiAoeCwgeSksICh4dGUsIHl0ZSksIE5vbmUsIE5vbmUKICAgIGVsaWYgbl93YXlzPT0zOgogICAgICAgIHh0ciwgeHZhLCB5dHIsIHl2YSA9IHRyYWluX3Rlc3Rfc3BsaXQoeCwgeSx0cmFpbl9zaXplPXZhbGlkX3NpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgICAgIHJldHVybiAoeHRyLCB5dHIpLCAoeHZhLCB5dmEpLCAoeHRlLCB5dGUpLCBOb25lCiAgICBlbGlmIG5fd2F5cz09NDoKICAgICAgICB4dCwgeHZhLCB5dCwgeXZhID0gdHJhaW5fdGVzdF9zcGxpdCh4LCB5LHRyYWluX3NpemU9dmFsaWRfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICAgICAgeHRyLCB4Y2FsLCB5dHIsIHljYWwgPSB0cmFpbl90ZXN0X3NwbGl0KHh0LCB5dCwgdHJhaW5fc2l6ZT0wLjgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGU9cmFuZG9tX3N0YXRlKQogICAgICAgIHJldHVybiAoeHRyLCB5dHIpLCAoeHZhLCB5dmEpLCAoeHRlLCB5dGUpLCAoeGNhbCwgeWNhbCkKICAgIGVsc2U6CiAgICAgICAgcmFpc2UgRXhjZXB0aW9uKCJuX3dheXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzIsNF0iKQoKZGVmIHNhdmVfdGVzdF9zZXQoCiAgICBjb250ZXh0LCAKICAgIHh0ZXN0LCAKICAgIHl0ZXN0LCAKICAgIGhlYWRlcjogbGlzdCwgCiAgICBsYWJlbDogc3RyID0gImxhYmVscyIsIAogICAgZmlsZV9leHQ6IHN0ciA9ICJwYXJxdWV0IiwgCiAgICBpbmRleDogYm9vbCA9IEZhbHNlLAogICAgZGVidWc6IGJvb2wgPSBGYWxzZQopOgogICAgIiIibG9nIGEgaGVsZCBvdXQgdGVzdCBzZXQKCiAgICA6cGFyYW0gY29udGV4dDogICAgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0geHRlc3Q6ICAgICAgdGVzdCBmZWF0dXJlcywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSB5dGVzdDogICAgICB0ZXN0IGxhYmVscywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSBoZWFkZXI6ICAgICAoW10pZmVhdHVyZXMgaGVhZGVyIGlmIHJlcXVpcmVkCiAgICA6cGFyYW0gbGFiZWw6ICAgICAgKCJsYWJlbHMiKSBuYW1lIG9mIGxhYmVsIGNvbHVtbgogICAgOnBhcmFtIGZpbGVfZXh0OiAgIGZvcm1hdCBvZiB0ZXN0IHNldCBmaWxlCiAgICA6cGFyYW0gaW5kZXg6ICAgICAgcHJlc2VydmUgaW5kZXggY29sdW1uCiAgICA6cGFyYW0gZGVidWc6ICAgICAgKEZhbHNlKQogICAgIiIiCiAgICBpbXBvcnQgcGFuZGFzIGFzIHBkCiAgICBmcm9tIG1scnVuIGltcG9ydCBtbGNvbmYKICAgIAogICAgdGVzdF9zZXQgPSBwZC5jb25jYXQoCiAgICAgICAgW3BkLkRhdGFGcmFtZShkYXRhPXh0ZXN0LCBjb2x1bW5zPWhlYWRlciksCiAgICAgICAgIHBkLkRhdGFGcmFtZShkYXRhPXl0ZXN0LnZhbHVlcywgY29sdW1ucz1bbGFiZWxdKV0sCiAgICAgICAgYXhpcz0xLCkKICAgIAogICAgaWYgZGVidWc6CiAgICAgICAgdGVzdF9zZXQudG9fcGFycXVldChtbGNvbmYuYXJ0aWZhY3RfcGF0aCsnL3Rlc3Rfc2V0LWRldi5wYXJxdWV0JykKICAgICAgICAKICAgIGNvbnRleHQubG9nX2RhdGFzZXQoInRlc3Rfc2V0IiwgZGY9dGVzdF9zZXQsIGZvcm1hdD1maWxlX2V4dCwgaW5kZXg9aW5kZXgpCgpkZWYgZHVtcF94Z2JfbW9kZWwoCiAgICBjb250ZXh0LCAKICAgIG1vZGVsLAogICAgZHVtcF90eXBlOiBzdHIsCiAgICBkZXN0X2ZvbGRlcjogc3RyLAogICAgZGVzdF9uYW1lOiBzdHIKKToKICAgICIiInNlcmlhbGl6ZS9sb2cgbW9kZWwKICAgIAogICAgWEdCb29zdCBtb2RlbCBjYW4gYmUgc2F2ZSBpbiAzIGRpZmZlcmVudCB3YXlzOgogICAgMS4gcGlja2xlIHRoZSBpbnRlcm5hbCBfYm9vc3RlciBvYmplY3QsIGluc2lkZSB0aGUgbW9kZWwKICAgIDIuIHVzaW5nIG1vZGVsLnNhdmVfbW9kZWwoImZuLmJpbiIpIHVzaW5nIGEgbGVnYWN5IGJpbmFyeSB4Z2IgZm9ybWF0CiAgICAyLiB1c2luZyBtb2RlbC5zYXZlX21vZGVsKCJmbi5qc29uIikgdXNpbmcgYSBwb3J0YWJsZSBqc29uIGZvcm1hdAogICAgCiAgICA6cGFyYW0gY29udGV4dDogICAgIHRoZSBmdW5jdGlvbiJzIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0gbW9kZWw6ICAgICAgIHRoZSBmaXR0ZWQgeGdib29zdCBtb2RlbAogICAgOnBhcmFtIGR1bXBfdHlwZTogICAicGlja2xlIiBsZWdhY3kiLCBvciAianNvbiIsIAogICAgOnBhcmFtIGRlc3RfZm9sZGVyOiBwYXRoIGZvciBzZXJpYWxpemVkIG1vZGVsIAogICAgOnBhcmFtIGRlc3RfbmFtZTogICBuYW1lIGZvciBzZXJpYWxpemVkIG1vZGVsIGZpbGUKICAgICIiIgogICAgZnJvbSBjbG91ZHBpY2tsZSBpbXBvcnQgZHVtcHMsIGR1bXAKICAgIHRyeToKICAgICAgICBtb2RlbC5zYXZlX21vZGVsKGYie2Rlc3RfZm9sZGVyfS97ZGVzdF9uYW1lfS1zYXZlX21vZGVsLnBrbCIpCiAgICAgICAgCiAgICAgICAgbW9kZWwuc2F2ZV9tb2RlbChmIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0tc2F2ZV9tb2RlbC5qc29uIikKICAgICAgICAKICAgICAgICBfYm9vc3RlciA9IG1vZGVsLmdldF9ib29zdGVyKCkKICAgICAgICBkdW1wKF9ib29zdGVyLCBvcGVuKGYie2Rlc3RfZm9sZGVyfS97ZGVzdF9uYW1lfS1kdW1wLnBrbCIsICJ3YiIpKQogICAgICAgIGR1bXAobW9kZWwsIG9wZW4oZiJ7ZGVzdF9mb2xkZXJ9L3tkZXN0X25hbWV9LWR1bXAtbW9kZWwucGtsIiwgIndiIikpCiAgICAgICAgCiAgICAgICAgZGF0YSA9IGR1bXBzKF9ib29zdGVyKQogICAgICAgIGNvbnRleHQubG9nX2FydGlmYWN0KCJtb2RlbCIsIGJvZHk9ZGF0YSwgbG9jYWxfcGF0aD1mIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0ucGtsIikKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBwcmludCgieGdib29zdCBtb2RlbCBzZXJpYWxpemF0aW9uIGVycm9yIiwgc3RyKGUpKQoKZGVmIHBsb3RfY29uZnVzaW9uX21hdHJpeCgKICAgIGxhYmVscywKICAgIHByZWRpY3Rpb25zLAogICAgY2xhc3NlcywKICAgIG5vcm1hbGl6ZT0iYWxsIiwKICAgIHRpdGxlPSdDb25mdXNpb24gbWF0cml4JywKICAgIGNtYXA9Tm9uZQopOgogICAgIiIicHJpbnRzIGFuZCBwbG90cyB0aGUgY29uZnVzaW9uIG1hdHJpeC4KICAgIAogICAgIiIiCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIGltcG9ydCBudW1weSBhcyBucAogICAgaW1wb3J0IGl0ZXJ0b29scwogICAgCiAgICBpZiBub3QgY21hcDoKICAgICAgICBjbWFwID0gcGx0LmNtLkJsdWVzCgogICAgY20gPSBtZXRyaWNzLmNvbmZ1c2lvbl9tYXRyaXgobGFiZWxzLCBwcmVkaWN0aW9ucywgbm9ybWFsaXplPW5vcm1hbGl6ZSkKICAgIAogICAgcGx0Lmltc2hvdyhjbSwgaW50ZXJwb2xhdGlvbj0nbmVhcmVzdCcsIGNtYXA9Y21hcCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5jb2xvcmJhcigpCiAgICB0aWNrX21hcmtzID0gbnAuYXJhbmdlKGxlbihjbGFzc2VzKSkKICAgIHBsdC54dGlja3ModGlja19tYXJrcywgY2xhc3Nlcywgcm90YXRpb249NDUpCiAgICBwbHQueXRpY2tzKHRpY2tfbWFya3MsIGNsYXNzZXMpCgogICAgdGhyZXNoID0gY20ubWF4KCkgLyAyLgogICAgZm9yIGksIGogaW4gaXRlcnRvb2xzLnByb2R1Y3QocmFuZ2UoY20uc2hhcGVbMF0pLCByYW5nZShjbS5zaGFwZVsxXSkpOgogICAgICAgIHBsdC50ZXh0KGosIGksIHJvdW5kKGNtW2ksIGpdLCAyKSwKICAgICAgICAgICAgICAgICBob3Jpem9udGFsYWxpZ25tZW50PSJjZW50ZXIiLAogICAgICAgICAgICAgICAgIGNvbG9yPSJ3aGl0ZSIgaWYgY21baSwgal0gPiB0aHJlc2ggZWxzZSAiYmxhY2siKQoKICAgIHBsdC55bGFiZWwoJ1RydWUgbGFiZWwnKQogICAgcGx0LnhsYWJlbCgnUHJlZGljdGVkIGxhYmVsJykKICAgIHJldHVybiBwbHQuZ2NmKCkKCmRlZiBwbG90X3JvYygKICAgIGNvbnRleHQsCiAgICB5X2xhYmVscywKICAgIHlfcHJvYnMsCiAgICBmcHJfbGFiZWw6IHN0ciA9ICJmYWxzZSBwb3NpdGl2ZSByYXRlIiwKICAgIHRwcl9sYWJlbDogc3RyID0gInRydWUgcG9zaXRpdmUgcmF0ZSIsCiAgICB0aXRsZTogc3RyID0gInJvYyBjdXJ2ZSIsCiAgICBsZWdlbmRfbG9jOiBzdHIgPSAiYmVzdCIsCik6CiAgICAiIiJwbG90IHJvYyBjdXJ2ZXMKCiAgICBUT0RPOiAgYWRkIGF2ZXJhZ2luZyBtZXRob2QgKGFzIHN0cmluZykgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgcHJvYnMsIAogICAgZGlzcGxheSBpbiBsZWdlbmQKCiAgICA6cGFyYW0gY29udGV4dDogICAgICB0aGUgZnVuY3Rpb24gY29udGV4dAogICAgOnBhcmFtIHlfbGFiZWxzOiAgICAgZ3JvdW5kIHRydXRoIGxhYmVscywgaG90IGVuY29kZWQgZm9yIG11bHRpY2xhc3MgIAogICAgOnBhcmFtIHlfcHJvYnM6ICAgICAgbW9kZWwgcHJlZGljdGlvbiBwcm9iYWJpbGl0aWVzCiAgICA6cGFyYW0ga2V5OiAgICAgICAgICAoInJvYyIpIGtleSBvZiBwbG90IGluIGFydGlmYWN0IHN0b3JlCiAgICA6cGFyYW0gcGxvdHNfZGlyOiAgICAoInBsb3RzIikgZGVzdGluYXRpb24gZm9sZGVyIHJlbGF0aXZlIHBhdGggdG8gYXJ0aWZhY3QgcGF0aAogICAgOnBhcmFtIGZtdDogICAgICAgICAgKCJwbmciKSBwbG90IGZvcm1hdAogICAgOnBhcmFtIGZwcl9sYWJlbDogICAgKCJmYWxzZSBwb3NpdGl2ZSByYXRlIikgeC1heGlzIGxhYmVscwogICAgOnBhcmFtIHRwcl9sYWJlbDogICAgKCJ0cnVlIHBvc2l0aXZlIHJhdGUiKSB5LWF4aXMgbGFiZWxzCiAgICA6cGFyYW0gdGl0bGU6ICAgICAgICAoInJvYyBjdXJ2ZSIpIHRpdGxlIG9mIHBsb3QKICAgIDpwYXJhbSBsZWdlbmRfbG9jOiAgICgiYmVzdCIpIGxvY2F0aW9uIG9mIHBsb3QgbGVnZW5kCiAgICAiIiIKICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgZnJvbSBtbHJ1bi5tbHV0aWxzIGltcG9ydCBnY2ZfY2xlYXIKICAgIAogICAgZ2NmX2NsZWFyKHBsdCkKCiAgICBwbHQucGxvdChbMCwgMV0sIFswLCAxXSwgImstLSIpCgogICAgcGx0LnhsYWJlbChmcHJfbGFiZWwpCiAgICBwbHQueWxhYmVsKHRwcl9sYWJlbCkKICAgIHBsdC50aXRsZSh0aXRsZSkKICAgIHBsdC5sZWdlbmQobG9jPWxlZ2VuZF9sb2MpCgogICAgaWYgeV9sYWJlbHMubmRpbSA+IDI6CiAgICAgICAgZnByID0gZGljdCgpCiAgICAgICAgdHByID0gZGljdCgpCiAgICAgICAgcm9jX2F1YyA9IGRpY3QoKQogICAgICAgIGZvciBpIGluIHJhbmdlKHlfbGFiZWxzWzosIDotMV0uc2hhcGVbMV0pOgogICAgICAgICAgICBmcHJbaV0sIHRwcltpXSwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKAogICAgICAgICAgICAgICAgeV9sYWJlbHNbOiwgaV0sIHlfcHJvYnNbOiwgaV0sIHBvc19sYWJlbD0xCiAgICAgICAgICAgICkKICAgICAgICAgICAgcm9jX2F1Y1tpXSA9IG1ldHJpY3MuYXVjKGZwcltpXSwgdHByW2ldKQogICAgICAgICAgICBwbHQucGxvdChmcHJbaV0sIHRwcltpXSwgbGFiZWw9ZiJjbGFzcyB7aX0iKQogICAgZWxzZToKICAgICAgICBmcHIsIHRwciwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKHlfbGFiZWxzLCB5X3Byb2JzWzosLTFdKQogICAgICAgIHBsdC5wbG90KGZwciwgdHByLCBsYWJlbD1mInBvc2l0aXZlIGNsYXNzIikKCiAgICByZXR1cm4gcGx0LmdjZigpCgpkZWYgZ2VuX3Byb2JhKAogICAgY29udGV4dCwKICAgIGZlYXRzLAogICAgbGFiZWxzLAogICAgbW9kZWwsCiAgICBzY29yZV9tZXRob2QsCiAgICBwbG90c19kZXN0LAogICAgbnRyZWVfbGltaXQ9Tm9uZSwKICAgIHZhbGlkYXRlX2ZlYXR1cmVzPVRydWUsCiAgICBiYXNlX21hcmdpbj1Ob25lCik6CiAgICAiIiIgZ2VuZXJhdGUgcHJlZGljdGlvbnMgYW5kIHZhbGlkYXRpb24gc3RhdHMKICAgIAogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBmZWF0czogICAgICAgICAgICAgdmFsaWRhdGlvbiBmZWF0dXJlcyBhcnJheSAKICAgIDpwYXJhbSBsYWJlbHM6ICAgICAgICAgICAgdmFsaWRhdGlvbiBncm91bmQtdHJ1dGggbGFiZWxzCiAgICA6cGFyYW0gbW9kZWw6ICAgICAgICAgICAgIGVzdGltYXRlZCBtb2RlbAogICAgOnBhcmFtIHNjcm9yZV9tZXRob2Q6ICAgICAoImF2ZXJhZ2UiKSBtdWx0aWNsYXNzIHNjb3JpbmcKICAgIDpwYXJhbSBwbG90c19kZXN0OiAgICAgICAgZGVzdGluYXRpb24gZm9sZGVyIGZvciBwbG90IGFydGlmYWN0cwogICAgOnBhcmFtIG50cmVlX2xpbWl0OiAgICAgICAoTm9uZSkgbGltaXQgbm8uIHRyZWVzIHVzZWQgaW4gcHJlZGljdGlvbgogICAgOnBhcmFtIHZhbGlkYXRlX2ZlYXR1cmVzOiAoVHJ1ZSkgZW5zdXJlIGNvbnNpc3RlbnQgZmVhdHVyZSBuYW1lcyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV0d2VlbiBtb2RlbCBhbmQgaW5wdXQgZGF0YQogICAgOnBhcmFtIGJhc2VfbWFyZ2luOiAgICAgICAoTm9uZSkgdW5kZWZpbmVkCiAgICAiIiIKICAgIGZyb20gc2tsZWFybiBpbXBvcnQgbWV0cmljcwogICAgZnJvbSBtbHJ1bi5hcnRpZmFjdHMgaW1wb3J0IFBsb3RBcnRpZmFjdAogICAgZnJvbSBtbHJ1bi5tbHV0aWxzIGltcG9ydCBnY2ZfY2xlYXIKICAgIGZyb20geGdib29zdCBpbXBvcnQgWEdCQ2xhc3NpZmllcgogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgCiAgICB5cHJlZCA9IG1vZGVsLnByZWRpY3QoZmVhdHMsIEZhbHNlLCBudHJlZV9saW1pdCwgdmFsaWRhdGVfZmVhdHVyZXMsIGJhc2VfbWFyZ2luKQogICAgCiAgICB5X3Byb2JhID0gW10KICAgIGlmIGhhc2F0dHIobW9kZWwsICJwcmVkaWN0X3Byb2JhIik6CiAgICAgICAgeV9wcm9iYSA9IG1vZGVsLnByZWRpY3RfcHJvYmEoZmVhdHMsIG50cmVlX2xpbWl0LCB2YWxpZGF0ZV9mZWF0dXJlcywgYmFzZV9tYXJnaW4pCiAgICB5cHJlZF9iaW5hcnkgPSBbcm91bmQodmFsdWUpIGZvciB2YWx1ZSBpbiB5X3Byb2JhWzosLTFdXQogICAgCiAgICBhdmVyYWdlX3ByZWNpc2lvbiA9IG1ldHJpY3MuYXZlcmFnZV9wcmVjaXNpb25fc2NvcmUobGFiZWxzLCB5X3Byb2JhWzosLTFdLCBhdmVyYWdlPXNjb3JlX21ldGhvZCkKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmImF2Z19wcmVjaXNpb24iLCBhdmVyYWdlX3ByZWNpc2lvbikKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmInJvY2F1YyIsIG1ldHJpY3Mucm9jX2F1Y19zY29yZShsYWJlbHMsIHlfcHJvYmFbOiwtMV0pKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYiYWNjdXJhY3lfc2NvcmUiLCBmbG9hdChtZXRyaWNzLmFjY3VyYWN5X3Njb3JlKGxhYmVscywgeXByZWRfYmluYXJ5KSkpCiAgICBjb250ZXh0LmxvZ19yZXN1bHQoZiJmMV9zY29yZSIsIG1ldHJpY3MuZjFfc2NvcmUobGFiZWxzLCB5cHJlZF9iaW5hcnksIGF2ZXJhZ2U9c2NvcmVfbWV0aG9kKSkKICAgIAogICAgY29udGV4dC5sb2dfYXJ0aWZhY3QoUGxvdEFydGlmYWN0KCJyb2MiLCBib2R5PXBsb3Rfcm9jKGNvbnRleHQsIGxhYmVscywgeV9wcm9iYSkpLAogICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxfcGF0aD1mIntwbG90c19kZXN0fS9yb2MuaHRtbCIpCiAgICBnY2ZfY2xlYXIocGx0KQoKICAgIGJvZHkgPSBwbG90X2NvbmZ1c2lvbl9tYXRyaXgobGFiZWxzLCB5cHJlZF9iaW5hcnksIGNsYXNzZXM9bGFiZWxzLmxhYmVscy51bmlxdWUoKSkgCiAgICBjb250ZXh0LmxvZ19hcnRpZmFjdChQbG90QXJ0aWZhY3QoImNvbmZ1c2lvbiIsIGJvZHk9Ym9keSksIGxvY2FsX3BhdGg9ZiJ7cGxvdHNfZGVzdH0vY29uZnVzaW9uLmh0bWwiKQogICAgCiAgICByZXR1cm4geV9wcm9iYQoKZGVmIHByb2JhX2NhbGlicmF0aW9uKG1vZGVsLCB4Y2FsLCB5Y2FsKToKICAgICIiImNhbGlicmF0ZSBvdXRwdXQgcHJvYmFiaWxpdGllcwogICAgCiAgICBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zY2lraXQtbGVhcm4ub3JnL3N0YWJsZS9hdXRvX2V4YW1wbGVzL2NhbGlicmF0aW9uL3Bsb3RfY2FsaWJyYXRpb25fY3VydmUuaHRtbCNzcGh4LWdsci1hdXRvLWV4YW1wbGVzLWNhbGlicmF0aW9uLXBsb3QtY2FsaWJyYXRpb24tY3VydmUtcHkKICAgICIiIgogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgZnJvbSBza2xlYXJuLmNhbGlicmF0aW9uIGltcG9ydCAoQ2FsaWJyYXRlZENsYXNzaWZpZXJDViwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGlicmF0aW9uX2N1cnZlKQogICAgZnJvbSBza2xlYXJuLmxpbmVhcl9tb2RlbCBpbXBvcnQgTG9naXN0aWNSZWdyZXNzaW9uCiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIAogICAgZGVmIHBsb3RfY2FsaWJyYXRpb25fY3VydmUobmFtZSwgZmlnX2luZGV4KToKICAgICAgICAiIiJQbG90IGNhbGlicmF0aW9uIGN1cnZlIGZvciBlc3Qgdy9vIGFuZCB3aXRoIGNhbGlicmF0aW9uLiAiIiIKICAgICAgICBpc290b25pYyA9IENhbGlicmF0ZWRDbGFzc2lmaWVyQ1YobW9kZWwsIGN2PSJwcmVmaXQiLCBtZXRob2Q9J2lzb3RvbmljJykKCiAgICAgICAgc2lnbW9pZCA9IENhbGlicmF0ZWRDbGFzc2lmaWVyQ1YobW9kZWwsIGN2PSJwcmVmaXQiLCBtZXRob2Q9J3NpZ21vaWQnKQoKICAgICAgICBsciA9IExvZ2lzdGljUmVncmVzc2lvbihDPTEuKQoKICAgICAgICBmaWcgPSBwbHQuZmlndXJlKGZpZ19pbmRleCwgZmlnc2l6ZT0oMTAsIDEwKSkKICAgICAgICBheDEgPSBwbHQuc3VicGxvdDJncmlkKCgzLCAxKSwgKDAsIDApLCByb3dzcGFuPTIpCiAgICAgICAgYXgyID0gcGx0LnN1YnBsb3QyZ3JpZCgoMywgMSksICgyLCAwKSkKCiAgICAgICAgYXgxLnBsb3QoWzAsIDFdLCBbMCwgMV0sICJrOiIsIGxhYmVsPSJQZXJmZWN0bHkgY2FsaWJyYXRlZCIpCiAgICAgICAgZm9yIGNsZiwgbmFtZSBpbiBbKGxyLCAnTG9naXN0aWMnKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAobW9kZWwsIG5hbWUpLAogICAgICAgICAgICAgICAgICAgICAgICAgIChpc290b25pYywgbmFtZSArICcgKyBJc290b25pYycpLAogICAgICAgICAgICAgICAgICAgICAgICAgIChzaWdtb2lkLCBuYW1lICsgJyArIFNpZ21vaWQnKV06CiAgICAgICAgICAgIGNsZi5maXQoeGNhbCwgeWNhbCkKICAgICAgICAgICAgeV9wcmVkID0gY2xmLnByZWRpY3QoeGNhbCkKICAgICAgICAgICAgaWYgaGFzYXR0cihjbGYsICJwcmVkaWN0X3Byb2JhIik6CiAgICAgICAgICAgICAgICBwcm9iX3BvcyA9IGNsZi5wcmVkaWN0X3Byb2JhKHhjYWwpWzosIDFdCiAgICAgICAgICAgIGVsc2U6ICAjIHVzZSBkZWNpc2lvbiBmdW5jdGlvbgogICAgICAgICAgICAgICAgcHJvYl9wb3MgPSBjbGYuZGVjaXNpb25fZnVuY3Rpb24oeGNhbCkKICAgICAgICAgICAgICAgIHByb2JfcG9zID0gICAgICAgICAgICAgICAgICAgICAocHJvYl9wb3MgLSBwcm9iX3Bvcy5taW4oKSkgLyAocHJvYl9wb3MubWF4KCkgLSBwcm9iX3Bvcy5taW4oKSkKCiAgICAgICAgICAgIGNsZl9zY29yZSA9IG1ldHJpY3MuYnJpZXJfc2NvcmVfbG9zcyh5Y2FsLCBwcm9iX3BvcywgcG9zX2xhYmVsPTEpICMgcG9zX2xhYmVsPXljYWwubWF4KCkpCiAgICAgICAgICAgIHByaW50KCIlczoiICUgbmFtZSkKICAgICAgICAgICAgcHJpbnQoIlx0QnJpZXI6ICUxLjNmIiAlIChjbGZfc2NvcmUpKQogICAgICAgICAgICBwcmludCgiXHRQcmVjaXNpb246ICUxLjNmIiAlIG1ldHJpY3MucHJlY2lzaW9uX3Njb3JlKHljYWwsIHlfcHJlZCkpCiAgICAgICAgICAgIHByaW50KCJcdFJlY2FsbDogJTEuM2YiICUgbWV0cmljcy5yZWNhbGxfc2NvcmUoeWNhbCwgeV9wcmVkKSkKICAgICAgICAgICAgcHJpbnQoIlx0RjE6ICUxLjNmXG4iICUgbWV0cmljcy5mMV9zY29yZSh5Y2FsLCB5X3ByZWQpKQoKICAgICAgICAgICAgZnJhY3Rpb25fb2ZfcG9zaXRpdmVzLCBtZWFuX3ByZWRpY3RlZF92YWx1ZSA9ICAgICAgICAgICAgICAgICBjYWxpYnJhdGlvbl9jdXJ2ZSh5Y2FsLCBwcm9iX3Bvcywgbl9iaW5zPTEwKQoKICAgICAgICAgICAgYXgxLnBsb3QobWVhbl9wcmVkaWN0ZWRfdmFsdWUsIGZyYWN0aW9uX29mX3Bvc2l0aXZlcywgInMtIiwKICAgICAgICAgICAgICAgICAgICAgbGFiZWw9IiVzICglMS4zZikiICUgKG5hbWUsIGNsZl9zY29yZSkpCgogICAgICAgICAgICBheDIuaGlzdChwcm9iX3BvcywgcmFuZ2U9KDAsIDEpLCBiaW5zPTEwLCBsYWJlbD1uYW1lLAogICAgICAgICAgICAgICAgICAgICBoaXN0dHlwZT0ic3RlcCIsIGx3PTIpCgogICAgICAgIGF4MS5zZXRfeWxhYmVsKCJGcmFjdGlvbiBvZiBwb3NpdGl2ZXMiKQogICAgICAgIGF4MS5zZXRfeWxpbShbLTAuMDUsIDEuMDVdKQogICAgICAgIGF4MS5sZWdlbmQobG9jPSJsb3dlciByaWdodCIpCiAgICAgICAgYXgxLnNldF90aXRsZSgnQ2FsaWJyYXRpb24gcGxvdHMgIChyZWxpYWJpbGl0eSBjdXJ2ZSknKQoKICAgICAgICBheDIuc2V0X3hsYWJlbCgiTWVhbiBwcmVkaWN0ZWQgdmFsdWUiKQogICAgICAgIGF4Mi5zZXRfeWxhYmVsKCJDb3VudCIpCiAgICAgICAgYXgyLmxlZ2VuZChsb2M9InVwcGVyIGNlbnRlciIsIG5jb2w9MikKCiAgICAgICAgcGx0LnRpZ2h0X2xheW91dCgpCgogICAgcGxvdF9jYWxpYnJhdGlvbl9jdXJ2ZSgiWEdCb29zdCIsIDEpCgogICAgcGx0LnNob3coKQoKZGVmIHRyYWluX21vZGVsKAogICAgY29udGV4dCwKICAgIG1vZGVsX3R5cGU6IHN0ciwKICAgIGRhdGFzZXQsCiAgICBsYWJlbF9jb2x1bW46IHN0ciA9ICJsYWJlbHMiLAogICAgc2FtcGxlOiBpbnQgPSAtMSwKICAgIHRlc3Rfc2l6ZTogZmxvYXQgPSAwLjA1LAogICAgdmFsaWRfc2l6ZTogZmxvYXQgPSAwLjc1LAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSAxLAogICAgbW9kZWxfZmlsZW5hbWU6IHN0ciA9ICJtb2RlbCIsCiAgICBtb2RlbHNfZGVzdDogc3RyID0gIiIsCiAgICBwbG90c19kZXN0OiBzdHIgPSAiIiwKICAgIHNjb3JlX21ldGhvZDogc3RyID0gIm1pY3JvIiwKICAgIGZpbGVfZXh0OiBzdHIgPSAicGFycXVldCIsCiAgICBtb2RlbF9wa2dfZmlsZTogc3RyID0gIiIsICAgIAopIC0+IE5vbmU6CiAgICAiIiJ0cmFpbiBhbiB4Z2Jvb3N0IG1vZGVsLgoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgdGhlIGZ1bmN0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBtb2RlbF90eXBlOiAgICAgICAgdGhlIG1vZGVsIHR5cGUgdG8gdHJhaW4sICdjbGFzc2lmaWVyJywgJ3JlZ3Jlc3NvcicuLi4KICAgIDpwYXJhbSBkYXRhc2V0OiAgICAgICAgICAgKCJkYXRhIikgbmFtZSBvZiByYXcgZGF0YSBmaWxlCiAgICA6cGFyYW0gbGFiZWxfY29sdW1uOiAgICAgIGdyb3VuZC10cnV0aCAoeSkgbGFiZWxzCiAgICA6cGFyYW0gc2FtcGxlOiAgICAgICAgICAgIFNlbGVjdHMgdGhlIGZpcnN0IG4gcm93cywgb3Igc2VsZWN0IGEgc2FtcGxlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0LiBJZiBuZWdhdGl2ZSA8LTEsIHNlbGVjdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHJhbmRvbSBzYW1wbGUKICAgIDpwYXJhbSBtb2RlbF9maWxlbmFtZTogICAgbW9kZWwgZmlsZSBmaWxlbmFtZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzIHRvIGEgZGlyZWN0b3J5CiAgICA6cGFyYW0gdGVzdF9zaXplOiAgICAgICAgICgwLjA1KSB0ZXN0IHNldCBzaXplCiAgICA6cGFyYW0gdmFsaWRfc2l6ZTogICAgICAgICAgKDAuNzUpIE9uY2UgdGhlIHRlc3Qgc2V0IGhhcyBiZWVuIHJlbW92ZWQgdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWluaW5nIHNldCBnZXRzIHRoaXMgcHJvcG9ydGlvbi4KICAgIDpwYXJhbSByYW5kb21fc3RhdGU6ICAgICAgKDEpIHNrbGVhcm4gcm5nIHNlZWQKICAgIDpwYXJhbSBtb2RlbHNfZGVzdDogICAgICAgbW9kZWxzIHN1YmZvbGRlciBvbiBhcnRpZmFjdCBwYXRoCiAgICA6cGFyYW0gcGxvdHNfZGVzdDogICAgICAgIHBsb3Qgc3ViZm9sZGVyIG9uIGFydGlmYWN0IHBhdGgKICAgIDpwYXJhbSBzY29yZV9tZXRob2Q6ICAgICAgZm9yIG11bHRpY2xhc3MgY2xhc3NpZmljYXRpb24KICAgIAogICAgOnBhcmFtIGZpbGVfZXh0OiAgICAgICAgICBmb3JtYXQgZm9yIHRlc3Rfc2V0X2tleSBob2xkIG91dCBkYXRhCiAgICA6cGFyYW0gbW9kZWxfcGtnX2ZpbGU6ICAgIGpzb24gbW9kZWwgY29uZmlnIGZpbGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAiIiIKICAgIG1vZGVsc19kZXN0ID0gbW9kZWxzX2Rlc3Qgb3IgIm1vZGVscyIKICAgIHBsb3RzX2Rlc3QgPSBwbG90c19kZXN0IG9yIGYicGxvdHMve2NvbnRleHQubmFtZX0iCiAgICAKICAgIHJhdywgbGFiZWxzLCBoZWFkZXIgPSBnZXRfc2FtcGxlKHN0cihkYXRhc2V0KSwgc2FtcGxlLCBsYWJlbF9jb2x1bW4pCiAgICAKICAgICh4dHIseXRyKSwgKHh2YSx5dmEpLCAoeHRlLHl0ZSksICh4Y2FsLCB5Y2FsKSA9IGdldF9zcGxpdHMocmF3LCBsYWJlbHMsIDQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Rfc2l6ZSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkX3NpemUsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbImxhYmVscyJdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5kb21fc3RhdGUpCiAgICAgICAgCiAgICBtb2RlbCwgbW9kZWxfY29uZmlnID0gZ2VuX3hnYl9tb2RlbChtb2RlbF90eXBlLCBjb250ZXh0LnBhcmFtZXRlcnMuaXRlbXMoKSkKICAgIAogICAgbW9kZWxfY29uZmlnWyJGSVQiXS51cGRhdGUoeyJYIjogeHRyLCJ5IjogeXRyLnZhbHVlc30pCiAgICAKICAgIG1vZGVsLmZpdCgqKm1vZGVsX2NvbmZpZ1siRklUIl0pCiAgICAKICAgIGR1bXBfeGdiX21vZGVsKGNvbnRleHQsIG1vZGVsLCAianNvbiIsIG1vZGVsc19kZXN0LCBtb2RlbF9maWxlbmFtZSkKCiAgICB5X3Byb2JhID0gZ2VuX3Byb2JhKGNvbnRleHQsIHh2YSwgeXZhLCBtb2RlbCwgc2NvcmVfbWV0aG9kLCBwbG90c19kZXN0KQogICAgCiAgICB5X3Byb2JhX2NhbCA9IHByb2JhX2NhbGlicmF0aW9uKG1vZGVsLCB4Y2FsLCB5Y2FsKQoK
    commands: []
    code_origin: https://github.com/yjb-ds/functions.git#733059af34bbe63a7b2ce43ee1021289bd161565:xgb_trainer.ipynb
