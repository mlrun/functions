kind: job
metadata:
  name: onnx-utils
  tag: ''
  hash: f78c685a6271974341117155176194e16367c2aa
  project: default
  labels:
    author: guyl
  categories:
  - Utilities
spec:
  command: ''
  args: []
  image: mlrun/ml-models
  env: []
  default_handler: to_onnx
  entry_points:
    tf_keras_to_onnx:
      name: tf_keras_to_onnx
      doc: Convert a TF.Keras model to an ONNX model and log it back to MLRun as a
        new model object.
      parameters:
      - name: model_handler
        doc: An initialized TFKerasModelHandler with a loaded model to convert to
          ONNX.
        default: ''
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether or not to optimize the ONNX model using 'onnxoptimizer' before
          saving the model. Defaulted to True.
        default: true
      - name: input_signature
        type: List[Tuple[Tuple[int], str]]
        doc: 'A list of the input layers shape and data type properties. Expected
          to receive a list where each element is an input layer tuple. An input layer
          tuple is a tuple of: [0] = Layer''s shape, a tuple of integers. [1] = Layer''s
          data type, a mlrun.data_types.ValueType string. If None, the input signature
          will be tried to be read from the model artifact. Defaulted to None.'
        default: null
      outputs:
      - default: ''
      lineno: 12
    pytorch_to_onnx:
      name: pytorch_to_onnx
      doc: Convert a PyTorch model to an ONNX model and log it back to MLRun as a
        new model object.
      parameters:
      - name: model_handler
        doc: An initialized PyTorchModelHandler with a loaded model to convert to
          ONNX.
        default: ''
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether or not to optimize the ONNX model using 'onnxoptimizer' before
          saving the model. Defaulted to True.
        default: true
      - name: input_signature
        type: List[Tuple[Tuple[int], str]]
        doc: 'A list of the input layers shape and data type properties. Expected
          to receive a list where each element is an input layer tuple. An input layer
          tuple is a tuple of: [0] = Layer''s shape, a tuple of integers. [1] = Layer''s
          data type, a mlrun.data_types.ValueType string. If None, the input signature
          will be tried to be read from the model artifact. Defaulted to None.'
        default: null
      - name: input_layers_names
        type: List[str]
        doc: 'List of names to assign to the input nodes of the graph in order. All
          of the other parameters (inner layers) can be set as well by passing additional
          names in the list. The order is by the order of the parameters in the model.
          If None, the inputs will be read from the handler''s inputs. If its also
          None, it is defaulted to: "input_0", "input_1", ...'
        default: null
      - name: output_layers_names
        type: List[str]
        doc: 'List of names to assign to the output nodes of the graph in order. If
          None, the outputs will be read from the handler''s outputs. If its also
          None, it is defaulted to: "output_0" (for multiple outputs, this parameter
          must be provided).'
        default: null
      - name: dynamic_axes
        type: Dict[str, Dict[int, str]]
        doc: 'If part of the input / output shape is dynamic, like (batch_size, 3,
          32, 32) you can specify it by giving a dynamic axis to the input / output
          layer by its name as follows: { "input layer name": {0: "batch_size"}, "output
          layer name": {0: "batch_size"}, } If provided, the ''is_batched'' flag will
          be ignored. Defaulted to None.'
        default: null
      - name: is_batched
        type: bool
        doc: Whether to include a batch size as the first axis in every input and
          output layer. Defaulted to True. Will be ignored if 'dynamic_axes' is provided.
        default: true
      outputs:
      - default: ''
      lineno: 66
    to_onnx:
      name: to_onnx
      doc: Convert the given model to an ONNX model.
      parameters:
      - name: context
        type: MLClientCtx
        doc: The MLRun function execution context
        default: ''
      - name: model_path
        type: str
        doc: The model path store object.
        default: ''
      - name: onnx_model_name
        type: str
        doc: The name to use to log the converted ONNX model. If not given, the given
          `model_name` will be used with an additional suffix `_onnx`. Defaulted to
          None.
        default: null
      - name: optimize_model
        type: bool
        doc: Whether to optimize the ONNX model using 'onnxoptimizer' before saving
          the model. Defaulted to True.
        default: true
      - name: framework_kwargs
        type: Dict[str, Any]
        doc: Additional arguments each framework may require in order to convert to
          ONNX. To get the doc string of the desired framework onnx conversion function,
          pass "help".
        default: null
      outputs:
      - default: ''
      lineno: 144
    optimize:
      name: optimize
      doc: Optimize the given ONNX model.
      parameters:
      - name: context
        type: MLClientCtx
        doc: The MLRun function execution context.
        default: ''
      - name: model_path
        type: str
        doc: Path to the ONNX model object.
        default: ''
      - name: optimizations
        type: List[str]
        doc: List of possible optimizations. To see what optimizations are available,
          pass "help". If None, all of the optimizations will be used. Defaulted to
          None.
        default: null
      - name: fixed_point
        type: bool
        doc: Optimize the weights using fixed point. Defaulted to False.
        default: false
      - name: optimized_model_name
        type: str
        doc: The name of the optimized model. If None, the original model will be
          overridden. Defaulted to None.
        default: null
      outputs:
      - default: ''
      lineno: 203
  description: ONNX intigration in MLRun, some utils functions for the ONNX framework,
    optimizing and converting models from different framework to ONNX using MLRun.
  build:
    functionSourceCode: ZnJvbSB0eXBpbmcgaW1wb3J0IEFueSwgQ2FsbGFibGUsIERpY3QsIExpc3QsIFR1cGxlCgppbXBvcnQgbWxydW4KCgpjbGFzcyBfVG9PTk5YQ29udmVyc2lvbnM6CiAgICAiIiIKICAgIEFuIE9OTlggY29udmVyc2lvbiBmdW5jdGlvbnMgbGlicmFyeSBjbGFzcy4KICAgICIiIgoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiB0Zl9rZXJhc190b19vbm54KAogICAgICAgIG1vZGVsX2hhbmRsZXIsCiAgICAgICAgb25ueF9tb2RlbF9uYW1lOiBzdHIgPSBOb25lLAogICAgICAgIG9wdGltaXplX21vZGVsOiBib29sID0gVHJ1ZSwKICAgICAgICBpbnB1dF9zaWduYXR1cmU6IExpc3RbVHVwbGVbVHVwbGVbaW50XSwgc3RyXV0gPSBOb25lLAogICAgKToKICAgICAgICAiIiIKICAgICAgICBDb252ZXJ0IGEgVEYuS2VyYXMgbW9kZWwgdG8gYW4gT05OWCBtb2RlbCBhbmQgbG9nIGl0IGJhY2sgdG8gTUxSdW4gYXMgYSBuZXcgbW9kZWwgb2JqZWN0LgoKICAgICAgICA6cGFyYW0gbW9kZWxfaGFuZGxlcjogICBBbiBpbml0aWFsaXplZCBURktlcmFzTW9kZWxIYW5kbGVyIHdpdGggYSBsb2FkZWQgbW9kZWwgdG8gY29udmVydCB0byBPTk5YLgogICAgICAgIDpwYXJhbSBvbm54X21vZGVsX25hbWU6IFRoZSBuYW1lIHRvIHVzZSB0byBsb2cgdGhlIGNvbnZlcnRlZCBPTk5YIG1vZGVsLiBJZiBub3QgZ2l2ZW4sIHRoZSBnaXZlbiBgbW9kZWxfbmFtZWAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHVzZWQgd2l0aCBhbiBhZGRpdGlvbmFsIHN1ZmZpeCBgX29ubnhgLiBEZWZhdWx0ZWQgdG8gTm9uZS4KICAgICAgICA6cGFyYW0gb3B0aW1pemVfbW9kZWw6ICBXaGV0aGVyIG9yIG5vdCB0byBvcHRpbWl6ZSB0aGUgT05OWCBtb2RlbCB1c2luZyAnb25ueG9wdGltaXplcicgYmVmb3JlIHNhdmluZyB0aGUgbW9kZWwuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdGVkIHRvIFRydWUuCiAgICAgICAgOnBhcmFtIGlucHV0X3NpZ25hdHVyZTogQSBsaXN0IG9mIHRoZSBpbnB1dCBsYXllcnMgc2hhcGUgYW5kIGRhdGEgdHlwZSBwcm9wZXJ0aWVzLiBFeHBlY3RlZCB0byByZWNlaXZlIGEgbGlzdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBhbiBpbnB1dCBsYXllciB0dXBsZS4gQW4gaW5wdXQgbGF5ZXIgdHVwbGUgaXMgYSB0dXBsZSBvZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMF0gPSBMYXllcidzIHNoYXBlLCBhIHR1cGxlIG9mIGludGVnZXJzLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxXSA9IExheWVyJ3MgZGF0YSB0eXBlLCBhIG1scnVuLmRhdGFfdHlwZXMuVmFsdWVUeXBlIHN0cmluZy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBOb25lLCB0aGUgaW5wdXQgc2lnbmF0dXJlIHdpbGwgYmUgdHJpZWQgdG8gYmUgcmVhZCBmcm9tIHRoZSBtb2RlbCBhcnRpZmFjdC4gRGVmYXVsdGVkCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gTm9uZS4KICAgICAgICAiIiIKICAgICAgICAjIEltcG9ydCB0aGUgZnJhbWV3b3JrIGFuZCBoYW5kbGVyOgogICAgICAgIGltcG9ydCB0ZW5zb3JmbG93IGFzIHRmCgogICAgICAgICMgQ2hlY2sgdGhlIGdpdmVuICdpbnB1dF9zaWduYXR1cmUnIHBhcmFtZXRlcjoKICAgICAgICBpZiBpbnB1dF9zaWduYXR1cmUgaXMgTm9uZToKICAgICAgICAgICAgIyBSZWFkIHRoZSBpbnB1dHMgZnJvbSB0aGUgbW9kZWw6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIG1vZGVsX2hhbmRsZXIucmVhZF9pbnB1dHNfZnJvbV9tb2RlbCgpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXJyb3I6CiAgICAgICAgICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5SdW50aW1lRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgZiJQbGVhc2UgcHJvdmlkZSB0aGUgJ2lucHV0X3NpZ25hdHVyZScgcGFyYW1ldGVyLiBUaGUgZnVuY3Rpb24gdHJpZWQgcmVhZGluZyB0aGUgaW5wdXQgbGF5ZXJzICIKICAgICAgICAgICAgICAgICAgICBmImluZm9ybWF0aW9uIGF1dG9tYXRpY2FsbHkgYnV0IGZhaWxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3I6IHtlcnJvcn0iCiAgICAgICAgICAgICAgICApCiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyBQYXJzZSB0aGUgJ2lucHV0X3NpZ25hdHVyZScgcGFyYW1ldGVyOgogICAgICAgICAgICBpbnB1dF9zaWduYXR1cmUgPSBbCiAgICAgICAgICAgICAgICB0Zi5UZW5zb3JTcGVjKAogICAgICAgICAgICAgICAgICAgIHNoYXBlPXNoYXBlLAogICAgICAgICAgICAgICAgICAgIGR0eXBlPW1vZGVsX2hhbmRsZXIuY29udmVydF92YWx1ZV90eXBlX3RvX3RmX2R0eXBlKAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV90eXBlPXZhbHVlX3R5cGUKICAgICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgZm9yIChzaGFwZSwgdmFsdWVfdHlwZSkgaW4gaW5wdXRfc2lnbmF0dXJlCiAgICAgICAgICAgIF0KCiAgICAgICAgIyBDb252ZXJ0IHRvIE9OTlg6CiAgICAgICAgbW9kZWxfaGFuZGxlci50b19vbm54KAogICAgICAgICAgICBtb2RlbF9uYW1lPW9ubnhfbW9kZWxfbmFtZSwKICAgICAgICAgICAgaW5wdXRfc2lnbmF0dXJlPWlucHV0X3NpZ25hdHVyZSwKICAgICAgICAgICAgb3B0aW1pemU9b3B0aW1pemVfbW9kZWwsCiAgICAgICAgKQoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBweXRvcmNoX3RvX29ubngoCiAgICAgICAgbW9kZWxfaGFuZGxlciwKICAgICAgICBvbm54X21vZGVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICAgICAgb3B0aW1pemVfbW9kZWw6IGJvb2wgPSBUcnVlLAogICAgICAgIGlucHV0X3NpZ25hdHVyZTogTGlzdFtUdXBsZVtUdXBsZVtpbnRdLCBzdHJdXSA9IE5vbmUsCiAgICAgICAgaW5wdXRfbGF5ZXJzX25hbWVzOiBMaXN0W3N0cl0gPSBOb25lLAogICAgICAgIG91dHB1dF9sYXllcnNfbmFtZXM6IExpc3Rbc3RyXSA9IE5vbmUsCiAgICAgICAgZHluYW1pY19heGVzOiBEaWN0W3N0ciwgRGljdFtpbnQsIHN0cl1dID0gTm9uZSwKICAgICAgICBpc19iYXRjaGVkOiBib29sID0gVHJ1ZSwKICAgICk6CiAgICAgICAgIiIiCiAgICAgICAgQ29udmVydCBhIFB5VG9yY2ggbW9kZWwgdG8gYW4gT05OWCBtb2RlbCBhbmQgbG9nIGl0IGJhY2sgdG8gTUxSdW4gYXMgYSBuZXcgbW9kZWwgb2JqZWN0LgoKICAgICAgICA6cGFyYW0gbW9kZWxfaGFuZGxlcjogICAgICAgQW4gaW5pdGlhbGl6ZWQgUHlUb3JjaE1vZGVsSGFuZGxlciB3aXRoIGEgbG9hZGVkIG1vZGVsIHRvIGNvbnZlcnQgdG8gT05OWC4KICAgICAgICA6cGFyYW0gb25ueF9tb2RlbF9uYW1lOiAgICAgVGhlIG5hbWUgdG8gdXNlIHRvIGxvZyB0aGUgY29udmVydGVkIE9OTlggbW9kZWwuIElmIG5vdCBnaXZlbiwgdGhlIGdpdmVuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtb2RlbF9uYW1lYCB3aWxsIGJlIHVzZWQgd2l0aCBhbiBhZGRpdGlvbmFsIHN1ZmZpeCBgX29ubnhgLiBEZWZhdWx0ZWQgdG8gTm9uZS4KICAgICAgICA6cGFyYW0gb3B0aW1pemVfbW9kZWw6ICAgICAgV2hldGhlciBvciBub3QgdG8gb3B0aW1pemUgdGhlIE9OTlggbW9kZWwgdXNpbmcgJ29ubnhvcHRpbWl6ZXInIGJlZm9yZSBzYXZpbmcgdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLiBEZWZhdWx0ZWQgdG8gVHJ1ZS4KICAgICAgICA6cGFyYW0gaW5wdXRfc2lnbmF0dXJlOiAgICAgQSBsaXN0IG9mIHRoZSBpbnB1dCBsYXllcnMgc2hhcGUgYW5kIGRhdGEgdHlwZSBwcm9wZXJ0aWVzLiBFeHBlY3RlZCB0byByZWNlaXZlIGEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYW4gaW5wdXQgbGF5ZXIgdHVwbGUuIEFuIGlucHV0IGxheWVyIHR1cGxlIGlzIGEgdHVwbGUgb2Y6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswXSA9IExheWVyJ3Mgc2hhcGUsIGEgdHVwbGUgb2YgaW50ZWdlcnMuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxXSA9IExheWVyJ3MgZGF0YSB0eXBlLCBhIG1scnVuLmRhdGFfdHlwZXMuVmFsdWVUeXBlIHN0cmluZy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgTm9uZSwgdGhlIGlucHV0IHNpZ25hdHVyZSB3aWxsIGJlIHRyaWVkIHRvIGJlIHJlYWQgZnJvbSB0aGUgbW9kZWwgYXJ0aWZhY3QuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRlZCB0byBOb25lLgogICAgICAgIDpwYXJhbSBpbnB1dF9sYXllcnNfbmFtZXM6ICBMaXN0IG9mIG5hbWVzIHRvIGFzc2lnbiB0byB0aGUgaW5wdXQgbm9kZXMgb2YgdGhlIGdyYXBoIGluIG9yZGVyLiBBbGwgb2YgdGhlIG90aGVyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMgKGlubmVyIGxheWVycykgY2FuIGJlIHNldCBhcyB3ZWxsIGJ5IHBhc3NpbmcgYWRkaXRpb25hbCBuYW1lcyBpbiB0aGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC4gVGhlIG9yZGVyIGlzIGJ5IHRoZSBvcmRlciBvZiB0aGUgcGFyYW1ldGVycyBpbiB0aGUgbW9kZWwuIElmIE5vbmUsIHRoZSBpbnB1dHMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSByZWFkIGZyb20gdGhlIGhhbmRsZXIncyBpbnB1dHMuIElmIGl0cyBhbHNvIE5vbmUsIGl0IGlzIGRlZmF1bHRlZCB0bzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlucHV0XzAiLCAiaW5wdXRfMSIsIC4uLgogICAgICAgIDpwYXJhbSBvdXRwdXRfbGF5ZXJzX25hbWVzOiBMaXN0IG9mIG5hbWVzIHRvIGFzc2lnbiB0byB0aGUgb3V0cHV0IG5vZGVzIG9mIHRoZSBncmFwaCBpbiBvcmRlci4gSWYgTm9uZSwgdGhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMgd2lsbCBiZSByZWFkIGZyb20gdGhlIGhhbmRsZXIncyBvdXRwdXRzLiBJZiBpdHMgYWxzbyBOb25lLCBpdCBpcyBkZWZhdWx0ZWQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICJvdXRwdXRfMCIgKGZvciBtdWx0aXBsZSBvdXRwdXRzLCB0aGlzIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkKS4KICAgICAgICA6cGFyYW0gZHluYW1pY19heGVzOiAgICAgICAgSWYgcGFydCBvZiB0aGUgaW5wdXQgLyBvdXRwdXQgc2hhcGUgaXMgZHluYW1pYywgbGlrZSAoYmF0Y2hfc2l6ZSwgMywgMzIsIDMyKSB5b3UgY2FuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZnkgaXQgYnkgZ2l2aW5nIGEgZHluYW1pYyBheGlzIHRvIHRoZSBpbnB1dCAvIG91dHB1dCBsYXllciBieSBpdHMgbmFtZSBhcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW5wdXQgbGF5ZXIgbmFtZSI6IHswOiAiYmF0Y2hfc2l6ZSJ9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm91dHB1dCBsYXllciBuYW1lIjogezA6ICJiYXRjaF9zaXplIn0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgcHJvdmlkZWQsIHRoZSAnaXNfYmF0Y2hlZCcgZmxhZyB3aWxsIGJlIGlnbm9yZWQuIERlZmF1bHRlZCB0byBOb25lLgogICAgICAgIDpwYXJhbSBpc19iYXRjaGVkOiAgICAgICAgICBXaGV0aGVyIHRvIGluY2x1ZGUgYSBiYXRjaCBzaXplIGFzIHRoZSBmaXJzdCBheGlzIGluIGV2ZXJ5IGlucHV0IGFuZCBvdXRwdXQgbGF5ZXIuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRlZCB0byBUcnVlLiBXaWxsIGJlIGlnbm9yZWQgaWYgJ2R5bmFtaWNfYXhlcycgaXMgcHJvdmlkZWQuCiAgICAgICAgIiIiCiAgICAgICAgIyBJbXBvcnQgdGhlIGZyYW1ld29yayBhbmQgaGFuZGxlcjoKICAgICAgICBpbXBvcnQgdG9yY2gKCiAgICAgICAgIyBQYXJzZSB0aGUgJ2lucHV0X3NpZ25hdHVyZScgcGFyYW1ldGVyOgogICAgICAgIGlmIGlucHV0X3NpZ25hdHVyZSBpcyBub3QgTm9uZToKICAgICAgICAgICAgaW5wdXRfc2lnbmF0dXJlID0gdHVwbGUoCiAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgdG9yY2guemVyb3MoCiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9c2hhcGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGR0eXBlPW1vZGVsX2hhbmRsZXIuY29udmVydF92YWx1ZV90eXBlX3RvX3RvcmNoX2R0eXBlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfdHlwZT12YWx1ZV90eXBlCiAgICAgICAgICAgICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIGZvciAoc2hhcGUsIHZhbHVlX3R5cGUpIGluIGlucHV0X3NpZ25hdHVyZQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICApCgogICAgICAgICMgQ29udmVydCB0byBPTk5YOgogICAgICAgIG1vZGVsX2hhbmRsZXIudG9fb25ueCgKICAgICAgICAgICAgbW9kZWxfbmFtZT1vbm54X21vZGVsX25hbWUsCiAgICAgICAgICAgIGlucHV0X3NhbXBsZT1pbnB1dF9zaWduYXR1cmUsCiAgICAgICAgICAgIG9wdGltaXplPW9wdGltaXplX21vZGVsLAogICAgICAgICAgICBpbnB1dF9sYXllcnNfbmFtZXM9aW5wdXRfbGF5ZXJzX25hbWVzLAogICAgICAgICAgICBvdXRwdXRfbGF5ZXJzX25hbWVzPW91dHB1dF9sYXllcnNfbmFtZXMsCiAgICAgICAgICAgIGR5bmFtaWNfYXhlcz1keW5hbWljX2F4ZXMsCiAgICAgICAgICAgIGlzX2JhdGNoZWQ9aXNfYmF0Y2hlZAogICAgICAgICkKCgojIE1hcCBmb3IgZ2V0dGluZyB0aGUgY29udmVyc2lvbiBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGZyYW1ld29yazoKX0NPTlZFUlNJT05fTUFQID0gewogICAgInRmLmtlcmFzIjogX1RvT05OWENvbnZlcnNpb25zLnRmX2tlcmFzX3RvX29ubngsCiAgICAicHl0b3JjaCI6IF9Ub09OTlhDb252ZXJzaW9ucy5weXRvcmNoX3RvX29ubngsCn0gICMgdHlwZTogRGljdFtzdHIsIENhbGxhYmxlXQoKCmRlZiB0b19vbm54KAogICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHgsCiAgICBtb2RlbF9wYXRoOiBzdHIsCiAgICBvbm54X21vZGVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICBvcHRpbWl6ZV9tb2RlbDogYm9vbCA9IFRydWUsCiAgICBmcmFtZXdvcmtfa3dhcmdzOiBEaWN0W3N0ciwgQW55XSA9IE5vbmUsCik6CiAgICAiIiIKICAgIENvbnZlcnQgdGhlIGdpdmVuIG1vZGVsIHRvIGFuIE9OTlggbW9kZWwuCgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgIFRoZSBNTFJ1biBmdW5jdGlvbiBleGVjdXRpb24gY29udGV4dAogICAgOnBhcmFtIG1vZGVsX3BhdGg6ICAgICAgIFRoZSBtb2RlbCBwYXRoIHN0b3JlIG9iamVjdC4KICAgIDpwYXJhbSBvbm54X21vZGVsX25hbWU6ICBUaGUgbmFtZSB0byB1c2UgdG8gbG9nIHRoZSBjb252ZXJ0ZWQgT05OWCBtb2RlbC4gSWYgbm90IGdpdmVuLCB0aGUgZ2l2ZW4gYG1vZGVsX25hbWVgIHdpbGwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkIHdpdGggYW4gYWRkaXRpb25hbCBzdWZmaXggYF9vbm54YC4gRGVmYXVsdGVkIHRvIE5vbmUuCiAgICA6cGFyYW0gb3B0aW1pemVfbW9kZWw6ICAgV2hldGhlciB0byBvcHRpbWl6ZSB0aGUgT05OWCBtb2RlbCB1c2luZyAnb25ueG9wdGltaXplcicgYmVmb3JlIHNhdmluZyB0aGUgbW9kZWwuIERlZmF1bHRlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIFRydWUuCiAgICA6cGFyYW0gZnJhbWV3b3JrX2t3YXJnczogQWRkaXRpb25hbCBhcmd1bWVudHMgZWFjaCBmcmFtZXdvcmsgbWF5IHJlcXVpcmUgaW4gb3JkZXIgdG8gY29udmVydCB0byBPTk5YLiBUbyBnZXQgdGhlIGRvYwogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBvZiB0aGUgZGVzaXJlZCBmcmFtZXdvcmsgb25ueCBjb252ZXJzaW9uIGZ1bmN0aW9uLCBwYXNzICJoZWxwIi4KICAgICIiIgogICAgZnJvbSBtbHJ1bi5mcmFtZXdvcmtzLmF1dG9fbWxydW4uYXV0b19tbHJ1biBpbXBvcnQgQXV0b01MUnVuCgogICAgIyBHZXQgYSBtb2RlbCBoYW5kbGVyIG9mIHRoZSByZXF1aXJlZCBmcmFtZXdvcms6CiAgICBtb2RlbF9oYW5kbGVyID0gQXV0b01MUnVuLmxvYWRfbW9kZWwobW9kZWxfcGF0aD1tb2RlbF9wYXRoLCBjb250ZXh0PWNvbnRleHQpCgogICAgIyBHZXQgdGhlIG1vZGVsJ3MgZnJhbWV3b3JrOgogICAgZnJhbWV3b3JrID0gbW9kZWxfaGFuZGxlci5GUkFNRVdPUktfTkFNRQoKICAgICMgVXNlIHRoZSBjb252ZXJzaW9uIG1hcCB0byBnZXQgdGhlIHNwZWNpZmljIGZyYW1ld29yayB0byBvbm54IGNvbnZlcnNpb246CiAgICBpZiBmcmFtZXdvcmsgbm90IGluIF9DT05WRVJTSU9OX01BUDoKICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5JbnZhbGlkQXJndW1lbnRFcnJvcigKICAgICAgICAgICAgZiJUaGUgZm9sbG93aW5nIGZyYW1ld29yazogJ3tmcmFtZXdvcmt9JywgaGFzIG5vIE9OTlggY29udmVyc2lvbi4iCiAgICAgICAgKQogICAgY29udmVyc2lvbl9mdW5jdGlvbiA9IF9DT05WRVJTSU9OX01BUFtmcmFtZXdvcmtdCgogICAgIyBDaGVjayBpZiBuZWVkZWQgdG8gcHJpbnQgdGhlIGZ1bmN0aW9uJ3MgZG9jIHN0cmluZyAoImhlbHAiIGlzIHBhc3NlZCk6CiAgICBpZiBmcmFtZXdvcmtfa3dhcmdzID09ICJoZWxwIjoKICAgICAgICBwcmludChjb252ZXJzaW9uX2Z1bmN0aW9uLl9fZG9jX18pCiAgICAgICAgcmV0dXJuCgogICAgIyBTZXQgdGhlIGRlZmF1bHQgZW1wdHkgZnJhbWV3b3JrIGt3YXJncyBpZiBuZWVkZWQ6CiAgICBpZiBmcmFtZXdvcmtfa3dhcmdzIGlzIE5vbmU6CiAgICAgICAgZnJhbWV3b3JrX2t3YXJncyA9IHt9CgogICAgIyBSdW4gdGhlIGNvbnZlcnNpb246CiAgICB0cnk6CiAgICAgICAgY29udmVyc2lvbl9mdW5jdGlvbigKICAgICAgICAgICAgbW9kZWxfaGFuZGxlcj1tb2RlbF9oYW5kbGVyLAogICAgICAgICAgICBvbm54X21vZGVsX25hbWU9b25ueF9tb2RlbF9uYW1lLAogICAgICAgICAgICBvcHRpbWl6ZV9tb2RlbD1vcHRpbWl6ZV9tb2RlbCwKICAgICAgICAgICAgKipmcmFtZXdvcmtfa3dhcmdzLAogICAgICAgICkKICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZXhjZXB0aW9uOgogICAgICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1bkludmFsaWRBcmd1bWVudEVycm9yKAogICAgICAgICAgICBmIkVSUk9SOiBBIFR5cGVFcnJvciBleGNlcHRpb24gd2FzIHJhaXNlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb246XG57ZXhjZXB0aW9ufS4gIgogICAgICAgICAgICBmIlBsZWFzZSByZWFkIHRoZSB7ZnJhbWV3b3JrfSBmcmFtZXdvcmsgY29udmVyc2lvbiBmdW5jdGlvbiBkb2Mgc3RyaW5nIGJ5IHBhc3NpbmcgJ2hlbHAnIGluIHRoZSAiCiAgICAgICAgICAgIGYiJ2ZyYW1ld29ya19rd2FyZ3MnIGRpY3Rpb25hcnkgcGFyYW1ldGVyLiIKICAgICAgICApCgoKZGVmIG9wdGltaXplKAogICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHgsCiAgICBtb2RlbF9wYXRoOiBzdHIsCiAgICBvcHRpbWl6YXRpb25zOiBMaXN0W3N0cl0gPSBOb25lLAogICAgZml4ZWRfcG9pbnQ6IGJvb2wgPSBGYWxzZSwKICAgIG9wdGltaXplZF9tb2RlbF9uYW1lOiBzdHIgPSBOb25lLAopOgogICAgIiIiCiAgICBPcHRpbWl6ZSB0aGUgZ2l2ZW4gT05OWCBtb2RlbC4KCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICAgIFRoZSBNTFJ1biBmdW5jdGlvbiBleGVjdXRpb24gY29udGV4dC4KICAgIDpwYXJhbSBtb2RlbF9wYXRoOiAgICAgICAgICAgUGF0aCB0byB0aGUgT05OWCBtb2RlbCBvYmplY3QuCiAgICA6cGFyYW0gb3B0aW1pemF0aW9uczogICAgICAgIExpc3Qgb2YgcG9zc2libGUgb3B0aW1pemF0aW9ucy4gVG8gc2VlIHdoYXQgb3B0aW1pemF0aW9ucyBhcmUgYXZhaWxhYmxlLCBwYXNzICJoZWxwIi4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgTm9uZSwgYWxsIG9mIHRoZSBvcHRpbWl6YXRpb25zIHdpbGwgYmUgdXNlZC4gRGVmYXVsdGVkIHRvIE5vbmUuCiAgICA6cGFyYW0gZml4ZWRfcG9pbnQ6ICAgICAgICAgIE9wdGltaXplIHRoZSB3ZWlnaHRzIHVzaW5nIGZpeGVkIHBvaW50LiBEZWZhdWx0ZWQgdG8gRmFsc2UuCiAgICA6cGFyYW0gb3B0aW1pemVkX21vZGVsX25hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcHRpbWl6ZWQgbW9kZWwuIElmIE5vbmUsIHRoZSBvcmlnaW5hbCBtb2RlbCB3aWxsIGJlIG92ZXJyaWRkZW4uCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRlZCB0byBOb25lLgogICAgIiIiCiAgICAjIEltcG9ydCB0aGUgbW9kZWwgaGFuZGxlcjoKICAgIGltcG9ydCBvbm54b3B0aW1pemVyCiAgICBmcm9tIG1scnVuLmZyYW1ld29ya3Mub25ueCBpbXBvcnQgT05OWE1vZGVsSGFuZGxlcgoKICAgICMgQ2hlY2sgaWYgbmVlZGVkIHRvIHByaW50IHRoZSBhdmFpbGFibGUgb3B0aW1pemF0aW9ucyAoImhlbHAiIGlzIHBhc3NlZCk6CiAgICBpZiBvcHRpbWl6YXRpb25zID09ICJoZWxwIjoKICAgICAgICBhdmFpbGFibGVfcGFzc2VzID0gIlxuKiAiLmpvaW4ob25ueG9wdGltaXplci5nZXRfYXZhaWxhYmxlX3Bhc3NlcygpKQogICAgICAgIHByaW50KGYiVGhlIGF2YWlsYWJsZSBvcHRpbWl6YXRpb25zIGFyZTpcbioge2F2YWlsYWJsZV9wYXNzZXN9IikKICAgICAgICByZXR1cm4KCiAgICAjIENyZWF0ZSB0aGUgbW9kZWwgaGFuZGxlcjoKICAgIG1vZGVsX2hhbmRsZXIgPSBPTk5YTW9kZWxIYW5kbGVyKAogICAgICAgIG1vZGVsX3BhdGg9bW9kZWxfcGF0aCwgY29udGV4dD1jb250ZXh0CiAgICApCgogICAgIyBMb2FkIHRoZSBPTk5YIG1vZGVsOgogICAgbW9kZWxfaGFuZGxlci5sb2FkKCkKCiAgICAjIE9wdGltaXplIHRoZSBtb2RlbCB1c2luZyB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbnM6CiAgICBtb2RlbF9oYW5kbGVyLm9wdGltaXplKG9wdGltaXphdGlvbnM9b3B0aW1pemF0aW9ucywgZml4ZWRfcG9pbnQ9Zml4ZWRfcG9pbnQpCgogICAgIyBSZW5hbWUgaWYgbmVlZGVkOgogICAgaWYgb3B0aW1pemVkX21vZGVsX25hbWUgaXMgbm90IE5vbmU6CiAgICAgICAgbW9kZWxfaGFuZGxlci5zZXRfbW9kZWxfbmFtZShtb2RlbF9uYW1lPW9wdGltaXplZF9tb2RlbF9uYW1lKQoKICAgICMgTG9nIHRoZSBvcHRpbWl6ZWQgbW9kZWw6CiAgICBtb2RlbF9oYW5kbGVyLmxvZygpCg==
    commands: []
    code_origin: https://github.com/guy1992l/functions.git#ad5a30b35d5ba757940d3e42d726405e58587fde:/Users/guyl/Projects/functions/onnx_utils/onnx_utils.py
    origin_filename: /Users/guyl/Projects/functions/onnx_utils/onnx_utils.py
  disable_auto_mount: false
  priority_class_name: ''
  affinity: null
verbose: false
