kind: job
metadata:
  name: xgb-trainer
  tag: latest
  hash: bae1cb2ceca681eede2bce98bc9892952b3b7be3
  project: ''
  labels:
    author: yjb
  categories:
  - models
  - classifier
spec:
  command: ''
  args: []
  image: mlrun/ml-models:0.4.6
  env: []
  default_handler: train_model
  entry_points:
    gen_xgb_model:
      name: gen_xgb_model
      doc: 'generate an xgboost model


        Multiple model types that can be estimated using

        the XGBoost Scikit-Learn API'
      parameters:
      - name: model_type
        type: str
        doc: one of 'classifier', 'regressor', 'ranker', 'rf_classifier', or 'rf_regressor'
      - name: xgb_params
        type: dict
        doc: parameters passed through the  function execution context
      outputs: []
      lineno: 6
    get_sample:
      name: get_sample
      doc: "generate data sample to be split (candidate for mlrun)\n \nReturns features\
        \ matrix and header (x), and labels (y)"
      parameters:
      - name: src
        type: str
        doc: full path and filename of data artifact
      - name: sample
        type: int
        doc: sample size from data source, use negative  integers to sample randomly,
          positive to sample consecutively from the first row
      - name: label
        type: str
        doc: label column title
      - name: reader
        doc: pandas type reader (read_csv, read_parquet, ...) returning a pandas dataframe,
          and with a `dropna` attribute
      outputs: []
      lineno: 49
    get_splits:
      name: get_splits
      doc: 'generate train and test sets (candidate for mlrun)


        cross validation:

        1. cut out a test set

        2a. use the training set in a cross validation scheme, or

        2b. make another split to generate a validation set'
      parameters:
      - name: raw
        doc: dataframe or numpy array of raw features
      - name: labels
        doc: label names
      - name: three_way
        type: bool
        default: true
      - name: test_size
        type: float
        doc: proportion of raw data to set asid as test data
        default: 0.15
      - name: valid_size
        type: float
        doc: proportion of remaining data to be set as validation
        default: 0.3
      - name: label_names
        type: list
        default:
        - labels
      - name: random_state
        type: int
        doc: (1) random number seed
        default: 1
      outputs: []
      lineno: 86
    save_test_set:
      name: save_test_set
      doc: save a held out test set
      parameters:
      - name: context
        doc: the function execution context
      - name: xtest
        doc: test features, as np.ndarray output from `get_splits`
      - name: ytest
        doc: test labels, as np.ndarray output from `get_splits`
      - name: header
        type: list
        doc: ([])features header if required
      - name: label
        type: str
        doc: ("labels") name of label column
        default: labels
      - name: file_ext
        type: str
        doc: format of test set file
        default: parquet
      - name: index
        type: bool
        doc: preserve index column
      outputs: []
      lineno: 136
    dump_xgb_model:
      name: dump_xgb_model
      doc: 'serialize/log model


        XGBoost model can be save in 3 different ways:

        1. pickle the internal _booster object, inside the model

        2. using model.save_model(''fn.bin'') using a legacy binary xgb format

        2. using model.save_model(''fn.json'') using a portable json format'
      parameters:
      - name: context
        doc: the function's execution context
      - name: model
        doc: the fitted xgboost model
      - name: dump_type
        type: str
        doc: '''pickle'' legacy'', or ''json'', '
      - name: dest_folder
        type: str
        doc: 'path for serialized model '
      - name: dest_name
        type: str
        doc: name for serialized model file
      outputs: []
      lineno: 164
    gen_proba:
      name: gen_proba
      doc: generate predictions and validation stats
      parameters:
      - name: context
        doc: the function execution context
      - name: feats
        doc: 'validation features array '
      - name: labels
        doc: validation ground-truth labels
      - name: model
        doc: estimated model
      - name: score_method
      - name: plots_dest
        doc: destination folder for plot artifacts
      - name: ntree_limit
        doc: (None) limit no. trees used in prediction
      - name: validate_features
        doc: (True) ensure consistent feature names  between model and input data
        default: true
      - name: base_margin
        doc: (None) undefined
      outputs: []
      lineno: 198
    plot_roc:
      name: plot_roc
      doc: "plot roc curves\n\nTODO:  add averaging method (as string) that was used\
        \ to create probs, \ndisplay in legend"
      parameters:
      - name: context
        doc: the function context
      - name: y_labels
        doc: 'ground truth labels, hot encoded for multiclass  '
      - name: y_probs
        doc: model prediction probabilities
      - name: fpr_label
        type: str
        doc: ("false positive rate") x-axis labels
        default: false positive rate
      - name: tpr_label
        type: str
        doc: ("true positive rate") y-axis labels
        default: true positive rate
      - name: title
        type: str
        doc: ("roc curve") title of plot
        default: roc curve
      - name: legend_loc
        type: str
        doc: ("best") location of plot legend
        default: best
      outputs: []
      lineno: 247
    train_model:
      name: train_model
      doc: train an xgboost model.
      parameters:
      - name: context
        doc: the function context
      - name: model_type
        type: str
      - name: dataset
        doc: ("data") name of raw data file
      - name: label_column
        type: str
        doc: ground-truth (y) labels
        default: labels
      - name: sample
        type: int
        doc: Selects the first n rows, or select a sample starting from the first.
          If negative <-1, select a random sample
        default: <_ast.USub object at 0x7f190c0f3d68>
      - name: test_size
        type: float
        doc: (0.05) test set size
        default: 0.05
      - name: valid_size
        type: float
        doc: (0.75) Once the test set has been removed the training set gets this
          proportion.
        default: 0.75
      - name: random_state
        type: int
        doc: (1) sklearn rng seed
        default: 1
      - name: model_filename
        type: str
        doc: model file filename, points to a directory
        default: model
      - name: models_dest
        type: str
        doc: models subfolder on artifact path
      - name: plots_dest
        type: str
        doc: plot subfolder on artifact path
      - name: score_method
        type: str
        doc: for multiclass classification
        default: micro
      - name: file_ext
        type: str
        doc: format for test_set_key hold out data
        default: parquet
      - name: model_pkg_file
        type: str
        doc: json model config file
      outputs: []
      lineno: 301
  description: train any classifier using scikit-learn's API
  build:
    functionSourceCode: IyBHZW5lcmF0ZWQgYnkgbnVjbGlvLmV4cG9ydC5OdWNsaW9FeHBvcnRlciBvbiAyMDIwLTA0LTI3IDE4OjMwCgppbXBvcnQgd2FybmluZ3MKd2FybmluZ3Muc2ltcGxlZmlsdGVyKGFjdGlvbj0iaWdub3JlIiwgY2F0ZWdvcnk9RnV0dXJlV2FybmluZykKCmRlZiBnZW5feGdiX21vZGVsKG1vZGVsX3R5cGU6IHN0ciwgeGdiX3BhcmFtczogZGljdCk6CiAgICAiIiJnZW5lcmF0ZSBhbiB4Z2Jvb3N0IG1vZGVsCiAgICAKICAgIE11bHRpcGxlIG1vZGVsIHR5cGVzIHRoYXQgY2FuIGJlIGVzdGltYXRlZCB1c2luZwogICAgdGhlIFhHQm9vc3QgU2Npa2l0LUxlYXJuIEFQSQogICAgCiAgICA6cGFyYW0gbW9kZWxfdHlwZTogb25lIG9mICdjbGFzc2lmaWVyJywgJ3JlZ3Jlc3NvcicsCiAgICAgICAgICAgICAgICAgICAgICAgJ3JhbmtlcicsICdyZl9jbGFzc2lmaWVyJywgb3IKICAgICAgICAgICAgICAgICAgICAgICdyZl9yZWdyZXNzb3InCiAgICA6cGFyYW0geGdiX3BhcmFtczogcGFyYW1ldGVycyBwYXNzZWQgdGhyb3VnaCB0aGUgCiAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0aW9uIGNvbnRleHQKICAgICIiIgogICAgZnJvbSBqc29uIGltcG9ydCBsb2FkCiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdldF9jbGFzc19maXQsIGNyZWF0ZV9jbGFzcwoKICAgIGlmIG1vZGVsX3R5cGUgPT0gImNsYXNzaWZpZXIiOgogICAgICAgIG1vZGVsX2NvbmZpZyA9IGdldF9jbGFzc19maXQoInhnYm9vc3QuWEdCQ2xhc3NpZmllciIpCiAgICBlbGlmIG1vZGVsX3R5cGUgPT0gInJlZ3Jlc3NvciI6CiAgICAgICAgbW9kZWxfY29uZmlnID0gZ2V0X2NsYXNzX2ZpdCgieGdib29zdC5YR0JSZWdyZXNzb3IiKQogICAgZWxpZiBtb2RlbF90eXBlID09ICJyYW5rZXIiOgogICAgICAgIG1vZGVsX2NvbmZpZyA9IGdldF9jbGFzc19maXQoInhnYm9vc3QuWEdCQ2xhc3NpZmllciIpCiAgICBlbGlmIG1vZGVsX3R5cGUgPT0gInJmX3JlZ3Jlc3NvciI6CiAgICAgICAgbW9kZWxfY29uZmlnID0gZ2V0X2NsYXNzX2ZpdCgieGdib29zdC5YR0JSRlJlZ3Jlc3NvciIpCiAgICBlbGlmIG1vZGVsX3R5cGUgPT0gInJmX2NsYXNzaWZpZXIiOgogICAgICAgIG1vZGVsX2NvbmZpZyA9IGdldF9jbGFzc19maXQoInhnYm9vc3QuWEdCUkZDbGFzc2lmaWVyIikKICAgIGVsc2U6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmJ3Vua25vd24gdHJhaW5lciB0eXBlIHttb2RlbF90eXBlfScpCgogICAgZm9yIGssIHYgaW4geGdiX3BhcmFtczoKICAgICAgICBpZiBrLnN0YXJ0c3dpdGgoJ0NMQVNTXycpOgogICAgICAgICAgICBtb2RlbF9jb25maWdbJ0NMQVNTJ11ba1s2Ol1dID0gdgogICAgICAgIGlmIGsuc3RhcnRzd2l0aCgnRklUXycpOgogICAgICAgICAgICBtb2RlbF9jb25maWdbJ0ZJVCddW2tbNDpdXSA9IHYKCiAgICBDbGFzc2lmaWVyQ2xhc3MgPSBjcmVhdGVfY2xhc3MobW9kZWxfY29uZmlnWyJNRVRBIl1bImNsYXNzIl0pCiAgICBtb2RlbCA9IENsYXNzaWZpZXJDbGFzcygqKm1vZGVsX2NvbmZpZ1siQ0xBU1MiXSkKCiAgICByZXR1cm4gbW9kZWwsIG1vZGVsX2NvbmZpZwoKaW1wb3J0IHhnYm9vc3QKYywgaiA9IGdlbl94Z2JfbW9kZWwoJ3JmX2NsYXNzaWZpZXInLCB7fSkKYXNzZXJ0IGlzaW5zdGFuY2UoYywgeGdib29zdC5YR0JSRkNsYXNzaWZpZXIpCgpkZWYgZ2V0X3NhbXBsZShzcmM6c3RyLCBzYW1wbGU6IGludCwgbGFiZWw6IHN0ciwgcmVhZGVyPU5vbmUpOgogICAgIiIiZ2VuZXJhdGUgZGF0YSBzYW1wbGUgdG8gYmUgc3BsaXQgKGNhbmRpZGF0ZSBmb3IgbWxydW4pCiAgICAgCiAgICBSZXR1cm5zIGZlYXR1cmVzIG1hdHJpeCBhbmQgaGVhZGVyICh4KSwgYW5kIGxhYmVscyAoeSkKICAgIDpwYXJhbSBzcmM6ICAgIGZ1bGwgcGF0aCBhbmQgZmlsZW5hbWUgb2YgZGF0YSBhcnRpZmFjdAogICAgOnBhcmFtIHNhbXBsZTogc2FtcGxlIHNpemUgZnJvbSBkYXRhIHNvdXJjZSwgdXNlIG5lZ2F0aXZlIAogICAgICAgICAgICAgICAgICAgaW50ZWdlcnMgdG8gc2FtcGxlIHJhbmRvbWx5LCBwb3NpdGl2ZSB0bwogICAgICAgICAgICAgICAgICAgc2FtcGxlIGNvbnNlY3V0aXZlbHkgZnJvbSB0aGUgZmlyc3Qgcm93CiAgICA6cGFyYW0gbGFiZWw6ICBsYWJlbCBjb2x1bW4gdGl0bGUKICAgIDpwYXJhbSByZWFkZXI6IHBhbmRhcyB0eXBlIHJlYWRlciAocmVhZF9jc3YsIHJlYWRfcGFycXVldCwgLi4uKSByZXR1cm5pbmcKICAgICAgICAgICAgICAgICAgIGEgcGFuZGFzIGRhdGFmcmFtZSwgYW5kIHdpdGggYSBgZHJvcG5hYCBhdHRyaWJ1dGUKICAgICIiIgogICAgaW1wb3J0IHBhbmRhcyBhcyBwZAogICAgCiAgICBpZiBub3QgcmVhZGVyOgogICAgICAgIGlmIHNyYy5lbmRzd2l0aCgiY3N2Iik6CiAgICAgICAgICAgIHJlYWRlciA9IHBkLnJlYWRfY3N2CiAgICAgICAgZWxpZiBzcmMuZW5kc3dpdGgoInBhcnF1ZXQiKSBvciBzcmMuZW5kc3dpdGgoInBxIik6CiAgICAgICAgICAgIHJlYWRlciA9IHBkLnJlYWRfcGFycXVldAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJhaXNlIEV4Y2VwdGlvbihmImZpbGUgdHlwZSB1bmhhbmRsZWQge3NyY30iKQoKICAgIGlmIChzYW1wbGUgPT0gLTEpIG9yIChzYW1wbGUgPj0gMSk6CiAgICAgICAgcmF3ID0gcmVhZGVyKHNyYykuZHJvcG5hKCkKICAgICAgICBsYWJlbHMgPSByYXcucG9wKGxhYmVsKQogICAgICAgIHJhdyA9IHJhdy5pbG9jWzpzYW1wbGUsIDpdCiAgICAgICAgbGFiZWxzID0gbGFiZWxzLmlsb2NbOnNhbXBsZV0KICAgIGVsc2U6CiAgICAgICAgcmF3ID0gcmVhZGVyKHNyYykuZHJvcG5hKCkuc2FtcGxlKHNhbXBsZSAqIC0xKQogICAgICAgIGxhYmVscyA9IHJhdy5wb3AobGFiZWwpCgogICAgcmV0dXJuIHJhdywgbGFiZWxzLCByYXcuY29sdW1ucy52YWx1ZXMKCnIsIGwsIGggPSBnZXRfc2FtcGxlKCcvVXNlci9hcnRpZmFjdHMvaXJpcy5wYXJxdWV0JywgLTEsICJsYWJlbHMiKQphc3NlcnQgci5zaGFwZVswXT09bC5zaGFwZVswXQpwcmludChoKQoKZGVmIGdldF9zcGxpdHMoCiAgICByYXcsIAogICAgbGFiZWxzLCAKICAgIHRocmVlX3dheTogYm9vbCA9IFRydWUsCiAgICB0ZXN0X3NpemU6IGZsb2F0ID0gMC4xNSwKICAgIHZhbGlkX3NpemU6IGZsb2F0ID0gMC4zMCwKICAgIGxhYmVsX25hbWVzOiBsaXN0ID0gWyJsYWJlbHMiXSwKICAgIHJhbmRvbV9zdGF0ZTogaW50ID0gMQopOgogICAgIiIiZ2VuZXJhdGUgdHJhaW4gYW5kIHRlc3Qgc2V0cyAoY2FuZGlkYXRlIGZvciBtbHJ1bikKCiAgICBjcm9zcyB2YWxpZGF0aW9uOgogICAgMS4gY3V0IG91dCBhIHRlc3Qgc2V0CiAgICAyYS4gdXNlIHRoZSB0cmFpbmluZyBzZXQgaW4gYSBjcm9zcyB2YWxpZGF0aW9uIHNjaGVtZSwgb3IKICAgIDJiLiBtYWtlIGFub3RoZXIgc3BsaXQgdG8gZ2VuZXJhdGUgYSB2YWxpZGF0aW9uIHNldAogICAgCiAgICA6cGFyYW0gcmF3OiAgICAgICAgICAgIGRhdGFmcmFtZSBvciBudW1weSBhcnJheSBvZiByYXcgZmVhdHVyZXMKICAgIDpwYXJhbSBsYWJlbHM6ICAgICAgICAgZGF0YWZyYW1lIG9yIG51bXB5IGFycmF5IG9mIHJhdyBsYWJlbHMKICAgIDpwYXJhbSB0ZXN0X3NpemU6ICAgICAgcHJvcG9ydGlvbiBvZiByYXcgZGF0YSB0byBzZXQgYXNpZCBhcyB0ZXN0IGRhdGEKICAgIDpwYXJhbSB2YWxpZF9zaXplOiAgICAgcHJvcG9ydGlvbiBvZiByZW1haW5pbmcgZGF0YSB0byBiZSBzZXQgYXMgdmFsaWRhdGlvbgogICAgOnBhcmFtIGxhYmVsczogICAgICAgICBsYWJlbCBuYW1lcwogICAgOnBhcmFtIHJhbmRvbV9zdGF0ZTogICAoMSkgcmFuZG9tIG51bWJlciBzZWVkCiAgICAiIiIKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIGltcG9ydCBudW1weSBhcyBucAogICAgZnJvbSBza2xlYXJuLm1vZGVsX3NlbGVjdGlvbiBpbXBvcnQgdHJhaW5fdGVzdF9zcGxpdAogICAgCiAgICBpZiBpc2luc3RhbmNlKHJhdywgbnAubmRhcnJheSk6CiAgICAgICAgaWYgbGFiZWxzLm5kaW09PTE6CiAgICAgICAgICAgIGxhYmVscz1sYWJlbHMucmVzaGFwZSgtMSwxKQogICAgICAgIHh5ID0gbnAuY29uY2F0ZW5hdGUoW3JhdywgbGFiZWxzXSwgYXhpcz0xKQogICAgZWxzZToKICAgICAgICBpZiBpc2luc3RhbmNlKGxhYmVscywgcGQuU2VyaWVzKToKICAgICAgICAgICAgbGFiZWxzID0gcGQuRGF0YUZyYW1lKGRhdGE9bGFiZWxzLCBjb2x1bW5zPWxhYmVsX25hbWVzKQogICAgICAgIHh5ID0gcGQuY29uY2F0KFtyYXcsIGxhYmVsc10sIGF4aXM9MSkKICAgICAgICAKICAgIHgsIHh0ZSwgeSwgeXRlID0gdHJhaW5fdGVzdF9zcGxpdCh4eSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMsIHRlc3Rfc2l6ZT10ZXN0X3NpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZG9tX3N0YXRlPXJhbmRvbV9zdGF0ZSkKICAgIGlmIG5vdCB0aHJlZV93YXk6CiAgICAgICAgcmV0dXJuICh4dHIsIHl0ciksICh4dGUsIHl0ZSksIE5vbmUKICAgIGVsc2U6CiAgICAgICAgeHRyLCB4dmEsIHl0ciwgeXZhID0gdHJhaW5fdGVzdF9zcGxpdCh4LCB5LHRyYWluX3NpemU9dmFsaWRfc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbV9zdGF0ZT1yYW5kb21fc3RhdGUpCiAgICAgICAgcmV0dXJuICh4dHIsIHl0ciksICh4dmEsIHl2YSksICh4dGUsIHl0ZSkKCih4dHIsIHl0ciksICh4dmEsIHl2YSksICh4dGUsIHl0ZSkgPSBnZXRfc3BsaXRzKHIsbCkKYXNzZXJ0IHh0ci5zaGFwZVswXSt4dmEuc2hhcGVbMF0reHRlLnNoYXBlWzBdID09IHIuc2hhcGVbMF0KeXRyLnNoYXBlCgpkZWYgc2F2ZV90ZXN0X3NldCgKICAgIGNvbnRleHQsIAogICAgeHRlc3QsIAogICAgeXRlc3QsIAogICAgaGVhZGVyOiBsaXN0LCAKICAgIGxhYmVsOiBzdHIgPSAibGFiZWxzIiwgCiAgICBmaWxlX2V4dDogc3RyID0gInBhcnF1ZXQiLCAKICAgIGluZGV4OiBib29sID0gRmFsc2UgCik6CiAgICAiIiJzYXZlIGEgaGVsZCBvdXQgdGVzdCBzZXQKCiAgICA6cGFyYW0gY29udGV4dDogICAgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0geHRlc3Q6ICAgICAgdGVzdCBmZWF0dXJlcywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSB5dGVzdDogICAgICB0ZXN0IGxhYmVscywgYXMgbnAubmRhcnJheSBvdXRwdXQgZnJvbSBgZ2V0X3NwbGl0c2AKICAgIDpwYXJhbSBoZWFkZXI6ICAgICAoW10pZmVhdHVyZXMgaGVhZGVyIGlmIHJlcXVpcmVkCiAgICA6cGFyYW0gbGFiZWw6ICAgICAgKCJsYWJlbHMiKSBuYW1lIG9mIGxhYmVsIGNvbHVtbgogICAgOnBhcmFtIGZpbGVfZXh0OiAgIGZvcm1hdCBvZiB0ZXN0IHNldCBmaWxlCiAgICA6cGFyYW0gaW5kZXg6ICAgICAgcHJlc2VydmUgaW5kZXggY29sdW1uCiAgICAiIiIKICAgIGltcG9ydCBwYW5kYXMgYXMgcGQKICAgIAogICAgdGVzdF9zZXQgPSBwZC5jb25jYXQoCiAgICAgICAgW3BkLkRhdGFGcmFtZShkYXRhPXh0ZXN0LCBjb2x1bW5zPWhlYWRlciksCiAgICAgICAgIHBkLkRhdGFGcmFtZShkYXRhPXl0ZXN0LnZhbHVlcywgY29sdW1ucz1bbGFiZWxdKV0sCiAgICAgICAgYXhpcz0xLCkKICAgIAogICAgY29udGV4dC5sb2dfZGF0YXNldCgndGVzdF9zZXQnLCBkZj10ZXN0X3NldCwgZm9ybWF0PWZpbGVfZXh0LCBpbmRleD1GYWxzZSkKCmRlZiBkdW1wX3hnYl9tb2RlbCgKICAgIGNvbnRleHQsIAogICAgbW9kZWwsCiAgICBkdW1wX3R5cGU6IHN0ciwKICAgIGRlc3RfZm9sZGVyOiBzdHIsCiAgICBkZXN0X25hbWU6IHN0cgopOgogICAgIiIic2VyaWFsaXplL2xvZyBtb2RlbAogICAgCiAgICBYR0Jvb3N0IG1vZGVsIGNhbiBiZSBzYXZlIGluIDMgZGlmZmVyZW50IHdheXM6CiAgICAxLiBwaWNrbGUgdGhlIGludGVybmFsIF9ib29zdGVyIG9iamVjdCwgaW5zaWRlIHRoZSBtb2RlbAogICAgMi4gdXNpbmcgbW9kZWwuc2F2ZV9tb2RlbCgnZm4uYmluJykgdXNpbmcgYSBsZWdhY3kgYmluYXJ5IHhnYiBmb3JtYXQKICAgIDIuIHVzaW5nIG1vZGVsLnNhdmVfbW9kZWwoJ2ZuLmpzb24nKSB1c2luZyBhIHBvcnRhYmxlIGpzb24gZm9ybWF0CiAgICAKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgdGhlIGZ1bmN0aW9uJ3MgZXhlY3V0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBtb2RlbDogICAgICAgdGhlIGZpdHRlZCB4Z2Jvb3N0IG1vZGVsCiAgICA6cGFyYW0gZHVtcF90eXBlOiAgICdwaWNrbGUnIGxlZ2FjeScsIG9yICdqc29uJywgCiAgICA6cGFyYW0gZGVzdF9mb2xkZXI6IHBhdGggZm9yIHNlcmlhbGl6ZWQgbW9kZWwgCiAgICA6cGFyYW0gZGVzdF9uYW1lOiAgIG5hbWUgZm9yIHNlcmlhbGl6ZWQgbW9kZWwgZmlsZQogICAgIiIiCiAgICBmcm9tIGNsb3VkcGlja2xlIGltcG9ydCBkdW1wcwogICAgdHJ5OgogICAgICAgIG1vZGVsLnNhdmVfbW9kZWwoZiJ7ZGVzdF9mb2xkZXJ9L3tkZXN0X25hbWV9LWxlZ2FjeS1zYXZlLnBrbCIpCiAgICAgICAgCiAgICAgICAgbW9kZWwuc2F2ZV9tb2RlbChmIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0tZXhwLXNhdmUuanNvbiIpCiAgICAgICAgCiAgICAgICAgX2Jvb3N0ZXIgPSBtb2RlbC5nZXRfYm9vc3RlcigpCiAgICAgICAgZHVtcChfYm9vc3Rlciwgb3BlbihmIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0tbGVnYWN5LWR1bXAucGtsIiwgIndiIikpCiAgICAgICAgCiAgICAgICAgZGF0YSA9IGR1bXBzKF9ib29zdGVyKQogICAgICAgIGNvbnRleHQubG9nX2FydGlmYWN0KCdtb2RlbCcsIGJvZHk9ZGF0YSwgbG9jYWxfcGF0aD1mIntkZXN0X2ZvbGRlcn0ve2Rlc3RfbmFtZX0ucGtsIikKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBwcmludCgneGdib29zdCBtb2RlbCBzZXJpYWxpemF0aW9uIGVycm9yJywgc3RyKGUpKQoKZGVmIGdlbl9wcm9iYSgKICAgIGNvbnRleHQsCiAgICBmZWF0cywKICAgIGxhYmVscywKICAgIG1vZGVsLAogICAgc2NvcmVfbWV0aG9kLAogICAgcGxvdHNfZGVzdCwKICAgIG50cmVlX2xpbWl0PU5vbmUsCiAgICB2YWxpZGF0ZV9mZWF0dXJlcz1UcnVlLAogICAgYmFzZV9tYXJnaW49Tm9uZQopOgogICAgIiIiIGdlbmVyYXRlIHByZWRpY3Rpb25zIGFuZCB2YWxpZGF0aW9uIHN0YXRzCiAgICAKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjb250ZXh0CiAgICA6cGFyYW0gZmVhdHM6ICAgICAgICAgICAgIHZhbGlkYXRpb24gZmVhdHVyZXMgYXJyYXkgCiAgICA6cGFyYW0gbGFiZWxzOiAgICAgICAgICAgIHZhbGlkYXRpb24gZ3JvdW5kLXRydXRoIGxhYmVscwogICAgOnBhcmFtIG1vZGVsOiAgICAgICAgICAgICBlc3RpbWF0ZWQgbW9kZWwKICAgIDpwYXJhbSBzY3JvcmVfbWV0aG9kOiAgICAgKCdhdmVyYWdlJykgbXVsdGljbGFzcyBzY29yaW5nCiAgICA6cGFyYW0gcGxvdHNfZGVzdDogICAgICAgIGRlc3RpbmF0aW9uIGZvbGRlciBmb3IgcGxvdCBhcnRpZmFjdHMKICAgIDpwYXJhbSBudHJlZV9saW1pdDogICAgICAgKE5vbmUpIGxpbWl0IG5vLiB0cmVlcyB1c2VkIGluIHByZWRpY3Rpb24KICAgIDpwYXJhbSB2YWxpZGF0ZV9mZWF0dXJlczogKFRydWUpIGVuc3VyZSBjb25zaXN0ZW50IGZlYXR1cmUgbmFtZXMgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldHdlZW4gbW9kZWwgYW5kIGlucHV0IGRhdGEKICAgIDpwYXJhbSBiYXNlX21hcmdpbjogICAgICAgKE5vbmUpIHVuZGVmaW5lZAogICAgIiIiCiAgICBmcm9tIHNrbGVhcm4gaW1wb3J0IG1ldHJpY3MKICAgIGZyb20gbWxydW4uYXJ0aWZhY3RzIGltcG9ydCBQbG90QXJ0aWZhY3QKICAgIGZyb20gbWxydW4ubWx1dGlscyBpbXBvcnQgZ2ZjX2NsZWFyCiAgICAKICAgIHlwcmVkID0gbW9kZWwucHJlZGljdChmZWF0cywgRmFsc2UsIG50cmVlX2xpbWl0LCB2YWxpZGF0ZV9mZWF0dXJlcywgYmFzZV9tYXJnaW4pCgogICAgeV9wcm9iYSA9IFtdCiAgICBpZiBoYXNhdHRyKG1vZGVsLCAicHJlZGljdF9wcm9iYSIpOgogICAgICAgIHlfcHJvYmEgPSBtb2RlbC5wcmVkaWN0X3Byb2JhKGZlYXRzLCBudHJlZV9saW1pdCwgdmFsaWRhdGVfZmVhdHVyZXMsIGJhc2VfbWFyZ2luKQoKICAgIGF2ZXJhZ2VfcHJlY2lzaW9uID0gbWV0cmljcy5hdmVyYWdlX3ByZWNpc2lvbl9zY29yZShsYWJlbHMsIHlfcHJvYmFbOiwtMV0sIGF2ZXJhZ2U9c2NvcmVfbWV0aG9kKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYiYXZnX3ByZWNpc2lvbiIsIGF2ZXJhZ2VfcHJlY2lzaW9uKQogICAgY29udGV4dC5sb2dfcmVzdWx0KGYicm9jYXVjIiwgbWV0cmljcy5yb2NfYXVjX3Njb3JlKGxhYmVscywgeV9wcm9iYVs6LC0xXSkpCiAgICBjb250ZXh0LmxvZ19yZXN1bHQoZiJhY2N1cmFjeSIsIGZsb2F0KG1vZGVsLnNjb3JlKGZlYXRzLCBsYWJlbHMpKSkKICAgIGNvbnRleHQubG9nX3Jlc3VsdChmImYxX3Njb3JlIiwgbWV0cmljcy5mMV9zY29yZShsYWJlbHMsIHlwcmVkLCBhdmVyYWdlPXNjb3JlX21ldGhvZCkpCiAgICAKICAgIGNvbnRleHQubG9nX2FydGlmYWN0KFBsb3RBcnRpZmFjdCgicm9jIiwgYm9keT1wbG90X3JvYyhjb250ZXh0LCB5dmEsIHlfcHJvYmEpKSwKICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsX3BhdGg9ZiJ7cGxvdHNfZGVzdH0vcm9jLmh0bWwiKQogICAgZ2NmX2NsZWFyKHBsdCkKICAgIAogICAgbWV0cmljcy5wbG90X2NvbmZ1c2lvbl9tYXRyaXgobW9kZWwsIGZlYXRzLCBsYWJlbHMsIGxhYmVscz1sYWJlbHMudW5pcXVlKCksIG5vcm1hbGl6ZT0ndHJ1ZScpIAogICAgY29udGV4dC5sb2dfYXJ0aWZhY3QoUGxvdEFydGlmYWN0KCJjb25mdXNpb24iLCBib2R5PXBsdC5nY2YoKSksIGxvY2FsX3BhdGg9ZiJ7cGxvdHNfZGVzdH0vY29uZnVzaW9uLmh0bWwiKQogICAgCiAgICByZXR1cm4geV9wcm9iYQoKZGVmIHBsb3Rfcm9jKAogICAgY29udGV4dCwKICAgIHlfbGFiZWxzLAogICAgeV9wcm9icywKICAgIGZwcl9sYWJlbDogc3RyID0gImZhbHNlIHBvc2l0aXZlIHJhdGUiLAogICAgdHByX2xhYmVsOiBzdHIgPSAidHJ1ZSBwb3NpdGl2ZSByYXRlIiwKICAgIHRpdGxlOiBzdHIgPSAicm9jIGN1cnZlIiwKICAgIGxlZ2VuZF9sb2M6IHN0ciA9ICJiZXN0IiwKKToKICAgICIiInBsb3Qgcm9jIGN1cnZlcwoKICAgIFRPRE86ICBhZGQgYXZlcmFnaW5nIG1ldGhvZCAoYXMgc3RyaW5nKSB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBwcm9icywgCiAgICBkaXNwbGF5IGluIGxlZ2VuZAoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgIHRoZSBmdW5jdGlvbiBjb250ZXh0CiAgICA6cGFyYW0geV9sYWJlbHM6ICAgICBncm91bmQgdHJ1dGggbGFiZWxzLCBob3QgZW5jb2RlZCBmb3IgbXVsdGljbGFzcyAgCiAgICA6cGFyYW0geV9wcm9iczogICAgICBtb2RlbCBwcmVkaWN0aW9uIHByb2JhYmlsaXRpZXMKICAgIDpwYXJhbSBrZXk6ICAgICAgICAgICgicm9jIikga2V5IG9mIHBsb3QgaW4gYXJ0aWZhY3Qgc3RvcmUKICAgIDpwYXJhbSBwbG90c19kaXI6ICAgICgicGxvdHMiKSBkZXN0aW5hdGlvbiBmb2xkZXIgcmVsYXRpdmUgcGF0aCB0byBhcnRpZmFjdCBwYXRoCiAgICA6cGFyYW0gZm10OiAgICAgICAgICAoInBuZyIpIHBsb3QgZm9ybWF0CiAgICA6cGFyYW0gZnByX2xhYmVsOiAgICAoImZhbHNlIHBvc2l0aXZlIHJhdGUiKSB4LWF4aXMgbGFiZWxzCiAgICA6cGFyYW0gdHByX2xhYmVsOiAgICAoInRydWUgcG9zaXRpdmUgcmF0ZSIpIHktYXhpcyBsYWJlbHMKICAgIDpwYXJhbSB0aXRsZTogICAgICAgICgicm9jIGN1cnZlIikgdGl0bGUgb2YgcGxvdAogICAgOnBhcmFtIGxlZ2VuZF9sb2M6ICAgKCJiZXN0IikgbG9jYXRpb24gb2YgcGxvdCBsZWdlbmQKICAgICIiIgogICAgZnJvbSBza2xlYXJuIGltcG9ydCBtZXRyaWNzCiAgICBpbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CiAgICBmcm9tIG1scnVuLm1sdXRpbHMgaW1wb3J0IGdmY19jbGVhcgogICAgCiAgICBnY2ZfY2xlYXIocGx0KQoKICAgIHBsdC5wbG90KFswLCAxXSwgWzAsIDFdLCAiay0tIikKCiAgICBwbHQueGxhYmVsKGZwcl9sYWJlbCkKICAgIHBsdC55bGFiZWwodHByX2xhYmVsKQogICAgcGx0LnRpdGxlKHRpdGxlKQogICAgcGx0LmxlZ2VuZChsb2M9bGVnZW5kX2xvYykKCiAgICBpZiB5X2xhYmVscy5zaGFwZVsxXSA+IDE6CiAgICAgICAgZnByID0gZGljdCgpCiAgICAgICAgdHByID0gZGljdCgpCiAgICAgICAgcm9jX2F1YyA9IGRpY3QoKQogICAgICAgIGZvciBpIGluIHJhbmdlKHlfbGFiZWxzWzosIDotMV0uc2hhcGVbMV0pOgogICAgICAgICAgICBmcHJbaV0sIHRwcltpXSwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKAogICAgICAgICAgICAgICAgeV9sYWJlbHNbOiwgaV0sIHlfcHJvYnNbOiwgaV0sIHBvc19sYWJlbD0xCiAgICAgICAgICAgICkKICAgICAgICAgICAgcm9jX2F1Y1tpXSA9IG1ldHJpY3MuYXVjKGZwcltpXSwgdHByW2ldKQogICAgICAgICAgICBwbHQucGxvdChmcHJbaV0sIHRwcltpXSwgbGFiZWw9ZiJjbGFzcyB7aX0iKQogICAgZWxzZToKICAgICAgICBmcHIsIHRwciwgXyA9IG1ldHJpY3Mucm9jX2N1cnZlKHlfbGFiZWxzLCB5X3Byb2JzWzosIDFdLCBwb3NfbGFiZWw9MSkKICAgICAgICBwbHQucGxvdChmcHIsIHRwciwgbGFiZWw9ZiJwb3NpdGl2ZSBjbGFzcyIpCgogICAgcmV0dXJuIHBsdC5nY2YoKQoKZGVmIHRyYWluX21vZGVsKAogICAgY29udGV4dCwKICAgIG1vZGVsX3R5cGU6IHN0ciwKICAgIGRhdGFzZXQsCiAgICBsYWJlbF9jb2x1bW46IHN0ciA9ICJsYWJlbHMiLAogICAgc2FtcGxlOiBpbnQgPSAtMSwKICAgIHRlc3Rfc2l6ZTogZmxvYXQgPSAwLjA1LAogICAgdmFsaWRfc2l6ZTogZmxvYXQgPSAwLjc1LAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSAxLAogICAgbW9kZWxfZmlsZW5hbWU6IHN0ciA9ICJtb2RlbCIsCiAgICBtb2RlbHNfZGVzdDogc3RyID0gIiIsCiAgICBwbG90c19kZXN0OiBzdHIgPSAiIiwKICAgIHNjb3JlX21ldGhvZDogc3RyID0gIm1pY3JvIiwKICAgIGZpbGVfZXh0OiBzdHIgPSAicGFycXVldCIsCiAgICBtb2RlbF9wa2dfZmlsZTogc3RyID0gIiIsICAgIAopIC0+IE5vbmU6CiAgICAiIiJ0cmFpbiBhbiB4Z2Jvb3N0IG1vZGVsLgoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgdGhlIGZ1bmN0aW9uIGNvbnRleHQKICAgIDpwYXJhbSBtb2RlbF9wa2dfY2xhc3M6ICAgdGhlIG1vZGVsIHRvIHRyYWluLCBlLmcsICJza2xlYXJuLm5ldXJhbF9uZXR3b3Jrcy5NTFBDbGFzc2lmaWVyIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGpzb24gbW9kZWwgY29uZmlnCiAgICA6cGFyYW0gZGF0YXNldDogICAgICAgICAgICgiZGF0YSIpIG5hbWUgb2YgcmF3IGRhdGEgZmlsZQogICAgOnBhcmFtIGxhYmVsX2NvbHVtbjogICAgICBncm91bmQtdHJ1dGggKHkpIGxhYmVscwogICAgOnBhcmFtIHNhbXBsZTogICAgICAgICAgICBTZWxlY3RzIHRoZSBmaXJzdCBuIHJvd3MsIG9yIHNlbGVjdCBhIHNhbXBsZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGluZyBmcm9tIHRoZSBmaXJzdC4gSWYgbmVnYXRpdmUgPC0xLCBzZWxlY3QKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSByYW5kb20gc2FtcGxlCiAgICA6cGFyYW0gbW9kZWxfZmlsZW5hbWU6ICAgIG1vZGVsIGZpbGUgZmlsZW5hbWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyB0byBhIGRpcmVjdG9yeQogICAgOnBhcmFtIHRlc3Rfc2l6ZTogICAgICAgICAoMC4wNSkgdGVzdCBzZXQgc2l6ZQogICAgOnBhcmFtIHZhbGlkX3NpemU6ICAgICAgICAgICgwLjc1KSBPbmNlIHRoZSB0ZXN0IHNldCBoYXMgYmVlbiByZW1vdmVkIHRoZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbmluZyBzZXQgZ2V0cyB0aGlzIHByb3BvcnRpb24uCiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICgxKSBza2xlYXJuIHJuZyBzZWVkCiAgICA6cGFyYW0gbW9kZWxzX2Rlc3Q6ICAgICAgIG1vZGVscyBzdWJmb2xkZXIgb24gYXJ0aWZhY3QgcGF0aAogICAgOnBhcmFtIHBsb3RzX2Rlc3Q6ICAgICAgICBwbG90IHN1YmZvbGRlciBvbiBhcnRpZmFjdCBwYXRoCiAgICA6cGFyYW0gc2NvcmVfbWV0aG9kOiAgICAgIGZvciBtdWx0aWNsYXNzIGNsYXNzaWZpY2F0aW9uCiAgICAKICAgIDpwYXJhbSBmaWxlX2V4dDogICAgICAgICAgZm9ybWF0IGZvciB0ZXN0X3NldF9rZXkgaG9sZCBvdXQgZGF0YQogICAgOnBhcmFtIG1vZGVsX3BrZ19maWxlOiAgICBqc29uIG1vZGVsIGNvbmZpZyBmaWxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgIiIiCiAgICBtb2RlbHNfZGVzdCA9IG1vZGVsc19kZXN0IG9yICdtb2RlbHMnCiAgICBwbG90c19kZXN0ID0gcGxvdHNfZGVzdCBvciBmJ3Bsb3RzL3tjb250ZXh0Lm5hbWV9JwogICAgCiAgICByYXcsIGxhYmVscywgaGVhZGVyID0gZ2V0X3NhbXBsZShzdHIoZGF0YXNldCksIHNhbXBsZSwgbGFiZWxfY29sdW1uKQogICAgCiAgICAoeHRyLHl0ciksICh4dmEseXZhKSwgKHh0ZSx5dGUpID0gZ2V0X3NwbGl0cyhyYXcsIGxhYmVscywgdGVzdF9zaXplLCB2YWxpZF9zaXplLCByYW5kb21fc3RhdGUpCiAgICAgICAgCiAgICBtb2RlbCwgbW9kZWxfY29uZmlnID0gZ2VuX3hnYl9tb2RlbChtb2RlbF90eXBlLCBjb250ZXh0LnBhcmFtZXRlcnMuaXRlbXMoKSkKICAgIAogICAgbW9kZWxfY29uZmlnWyJGSVQiXS51cGRhdGUoeyJYIjogeHRyLCJ5IjogeXRyLnZhbHVlc30pCiAgICAKICAgIG1vZGVsLmZpdCgqKm1vZGVsX2NvbmZpZ1siRklUIl0pCiAgICAKICAgIGR1bXBfeGdiX21vZGVsKGNvbnRleHQsIG1vZGVsLCAnanNvbicsIG1vZGVsc19kZXN0LCBtb2RlbF9maWxlbmFtZSkKCiAgICB5X3Byb2JhID0gZ2VuX3Byb2JhKGNvbnRleHQsIHh2YSwgeXZhLCBtb2RlbCwgc2NvcmVfbWV0aG9kLCBwbG90c19kZXN0KQoK
    commands: []
    code_origin: https://github.com/yjb-ds/functions.git#66782f61a5f06b6c9880f694c6fabfa72df51385:xgb_trainer.ipynb
